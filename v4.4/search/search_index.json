{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"license/","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"api/csdo/","text":"SDO Client # The CSDO component provides an interface to the CANopen SDO client. Module Context # classDiagram CO_NODE o-- CO_CSDO : Node CO_FRM o-- CO_CSDO : Frm CO_CSDO_STATE o-- CO_CSDO : State CO_CSDO_TRANSFER o-- CO_CSDO : Tfer class CO_CSDO { -uint32_t RxId -uint32_t TxId -uint8_t NodeId +COCSdoFind(num) +COCSdoRequestUpload(key, buffer, size, callback, timeout) +COCSdoRequestDownload(key, buffer, size, callback, timeout) } class CO_CSDO_STATE { <<enumeration>> } Structure Data # The class CO_CSDO is defined within co_csdo.h and is responsible for the CANopen SDO client handling. The following data members are in this class: Data Member Type Description TxId uint32_t COB-ID for the transmitted SDO request RxId uint32_t COB-ID for the received SDO response NodeId uint8_t Node-Id of addressed SDO server Info The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node. Member Functions # The following chapters describes the API functions of the CANopen SDO client module. These functions are implemented within the source file: co_csdo.c/h COCSdoFind() # The function checks the availability of the given SDO client index and returns the corresponding CO_CSDO object. Prototype CO_CSDO * COCSdoFind ( CO_NODE * node , uint8_t num ); Arguments Parameter Description node Pointer to parent CANopen node num SDO client number (1..127) Returned Value The function returns a valid CO_CSDO object when addressed SDO client is ready for initiating a new transfer. Otherwise, an invalid CO_CSDO object is returned. Example The following example checks the state of SDO client #2. CO_CSDO * csdo ; : csdo = COCSdoFind ( & ( AppNode ), 2 ); if ( csdo == 0 ) { /* SDO client #2 is missing or busy */ } else { /* SDO client #2 is usable */ } : COCSdoRequestDownload() # The function starts an SDO download transfer in the calling node to write data to the configured SDO server node-id. When the size of data transfer is lower or equal 4 an expedited transfer is used, otherwise a segmented transfer is initiated. Prototype CO_ERR COCSdoRequestDownload ( CO_CSDO * csdo , uint32_t key , uint8_t * buffer , uint32_t size , CO_CSDO_CALLBACK_T callback , uint32_t timeout ); Arguments Parameter Description csdo Pointer to SDO client object key destination object entry on SDO server Node-Id buffer pointer to buffer with data size size in byte of data within the buffer callback user provided callback for transfer finalization timeout transfer timeout in milliseconds Returned Value The function returns CO_ERR_NONE when transfer is initiated successfully. Any other error code indicates, that the transfer is not started. Example The following example writes a 32bit value to the remote node object dictionary entry [ 1234h:02 ] with SDO client #1 and a transfer timeout of 1s. uint32_t writeValue = 0 ; /* The application specific SDO transfer finalization callback */ void AppCSdoFinishCb ( CO_CSDO * csdo , uint16_t index , uint8_t sub , uint32_t code ) { if ( code == 0 ) { /* data written successfully in remote node */ } else { /* a timeout or abort is detected during SDO transfer */ } } /* somewhere in your application: */ void foo () { CO_CSDO * csdo ; CO_ERR err ; : csdo = COCSdoFind ( & ( AppNode ), 1 ); writeValue = 42 ; err = COCSdoRequestDownload ( csdo , CO_DEV ( 1234 , 02 ), & writeValue , sizeof ( writeValue ), AppCSdoFinishCb , 1000 ); if ( err == CO_ERR_NONE ) { /* Transfer is started successfully */ /* Note: don't change the 'writeValue' until transfer is finished! */ } else { /* Unable to start the SDO transfer */ } : } COCSdoRequestUpload() # The function starts an SDO upload transfer in the calling node to read data from the configured SDO server node-id. When the size of data transfer is lower or equal 4 an expedited transfer is used, otherwise a segmented transfer is initiated. Prototype CO_ERR COCSdoRequestUpload ( CO_CSDO * csdo , uint32_t key , uint8_t * buffer , uint32_t size , CO_CSDO_CALLBACK_T callback , uint32_t timeout ); Arguments Parameter Description csdo Pointer to SDO client object key destination object entry on SDO server Node-Id buffer pointer to buffer with data size size in byte of data within the buffer callback user provided callback for transfer finalization timeout transfer timeout in milliseconds Returned Value The function returns CO_ERR_NONE when transfer is initiated successfully. Any other error code indicates, that the transfer is not started. Example The following example reads a 32 bytes from the remote node object dictionary entry [ 1234h:02 ] with SDO client #1 and a transfer timeout of 1s. uint8_t readValue [ 32 ] = { 0 }; /* The application specific SDO transfer finalization callback */ void AppCSdoFinishCb ( CO_CSDO * csdo , uint16_t index , uint8_t sub , uint32_t code ) { if ( code == 0 ) { /* read data is available in 'readValue' */ } else { /* a timeout or abort is detected during SDO transfer */ } } /* somewhere in your application: */ void foo () { CO_CSDO * csdo ; CO_ERR err ; : csdo = COCSdoFind ( & ( AppNode ), 1 ); err = COCSdoRequestUpload ( csdo , CO_DEV ( 1234 , 02 ), & readValue , 32 , AppCSdoFinishCb , 1000 ); if ( err == CO_ERR_NONE ) { /* Transfer is started successfully */ /* Note: don't use the 'readValue' until transfer is finished! */ } else { /* Unable to start the SDO transfer */ } : }","title":"SDO Client"},{"location":"api/csdo/#sdo-client","text":"The CSDO component provides an interface to the CANopen SDO client.","title":"SDO Client"},{"location":"api/csdo/#module-context","text":"classDiagram CO_NODE o-- CO_CSDO : Node CO_FRM o-- CO_CSDO : Frm CO_CSDO_STATE o-- CO_CSDO : State CO_CSDO_TRANSFER o-- CO_CSDO : Tfer class CO_CSDO { -uint32_t RxId -uint32_t TxId -uint8_t NodeId +COCSdoFind(num) +COCSdoRequestUpload(key, buffer, size, callback, timeout) +COCSdoRequestDownload(key, buffer, size, callback, timeout) } class CO_CSDO_STATE { <<enumeration>> }","title":"Module Context"},{"location":"api/csdo/#structure-data","text":"The class CO_CSDO is defined within co_csdo.h and is responsible for the CANopen SDO client handling. The following data members are in this class: Data Member Type Description TxId uint32_t COB-ID for the transmitted SDO request RxId uint32_t COB-ID for the received SDO response NodeId uint8_t Node-Id of addressed SDO server Info The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node.","title":"Structure Data"},{"location":"api/csdo/#member-functions","text":"The following chapters describes the API functions of the CANopen SDO client module. These functions are implemented within the source file: co_csdo.c/h","title":"Member Functions"},{"location":"api/csdo/#cocsdofind","text":"The function checks the availability of the given SDO client index and returns the corresponding CO_CSDO object. Prototype CO_CSDO * COCSdoFind ( CO_NODE * node , uint8_t num ); Arguments Parameter Description node Pointer to parent CANopen node num SDO client number (1..127) Returned Value The function returns a valid CO_CSDO object when addressed SDO client is ready for initiating a new transfer. Otherwise, an invalid CO_CSDO object is returned. Example The following example checks the state of SDO client #2. CO_CSDO * csdo ; : csdo = COCSdoFind ( & ( AppNode ), 2 ); if ( csdo == 0 ) { /* SDO client #2 is missing or busy */ } else { /* SDO client #2 is usable */ } :","title":"COCSdoFind()"},{"location":"api/csdo/#cocsdorequestdownload","text":"The function starts an SDO download transfer in the calling node to write data to the configured SDO server node-id. When the size of data transfer is lower or equal 4 an expedited transfer is used, otherwise a segmented transfer is initiated. Prototype CO_ERR COCSdoRequestDownload ( CO_CSDO * csdo , uint32_t key , uint8_t * buffer , uint32_t size , CO_CSDO_CALLBACK_T callback , uint32_t timeout ); Arguments Parameter Description csdo Pointer to SDO client object key destination object entry on SDO server Node-Id buffer pointer to buffer with data size size in byte of data within the buffer callback user provided callback for transfer finalization timeout transfer timeout in milliseconds Returned Value The function returns CO_ERR_NONE when transfer is initiated successfully. Any other error code indicates, that the transfer is not started. Example The following example writes a 32bit value to the remote node object dictionary entry [ 1234h:02 ] with SDO client #1 and a transfer timeout of 1s. uint32_t writeValue = 0 ; /* The application specific SDO transfer finalization callback */ void AppCSdoFinishCb ( CO_CSDO * csdo , uint16_t index , uint8_t sub , uint32_t code ) { if ( code == 0 ) { /* data written successfully in remote node */ } else { /* a timeout or abort is detected during SDO transfer */ } } /* somewhere in your application: */ void foo () { CO_CSDO * csdo ; CO_ERR err ; : csdo = COCSdoFind ( & ( AppNode ), 1 ); writeValue = 42 ; err = COCSdoRequestDownload ( csdo , CO_DEV ( 1234 , 02 ), & writeValue , sizeof ( writeValue ), AppCSdoFinishCb , 1000 ); if ( err == CO_ERR_NONE ) { /* Transfer is started successfully */ /* Note: don't change the 'writeValue' until transfer is finished! */ } else { /* Unable to start the SDO transfer */ } : }","title":"COCSdoRequestDownload()"},{"location":"api/csdo/#cocsdorequestupload","text":"The function starts an SDO upload transfer in the calling node to read data from the configured SDO server node-id. When the size of data transfer is lower or equal 4 an expedited transfer is used, otherwise a segmented transfer is initiated. Prototype CO_ERR COCSdoRequestUpload ( CO_CSDO * csdo , uint32_t key , uint8_t * buffer , uint32_t size , CO_CSDO_CALLBACK_T callback , uint32_t timeout ); Arguments Parameter Description csdo Pointer to SDO client object key destination object entry on SDO server Node-Id buffer pointer to buffer with data size size in byte of data within the buffer callback user provided callback for transfer finalization timeout transfer timeout in milliseconds Returned Value The function returns CO_ERR_NONE when transfer is initiated successfully. Any other error code indicates, that the transfer is not started. Example The following example reads a 32 bytes from the remote node object dictionary entry [ 1234h:02 ] with SDO client #1 and a transfer timeout of 1s. uint8_t readValue [ 32 ] = { 0 }; /* The application specific SDO transfer finalization callback */ void AppCSdoFinishCb ( CO_CSDO * csdo , uint16_t index , uint8_t sub , uint32_t code ) { if ( code == 0 ) { /* read data is available in 'readValue' */ } else { /* a timeout or abort is detected during SDO transfer */ } } /* somewhere in your application: */ void foo () { CO_CSDO * csdo ; CO_ERR err ; : csdo = COCSdoFind ( & ( AppNode ), 1 ); err = COCSdoRequestUpload ( csdo , CO_DEV ( 1234 , 02 ), & readValue , 32 , AppCSdoFinishCb , 1000 ); if ( err == CO_ERR_NONE ) { /* Transfer is started successfully */ /* Note: don't use the 'readValue' until transfer is finished! */ } else { /* Unable to start the SDO transfer */ } : }","title":"COCSdoRequestUpload()"},{"location":"api/dictionary/","text":"Object Dictionary # The object dictionary component provides the interface to object entries in the object dictionary. Module Context # classDiagram CO_NODE o-- CO_DICT : Node CO_OBJ o-- CO_DICT : Root CO_ERR -- CO_DICT class CO_DICT { -uint16_t Num -uint16_t Max +CODictFind(key) CO_OBJ +CODictRdBuffer(key, destination, size) CO_ERR +CODictRdByte(key, destination) CO_ERR +CODictRdLong(key, destination) CO_ERR +CODictRdWord(key, destination) CO_ERR +CODictWrBuffer(key, source, size) CO_ERR +CODictWrByte(key, value) CO_ERR +CODictWrLong(key, value) CO_ERR +CODictWrWord(key, value) CO_ERR } class CO_ERR { <<enumeration>> } Structure Data # The class CO_DICT is defined within co_dict.h and is responsible for the object dictionary handling functions. The following data members are allocated in this class: Data Member Type Description Max uint16_t maximum number of objects in dictionary Node CO_NODE* pointer to parent node Num uint16_t current number of objects in dictionary Root CO_OBJ* pointer to the first object in object dictionary Info The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node. Member Functions # Warning The access with the member functions of this class to an object entry must be done with the correct width. There is no casting of the object entry values to the requested value types. The following table describes the API functions of the object dictionary module. These functions are implemented within the source file: co_dict.c/h CODictFind() # The function is often called from the application to get an object entry. If an object entry is not found, this generates no stack error. Prototype CO_OBJ * CODictFind ( CO_DICT * cod , uint32_t key ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV Returned Value >0 : pointer to identified object entry =0 : object entry is not found Example The following example checks the existence of the mandatory object entry \"[1017:00] - Heartbeat\" within the object dictionary of the CANopen node AppNode. CO_OBJ * obj ; : obj = CODictFind ( & ( Appnode . Dict ), CO_DEV ( 0x1017 , 0x00 )); if ( obj == 0 ) { /* object [1017:00] is missing */ } else { /* object [1017:00] is available */ } : Note When using a static object dictionary, you can store and reuse the pointer to the identified object entry with the Object Entry access functions. The pointer to the object entry will NOT change during runtime in a static object dictionary. Important The CANopen Stack relies on a binary search algorithm to ensure that object dictionary entries are found quickly. Because of this, you must keep the index / subindex of all entries in the object dictionary sorted in ascending order. CODictRdBuffer() # The object entry is addressed with the given key and the bytes will be read from the dictionary and copied to the given destination buffer with the given length. Prototype CO_ERR CODictRdBuffer ( CO_DICT * cod , uint32_t key , uint8_t * buffer , uint32_t size ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV buffer pointer to the destination bytes size size of destination buffer in number of bytes Returned Value == CO_ERR_NONE : successful operation != CO_ERR_NONE : an error is detected Example The following example reads the value to the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. CO_ERR err ; uint8_t buffer [ 10 ]; : err = CODictRdBuffer ( & ( Appnode . Dict ), CO_DEV ( 0x1234 , 0x56 ), buffer , 10 ); if ( err != CO_ERR_NONE ) { /* object [1234:56] is missing or error during writing */ } : CODictRdByte() # The object entry is addressed with the given key and the value will be written to the given destination pointer. Prototype CO_ERR CODictRdByte ( CO_DICT * cod , uint32_t key , uint8_t * value ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV value pointer to value destination Returned Value == CO_ERR_NONE : successful operation != CO_ERR_NONE : an error is detected Example The following example reads the current value of the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. CO_ERR err ; uint8_t value ; : err = CODictRdByte ( & ( Appnode . Dict ), CO_DEV ( 0x1234 , 0x56 ), & value ); if ( err != CO_ERR_NONE ) { /* object [1234:56] is missing or error during reading */ } else { /* value holds the content of object [1234:56] */ } : Note This function uses CODictFind() on each function call. To improve access performance for multiple accesses to a single object entry, the application may use CODictFind() once and COObjRdValue() multiple times. CODictRdLong() # The object entry is addressed with the given key and the value will be written to the given destination pointer. Prototype CO_ERR CODictRdLong ( CO_DICT * cod , uint32_t key , uint32_t * value ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV value pointer to value destination Returned Value == CO_ERR_NONE : successful operation != CO_ERR_NONE : an error is detected Example The following example reads the current value of the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. CO_ERR err ; uint32_t value ; : err = CODictRdLong ( & ( Appnode . Dict ), CO_DEV ( 0x1234 , 0x56 ), & value ); if ( err != CO_ERR_NONE ) { /* object [1234:56] is missing or error during reading */ } else { /* value holds the content of object [1234:56] */ } : Note This function uses CODictFind() on each function call. To improve access performance for multiple accesses to a single object entry, the application may use CODictFind() once and COObjRdValue() multiple times. CODictRdWord() # The object entry is addressed with the given key and the value will be written to the given destination pointer. Prototype CO_ERR CODictRdWord ( CO_DICT * cod , uint32_t key , uint16_t * value ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV value pointer to value destination Returned Value == CO_ERR_NONE : successful operation != CO_ERR_NONE : an error is detected Example The following example reads the current value of the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. CO_ERR err ; uint16_t value ; : err = CODictRdWord ( & ( Appnode . Dict ), CO_DEV ( 0x1234 , 0x56 ), & value ); if ( err != CO_ERR_NONE ) { /* object [1234:56] is missing or error during reading */ } else { /* value holds the content of object [1234:56] */ } : Note This function uses CODictFind() on each function call. To improve access performance for multiple accesses to a single object entry, the application may use CODictFind() once and COObjRdValue() multiple times. CODictWrBuffer() # The object entry is addressed with the given key and the bytes will be read from to the given source buffer of the given size. Prototype CO_ERR CODictWrBuffer ( CO_DICT * cod , uint32_t key , uint8_t * buffer , uint32_t size ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV buffer pointer to the source bytes size size of source buffer Returned Value == CO_ERR_NONE : successful operation != CO_ERR_NONE : an error is detected Example The following example writes the value to the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. CO_ERR err ; uint8_t buffer [ 10 ] = { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 0 }; : err = CODictWrBuffer ( & ( Appnode . Dict ), CO_DEV ( 0x1234 , 0x56 ), buffer , 10 ); if ( err != CO_ERR_NONE ) { /* object [1234:56] is missing or error during writing */ } : CODictWrByte() # The object entry is addressed with the given key. Prototype CO_ERR CODictWrByte ( CO_DICT * cod , uint32_t key , uint8_t value ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV value the source value Returned Value == CO_ERR_NONE : successful operation != CO_ERR_NONE : an error is detected Example The following example writes the value to the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. CO_ERR err ; uint8_t value = 0x30 ; : err = CODictWrByte ( & ( Appnode . Dict ), CO_DEV ( 0x1234 , 0x56 ), value ); if ( err != CO_ERR_NONE ) { /* object [1234:56] is missing or error during writing */ } : Note This function uses CODictFind() on each function call. To improve access performance for multiple accesses to a single object entry, the application may use CODictFind() once and COObjWrValue() multiple times. CODictWrLong() # The object entry is addressed with the given key. Prototype CO_ERR CODictWrLong ( CO_DICT * cod , uint32_t key , uint32_t value ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV value the source value Returned Value == CO_ERR_NONE : successful operation != CO_ERR_NONE : an error is detected Example The following example writes the value to the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. CO_ERR err ; uint32_t value = 0x30 ; : err = CODictWrLong ( & ( Appnode . Dict ), CO_DEV ( 0x1234 , 0x56 ), value ); if ( err != CO_ERR_NONE ) { /* object [1234:56] is missing or error during writing */ } : Note This function uses CODictFind() on each function call. To improve access performance for multiple accesses to a single object entry, the application may use CODictFind() once and COObjWrValue() multiple times. CODictWrWord() # The object entry is addressed with the given key. Prototype CO_ERR CODictWrWord ( CO_DICT * cod , uint32_t key , uint16_t value ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV value the source value Returned Value == CO_ERR_NONE : successful operation != CO_ERR_NONE : an error is detected Example The following example writes the value to the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. CO_ERR err ; uint16_t value = 0x30 ; : err = CODictWrWord ( & ( Appnode . Dict ), CO_DEV ( 0x1234 , 0x56 ), value ); if ( err != CO_ERR_NONE ) { /* object [1234:56] is missing or error during writing */ } : Note This function uses CODictFind() on each function call. To improve access performance for multiple accesses to a single object entry, the application may use CODictFind() once and COObjWrValue() multiple times.","title":"Object Dictionary"},{"location":"api/dictionary/#object-dictionary","text":"The object dictionary component provides the interface to object entries in the object dictionary.","title":"Object Dictionary"},{"location":"api/dictionary/#module-context","text":"classDiagram CO_NODE o-- CO_DICT : Node CO_OBJ o-- CO_DICT : Root CO_ERR -- CO_DICT class CO_DICT { -uint16_t Num -uint16_t Max +CODictFind(key) CO_OBJ +CODictRdBuffer(key, destination, size) CO_ERR +CODictRdByte(key, destination) CO_ERR +CODictRdLong(key, destination) CO_ERR +CODictRdWord(key, destination) CO_ERR +CODictWrBuffer(key, source, size) CO_ERR +CODictWrByte(key, value) CO_ERR +CODictWrLong(key, value) CO_ERR +CODictWrWord(key, value) CO_ERR } class CO_ERR { <<enumeration>> }","title":"Module Context"},{"location":"api/dictionary/#structure-data","text":"The class CO_DICT is defined within co_dict.h and is responsible for the object dictionary handling functions. The following data members are allocated in this class: Data Member Type Description Max uint16_t maximum number of objects in dictionary Node CO_NODE* pointer to parent node Num uint16_t current number of objects in dictionary Root CO_OBJ* pointer to the first object in object dictionary Info The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node.","title":"Structure Data"},{"location":"api/dictionary/#member-functions","text":"Warning The access with the member functions of this class to an object entry must be done with the correct width. There is no casting of the object entry values to the requested value types. The following table describes the API functions of the object dictionary module. These functions are implemented within the source file: co_dict.c/h","title":"Member Functions"},{"location":"api/dictionary/#codictfind","text":"The function is often called from the application to get an object entry. If an object entry is not found, this generates no stack error. Prototype CO_OBJ * CODictFind ( CO_DICT * cod , uint32_t key ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV Returned Value >0 : pointer to identified object entry =0 : object entry is not found Example The following example checks the existence of the mandatory object entry \"[1017:00] - Heartbeat\" within the object dictionary of the CANopen node AppNode. CO_OBJ * obj ; : obj = CODictFind ( & ( Appnode . Dict ), CO_DEV ( 0x1017 , 0x00 )); if ( obj == 0 ) { /* object [1017:00] is missing */ } else { /* object [1017:00] is available */ } : Note When using a static object dictionary, you can store and reuse the pointer to the identified object entry with the Object Entry access functions. The pointer to the object entry will NOT change during runtime in a static object dictionary. Important The CANopen Stack relies on a binary search algorithm to ensure that object dictionary entries are found quickly. Because of this, you must keep the index / subindex of all entries in the object dictionary sorted in ascending order.","title":"CODictFind()"},{"location":"api/dictionary/#codictrdbuffer","text":"The object entry is addressed with the given key and the bytes will be read from the dictionary and copied to the given destination buffer with the given length. Prototype CO_ERR CODictRdBuffer ( CO_DICT * cod , uint32_t key , uint8_t * buffer , uint32_t size ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV buffer pointer to the destination bytes size size of destination buffer in number of bytes Returned Value == CO_ERR_NONE : successful operation != CO_ERR_NONE : an error is detected Example The following example reads the value to the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. CO_ERR err ; uint8_t buffer [ 10 ]; : err = CODictRdBuffer ( & ( Appnode . Dict ), CO_DEV ( 0x1234 , 0x56 ), buffer , 10 ); if ( err != CO_ERR_NONE ) { /* object [1234:56] is missing or error during writing */ } :","title":"CODictRdBuffer()"},{"location":"api/dictionary/#codictrdbyte","text":"The object entry is addressed with the given key and the value will be written to the given destination pointer. Prototype CO_ERR CODictRdByte ( CO_DICT * cod , uint32_t key , uint8_t * value ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV value pointer to value destination Returned Value == CO_ERR_NONE : successful operation != CO_ERR_NONE : an error is detected Example The following example reads the current value of the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. CO_ERR err ; uint8_t value ; : err = CODictRdByte ( & ( Appnode . Dict ), CO_DEV ( 0x1234 , 0x56 ), & value ); if ( err != CO_ERR_NONE ) { /* object [1234:56] is missing or error during reading */ } else { /* value holds the content of object [1234:56] */ } : Note This function uses CODictFind() on each function call. To improve access performance for multiple accesses to a single object entry, the application may use CODictFind() once and COObjRdValue() multiple times.","title":"CODictRdByte()"},{"location":"api/dictionary/#codictrdlong","text":"The object entry is addressed with the given key and the value will be written to the given destination pointer. Prototype CO_ERR CODictRdLong ( CO_DICT * cod , uint32_t key , uint32_t * value ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV value pointer to value destination Returned Value == CO_ERR_NONE : successful operation != CO_ERR_NONE : an error is detected Example The following example reads the current value of the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. CO_ERR err ; uint32_t value ; : err = CODictRdLong ( & ( Appnode . Dict ), CO_DEV ( 0x1234 , 0x56 ), & value ); if ( err != CO_ERR_NONE ) { /* object [1234:56] is missing or error during reading */ } else { /* value holds the content of object [1234:56] */ } : Note This function uses CODictFind() on each function call. To improve access performance for multiple accesses to a single object entry, the application may use CODictFind() once and COObjRdValue() multiple times.","title":"CODictRdLong()"},{"location":"api/dictionary/#codictrdword","text":"The object entry is addressed with the given key and the value will be written to the given destination pointer. Prototype CO_ERR CODictRdWord ( CO_DICT * cod , uint32_t key , uint16_t * value ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV value pointer to value destination Returned Value == CO_ERR_NONE : successful operation != CO_ERR_NONE : an error is detected Example The following example reads the current value of the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. CO_ERR err ; uint16_t value ; : err = CODictRdWord ( & ( Appnode . Dict ), CO_DEV ( 0x1234 , 0x56 ), & value ); if ( err != CO_ERR_NONE ) { /* object [1234:56] is missing or error during reading */ } else { /* value holds the content of object [1234:56] */ } : Note This function uses CODictFind() on each function call. To improve access performance for multiple accesses to a single object entry, the application may use CODictFind() once and COObjRdValue() multiple times.","title":"CODictRdWord()"},{"location":"api/dictionary/#codictwrbuffer","text":"The object entry is addressed with the given key and the bytes will be read from to the given source buffer of the given size. Prototype CO_ERR CODictWrBuffer ( CO_DICT * cod , uint32_t key , uint8_t * buffer , uint32_t size ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV buffer pointer to the source bytes size size of source buffer Returned Value == CO_ERR_NONE : successful operation != CO_ERR_NONE : an error is detected Example The following example writes the value to the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. CO_ERR err ; uint8_t buffer [ 10 ] = { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 0 }; : err = CODictWrBuffer ( & ( Appnode . Dict ), CO_DEV ( 0x1234 , 0x56 ), buffer , 10 ); if ( err != CO_ERR_NONE ) { /* object [1234:56] is missing or error during writing */ } :","title":"CODictWrBuffer()"},{"location":"api/dictionary/#codictwrbyte","text":"The object entry is addressed with the given key. Prototype CO_ERR CODictWrByte ( CO_DICT * cod , uint32_t key , uint8_t value ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV value the source value Returned Value == CO_ERR_NONE : successful operation != CO_ERR_NONE : an error is detected Example The following example writes the value to the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. CO_ERR err ; uint8_t value = 0x30 ; : err = CODictWrByte ( & ( Appnode . Dict ), CO_DEV ( 0x1234 , 0x56 ), value ); if ( err != CO_ERR_NONE ) { /* object [1234:56] is missing or error during writing */ } : Note This function uses CODictFind() on each function call. To improve access performance for multiple accesses to a single object entry, the application may use CODictFind() once and COObjWrValue() multiple times.","title":"CODictWrByte()"},{"location":"api/dictionary/#codictwrlong","text":"The object entry is addressed with the given key. Prototype CO_ERR CODictWrLong ( CO_DICT * cod , uint32_t key , uint32_t value ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV value the source value Returned Value == CO_ERR_NONE : successful operation != CO_ERR_NONE : an error is detected Example The following example writes the value to the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. CO_ERR err ; uint32_t value = 0x30 ; : err = CODictWrLong ( & ( Appnode . Dict ), CO_DEV ( 0x1234 , 0x56 ), value ); if ( err != CO_ERR_NONE ) { /* object [1234:56] is missing or error during writing */ } : Note This function uses CODictFind() on each function call. To improve access performance for multiple accesses to a single object entry, the application may use CODictFind() once and COObjWrValue() multiple times.","title":"CODictWrLong()"},{"location":"api/dictionary/#codictwrword","text":"The object entry is addressed with the given key. Prototype CO_ERR CODictWrWord ( CO_DICT * cod , uint32_t key , uint16_t value ); Arguments Parameter Description cod pointer to the object dictionary key object entry key; should be generated with CO_DEV value the source value Returned Value == CO_ERR_NONE : successful operation != CO_ERR_NONE : an error is detected Example The following example writes the value to the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. CO_ERR err ; uint16_t value = 0x30 ; : err = CODictWrWord ( & ( Appnode . Dict ), CO_DEV ( 0x1234 , 0x56 ), value ); if ( err != CO_ERR_NONE ) { /* object [1234:56] is missing or error during writing */ } : Note This function uses CODictFind() on each function call. To improve access performance for multiple accesses to a single object entry, the application may use CODictFind() once and COObjWrValue() multiple times.","title":"CODictWrWord()"},{"location":"api/emergency/","text":"Emergency # The emergency component provides an interface to the emergency history in the object dictionary and handles the emergency message transmission to the CANopen network. Module Context # classDiagram CO_NODE o-- CO_EMCY : Node CO_EMCY_TBL o-- CO_EMCY : Root CO_EMCY_HIST *-- CO_EMCY : Hist class CO_EMCY { -uint8_t Cnt -uint8_t Err +COEmcyClr(error) +COEmcyCnt() int16_t +COEmcyGet(error) int16_t +COEmcyHistReset() +COEmcyReset(silent) +COEmcySet(error, user) } Structure Data # The class CO_EMCY is defined within co_emcy.h and is responsible for emergency management functions. The following data members are in this class: Data Member Type Description Cnt[] uint8_t error register object entry bit counters Err[] uint8_t individual emergency status storage Hist CO_EMCY_HIST emergency history management object Node CO_NODE* pointer to parent node Root CO_EMCY_TBL* pointer to application emergency table Info The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node. Member Functions # The following table describes the API functions of the emergency module. These functions are implemented within the source file: co_emcy.c/h COEmcyClr() # The EMCY message is transmitted if the error was previously detected. Prototype void COEmcyClr ( CO_EMCY * emcy , uint8_t error ); Arguments Parameter Description emcy pointer to EMCY object error error code identifier in application EMCY table Returned Value none Example The following example demonstrates the clearing of a possible detected emergency event APP_EMCY_2 within the application of the CANopen node AppNode. : COEmcyClr ( & ( AppNode . Emcy ), APP_EMCY_2 ); : Note The emergency identifier APP_EMCY_2 must be defined within the application-specific configuration. COEmcyCnt() # When calling this function, all EMCY error status will stay unchanged. Prototype int16_t COEmcyCnt ( CO_EMCY * emcy ); Arguments Parameter Description emcy pointer to EMCY object Returned Value >=0 : success with the number of currently detected EMCY errors <0 : an error is detected inside of this function Example The following example calculates the current number of detected emergency events within the application of the CANopen node AppNode. int16_t emcy ; : emcy = COEmcyCnt ( & ( AppNode . Emcy )); if ( emcy < 0 ) { /* error handling */ } else { /* emcy holds number of detected emergencies */ } : COEmcyGet() # When calling this function, the EMCY error status will stay unchanged. Prototype int16_t COEmcyGet ( CO_EMCY * emcy , uint8_t error ); Arguments Parameter Description emcy pointer to EMCY object error error code identifier in application EMCY table Returned Value =0 : success with error is not detected =1 : success with an error was detected before <0 : an error is detected inside of this function Example The following example reads the current status of a possible detected emergency event APP_EMCY_2 within the application of the CANopen node AppNode. int16_t warning ; : warning = COEmcyGet ( & ( AppNode . Emcy ), APP_EMCY_2 ); if ( warning < 0 ) { /* error handling */ } else { /* warning holds current emergency status */ } : Note The emergency identifier APP_EMCY_2 must be defined within the application-specific configuration. COEmcyHistReset() # There is no EMCY message transmission due to this function call. Prototype void COEmcyHistReset ( CO_EMCY * emcy ); Arguments Parameter Description emcy pointer to EMCY object Returned Value none Example The following example clears all emergency history entries within the object dictionary of the CANopen node AppNode. : COEmcyHistReset ( & ( AppNode . Emcy )); : COEmcyReset() # The EMCY message transmission can be suppressed by setting the parameter silent to 1. Prototype void COEmcyReset ( CO_EMCY * emcy , uint8_t silent ); Arguments Parameter Description emcy pointer to EMCY object silent disables the EMCY message transmission for the state changes, made by this function Returned Value none Example The following example clears all detected emergency within the application of the CANopen node AppNode. The corresponding emergency state change messages will be sent. : COEmcyReset ( & ( AppNode . Emcy ), 0 ); : COEmcySet() # The EMCY message is transmitted if the error is detected for the first time. The given manufacturer-specific fields are optional, e.g. the pointer may be 0 to set all manufacturer-specific values to 0. Prototype void COEmcySet ( CO_EMCY * emcy , uint8_t err , CO_EMCY_USR * user ); Arguments Parameter Description emcy pointer to EMCY object err error code identifier in application EMCY table user manufacturer-specific fields in EMCY history and/or EMCY message Returned Value none Example The following example demonstrates the detection of an emergency event APP_EMCY_2 within the application of the CANopen node AppNode. The specific user information data for this event is: 0x1234567890. CO_EMCY_USR usr ; : usr . Emcy [ 0 ] = 0x12 ; usr . Emcy [ 1 ] = 0x34 ; usr . Emcy [ 2 ] = 0x56 ; usr . Emcy [ 3 ] = 0x78 ; usr . Emcy [ 4 ] = 0x90 ; COEmcySet ( & ( AppNode . Emcy ), APP_EMCY_2 , & usr ); : Note The specific user information data field is optional. If not used, the last parameter during calling COEmcySet() can be 0 (zero). The emergency identifier APP_EMCY_2 must be defined within the application-specific configuration.","title":"Emergency"},{"location":"api/emergency/#emergency","text":"The emergency component provides an interface to the emergency history in the object dictionary and handles the emergency message transmission to the CANopen network.","title":"Emergency"},{"location":"api/emergency/#module-context","text":"classDiagram CO_NODE o-- CO_EMCY : Node CO_EMCY_TBL o-- CO_EMCY : Root CO_EMCY_HIST *-- CO_EMCY : Hist class CO_EMCY { -uint8_t Cnt -uint8_t Err +COEmcyClr(error) +COEmcyCnt() int16_t +COEmcyGet(error) int16_t +COEmcyHistReset() +COEmcyReset(silent) +COEmcySet(error, user) }","title":"Module Context"},{"location":"api/emergency/#structure-data","text":"The class CO_EMCY is defined within co_emcy.h and is responsible for emergency management functions. The following data members are in this class: Data Member Type Description Cnt[] uint8_t error register object entry bit counters Err[] uint8_t individual emergency status storage Hist CO_EMCY_HIST emergency history management object Node CO_NODE* pointer to parent node Root CO_EMCY_TBL* pointer to application emergency table Info The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node.","title":"Structure Data"},{"location":"api/emergency/#member-functions","text":"The following table describes the API functions of the emergency module. These functions are implemented within the source file: co_emcy.c/h","title":"Member Functions"},{"location":"api/emergency/#coemcyclr","text":"The EMCY message is transmitted if the error was previously detected. Prototype void COEmcyClr ( CO_EMCY * emcy , uint8_t error ); Arguments Parameter Description emcy pointer to EMCY object error error code identifier in application EMCY table Returned Value none Example The following example demonstrates the clearing of a possible detected emergency event APP_EMCY_2 within the application of the CANopen node AppNode. : COEmcyClr ( & ( AppNode . Emcy ), APP_EMCY_2 ); : Note The emergency identifier APP_EMCY_2 must be defined within the application-specific configuration.","title":"COEmcyClr()"},{"location":"api/emergency/#coemcycnt","text":"When calling this function, all EMCY error status will stay unchanged. Prototype int16_t COEmcyCnt ( CO_EMCY * emcy ); Arguments Parameter Description emcy pointer to EMCY object Returned Value >=0 : success with the number of currently detected EMCY errors <0 : an error is detected inside of this function Example The following example calculates the current number of detected emergency events within the application of the CANopen node AppNode. int16_t emcy ; : emcy = COEmcyCnt ( & ( AppNode . Emcy )); if ( emcy < 0 ) { /* error handling */ } else { /* emcy holds number of detected emergencies */ } :","title":"COEmcyCnt()"},{"location":"api/emergency/#coemcyget","text":"When calling this function, the EMCY error status will stay unchanged. Prototype int16_t COEmcyGet ( CO_EMCY * emcy , uint8_t error ); Arguments Parameter Description emcy pointer to EMCY object error error code identifier in application EMCY table Returned Value =0 : success with error is not detected =1 : success with an error was detected before <0 : an error is detected inside of this function Example The following example reads the current status of a possible detected emergency event APP_EMCY_2 within the application of the CANopen node AppNode. int16_t warning ; : warning = COEmcyGet ( & ( AppNode . Emcy ), APP_EMCY_2 ); if ( warning < 0 ) { /* error handling */ } else { /* warning holds current emergency status */ } : Note The emergency identifier APP_EMCY_2 must be defined within the application-specific configuration.","title":"COEmcyGet()"},{"location":"api/emergency/#coemcyhistreset","text":"There is no EMCY message transmission due to this function call. Prototype void COEmcyHistReset ( CO_EMCY * emcy ); Arguments Parameter Description emcy pointer to EMCY object Returned Value none Example The following example clears all emergency history entries within the object dictionary of the CANopen node AppNode. : COEmcyHistReset ( & ( AppNode . Emcy )); :","title":"COEmcyHistReset()"},{"location":"api/emergency/#coemcyreset","text":"The EMCY message transmission can be suppressed by setting the parameter silent to 1. Prototype void COEmcyReset ( CO_EMCY * emcy , uint8_t silent ); Arguments Parameter Description emcy pointer to EMCY object silent disables the EMCY message transmission for the state changes, made by this function Returned Value none Example The following example clears all detected emergency within the application of the CANopen node AppNode. The corresponding emergency state change messages will be sent. : COEmcyReset ( & ( AppNode . Emcy ), 0 ); :","title":"COEmcyReset()"},{"location":"api/emergency/#coemcyset","text":"The EMCY message is transmitted if the error is detected for the first time. The given manufacturer-specific fields are optional, e.g. the pointer may be 0 to set all manufacturer-specific values to 0. Prototype void COEmcySet ( CO_EMCY * emcy , uint8_t err , CO_EMCY_USR * user ); Arguments Parameter Description emcy pointer to EMCY object err error code identifier in application EMCY table user manufacturer-specific fields in EMCY history and/or EMCY message Returned Value none Example The following example demonstrates the detection of an emergency event APP_EMCY_2 within the application of the CANopen node AppNode. The specific user information data for this event is: 0x1234567890. CO_EMCY_USR usr ; : usr . Emcy [ 0 ] = 0x12 ; usr . Emcy [ 1 ] = 0x34 ; usr . Emcy [ 2 ] = 0x56 ; usr . Emcy [ 3 ] = 0x78 ; usr . Emcy [ 4 ] = 0x90 ; COEmcySet ( & ( AppNode . Emcy ), APP_EMCY_2 , & usr ); : Note The specific user information data field is optional. If not used, the last parameter during calling COEmcySet() can be 0 (zero). The emergency identifier APP_EMCY_2 must be defined within the application-specific configuration.","title":"COEmcySet()"},{"location":"api/interface/","text":"CAN Interface # The interface component provides an interface to the hardware driver. Module Context # classDiagram CO_NODE o-- CO_IF : Node CO_IF_DRV *-- CO_IF : Drv CO_IF_FRM -- CO_IF class CO_IF { +COIfCanClose() +COIfCanRead(destination) int16_t +COIfCanReset() +COIfCanSend(source) int16_t } Structure Data # The class CO_IF is defined within co_if.h and is responsible for the interface management. The following data members are in this class Data Member Type Description Drv CO_IF_DRV driver specific CAN bus identification Node CO_NODE* pointer to parent node Info The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node. Member Functions # The following table describes the API functions of the CANopen interface module. These functions are implemented within the source file: co_if.c/h COIfCanClose() # This function closes the interface ONLY. Be careful in calling this function for an active CANopen node on this interface. This can result in unpredictable behavior of the overall system. Prototype void COIfCanClose ( CO_IF * cif ); Arguments Parameter Description cif pointer to interface object Returned Value none Example The following example shows how to close the interface of the CANopen node AppNode: : COIfCanClose ( & ( AppNode . If )); : COIfCanRead() # If a CAN frame is received, the given receive frame buffer will be filled with the received data. The read function is rarely used from within the application because the CANopen will receive all messages by default and allows to work on all non-CANopen messages with a callback function. Important For evaluation, demonstration, or testing purposes this CAN read function may poll for a new CAN frame. In this special case, the additional return value with no received CAN frame is possible. Don't use the polling mode in production; you should use interrupt-driven CAN communication. The CAN polling is not suitable for CANopen. Prototype int16_t COIfCanRead ( CO_IF * cif , CO_IF_FRM * frm ); Arguments Parameter Description cif pointer to interface object frm pointer to destination frame buffer Returned Value >0 : size of CO_IF_FRM on success =0 : special: nothing received during polling (timeout) <0 : an error is detected Example If necessary, the following example show how to call the blocking receive function for the interface of the CANopen node AppNode: CO_IF_FRM frame ; int16_t err ; : err = COIfCanRead ( & ( AppNode . If ), & frame ); if ( err <= 0 ) { /* error in interface layer */ } else { /* frame contains received data */ } : COIfCanReset() # This function resets the interface ONLY. Be careful in calling this function for an active CANopen node on this interface. This can result in unpredictable behavior of the overall system. Prototype void COIfCanReset ( CO_IF * cif ); Arguments Parameter Description cif pointer to interface object Returned Value none Example The following example shows how to reset the interface of the CANopen node AppNode: : COIfCanReset ( & ( AppNode . If )); : COIfCanSend() # The send function may be used within the application to transmit additional messages on the CANopen interface. Prototype int16_t COIfCanSend ( CO_IF * cif , CO_IF_FRM * frm ); Arguments Parameter Description cif pointer to interface object frm pointer to destination frame buffer Returned Value >0 : size of CO_IF_FRM on success <0 : an error is detected Example The following example shows how to call the transmit function for the interface of the CANopen node AppNode: CO_IF_FRM frame ; int16_t err ; : frame . Identifier = 0x123 ; frame . DLC = 8 ; frame . Data [ 0 ] = 0x12 ; frame . Data [ 1 ] = 0x23 ; frame . Data [ 2 ] = 0x34 ; frame . Data [ 3 ] = 0x45 ; frame . Data [ 4 ] = 0x56 ; frame . Data [ 5 ] = 0x67 ; frame . Data [ 6 ] = 0x78 ; frame . Data [ 7 ] = 0x89 ; err = COIfCanSend ( & ( AppNode . If ), & frame ); if ( err < 0 ) { /* error in interface layer */ } :","title":"CAN Interface"},{"location":"api/interface/#can-interface","text":"The interface component provides an interface to the hardware driver.","title":"CAN Interface"},{"location":"api/interface/#module-context","text":"classDiagram CO_NODE o-- CO_IF : Node CO_IF_DRV *-- CO_IF : Drv CO_IF_FRM -- CO_IF class CO_IF { +COIfCanClose() +COIfCanRead(destination) int16_t +COIfCanReset() +COIfCanSend(source) int16_t }","title":"Module Context"},{"location":"api/interface/#structure-data","text":"The class CO_IF is defined within co_if.h and is responsible for the interface management. The following data members are in this class Data Member Type Description Drv CO_IF_DRV driver specific CAN bus identification Node CO_NODE* pointer to parent node Info The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node.","title":"Structure Data"},{"location":"api/interface/#member-functions","text":"The following table describes the API functions of the CANopen interface module. These functions are implemented within the source file: co_if.c/h","title":"Member Functions"},{"location":"api/interface/#coifcanclose","text":"This function closes the interface ONLY. Be careful in calling this function for an active CANopen node on this interface. This can result in unpredictable behavior of the overall system. Prototype void COIfCanClose ( CO_IF * cif ); Arguments Parameter Description cif pointer to interface object Returned Value none Example The following example shows how to close the interface of the CANopen node AppNode: : COIfCanClose ( & ( AppNode . If )); :","title":"COIfCanClose()"},{"location":"api/interface/#coifcanread","text":"If a CAN frame is received, the given receive frame buffer will be filled with the received data. The read function is rarely used from within the application because the CANopen will receive all messages by default and allows to work on all non-CANopen messages with a callback function. Important For evaluation, demonstration, or testing purposes this CAN read function may poll for a new CAN frame. In this special case, the additional return value with no received CAN frame is possible. Don't use the polling mode in production; you should use interrupt-driven CAN communication. The CAN polling is not suitable for CANopen. Prototype int16_t COIfCanRead ( CO_IF * cif , CO_IF_FRM * frm ); Arguments Parameter Description cif pointer to interface object frm pointer to destination frame buffer Returned Value >0 : size of CO_IF_FRM on success =0 : special: nothing received during polling (timeout) <0 : an error is detected Example If necessary, the following example show how to call the blocking receive function for the interface of the CANopen node AppNode: CO_IF_FRM frame ; int16_t err ; : err = COIfCanRead ( & ( AppNode . If ), & frame ); if ( err <= 0 ) { /* error in interface layer */ } else { /* frame contains received data */ } :","title":"COIfCanRead()"},{"location":"api/interface/#coifcanreset","text":"This function resets the interface ONLY. Be careful in calling this function for an active CANopen node on this interface. This can result in unpredictable behavior of the overall system. Prototype void COIfCanReset ( CO_IF * cif ); Arguments Parameter Description cif pointer to interface object Returned Value none Example The following example shows how to reset the interface of the CANopen node AppNode: : COIfCanReset ( & ( AppNode . If )); :","title":"COIfCanReset()"},{"location":"api/interface/#coifcansend","text":"The send function may be used within the application to transmit additional messages on the CANopen interface. Prototype int16_t COIfCanSend ( CO_IF * cif , CO_IF_FRM * frm ); Arguments Parameter Description cif pointer to interface object frm pointer to destination frame buffer Returned Value >0 : size of CO_IF_FRM on success <0 : an error is detected Example The following example shows how to call the transmit function for the interface of the CANopen node AppNode: CO_IF_FRM frame ; int16_t err ; : frame . Identifier = 0x123 ; frame . DLC = 8 ; frame . Data [ 0 ] = 0x12 ; frame . Data [ 1 ] = 0x23 ; frame . Data [ 2 ] = 0x34 ; frame . Data [ 3 ] = 0x45 ; frame . Data [ 4 ] = 0x56 ; frame . Data [ 5 ] = 0x67 ; frame . Data [ 6 ] = 0x78 ; frame . Data [ 7 ] = 0x89 ; err = COIfCanSend ( & ( AppNode . If ), & frame ); if ( err < 0 ) { /* error in interface layer */ } :","title":"COIfCanSend()"},{"location":"api/network/","text":"Network Management # The network component provides an interface to the CANopen mode control, the node management, and the heartbeat handling. Module Context # classDiagram CO_NODE o-- CO_NMT : Node CO_MODE -- CO_NMT CO_NMT_RESET -- CO_NMT class CO_NMT { -int16_t Tmr -uint8_t Allowed +CONmtGetHbEvents(nodeId) int16_t +CONmtGetMode() CO_MODE +CONmtGetNodeId() uint8_t +CONmtLastHbState(nodeId) CO_MODE +CONmtReset(type) +CONmtSetMode(mode) +CONmtSetNodeId(nodeId) } class CO_NMT_RESET { <<enumeration>> } Structure Data # The class CO_NMT is defined within co_nmt.h and is responsible for the CANopen network slave management. The following data members are in this class: Data Member Type Description Allowed uint8_t encoding of allowed CANopen services Mode CO_MODE current NMT mode Node CO_NODE* pointer to parent node Tmr int16_t heartpeat producer timer identifier Info The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node. Member Functions # The following table describes the API functions of the CANopen network management module. Furthermore, this module includes the heartbeat producer and consumer. These functions are implemented within the source file: co_nmt.c/h , co_hb_prod.c/h and co_hb_cons.c/h CONmtGetHbEvents() # If a second heartbeat is received within the heartbeat deadline, the heartbeat timing is marked as ok . If the second heartbeat is received after the heartbeat deadline, the heartbeat timing is marked as missed . Prototype int16_t CONmtGetHbEvents ( CO_NMT * nmt , uint8_t nodeId ); Arguments Parameter Description nmt pointer to NMT object nodeId address heartbeat consumer for given node Returned Value <0 : error, e.g. the given node ID is not monitored by a heartbeat consumer =0 : the heartbeat consumer detects no miss event for the given node ID >0 : the heartbeat consumer detects this number of missed heartbeat deadlines Example The following example shows how to check the heartbeat consumer results of the CANopen node AppNode for the CANopen Node with node-ID = 10: int16_t events ; : events = CONmtGetHbEvents ( & ( AppNode . Nmt ), 10 ); if ( events > 0 ) { /* number of missing heartbeats of the monitored node 10 */ } else if ( events < 0 ) { /* no heartbeat consumer running for node 10 */ } else { /* the heartbeats of node 10 are received as expected */ } : CONmtGetMode() # The possible values of the reset type CO_MODE are: Value Description CO_INVALID device in INVALID mode, e.g. not initialized CO_INIT device in INIT mode CO_PREOP device in PRE-OPERATIONAL mode CO_OPERATIONAL device in OPERATIONAL mode CO_STOP device in STOP mode Prototype CO_MODE CONmtGetMode ( CO_NMT * nmt ); Arguments Parameter Description nmt pointer to NMT object Returned Value >0 : current NMT mode =0 : an error is detected Example The following example shows how to perform operations only in the operational mode of the CANopen node AppNode: CO_MODE mode ; : mode = CONmtGetMode ( & ( AppNode . Nmt )); if ( mode == CO_OPERATIONAL ) { /* perform actions in operational mode */ } : CONmtGetNodeId() # There should be always a valid node ID within the CANopen Stack. The default node ID is set in the node specification. Prototype uint8_t CONmtGetNodeId ( CO_NMT * nmt ); Arguments Parameter Description nmt pointer to NMT object nodeId requested NMT node ID Returned Value >0 : current NMT node ID =0 : an error is detected Example The following example shows how to get the node ID of the CANopen node AppNode: uint8_t id ; : id = CONmtGetNodeId ( & ( AppNode . Nmt )); if ( id == 0 ) { /* error during reading the node-ID */ } else { /* id holds the node ID */ } : CONmtLastHbState() # The possible values of the device mode CO_MODE are: Value Description CO_INVALID device in INVALID mode, e.g. not initialized CO_INIT device in INIT mode CO_PREOP device in PRE-OPERATIONAL mode CO_OPERATIONAL device in OPERATIONAL mode CO_STOP device in STOP mode Prototype CO_MODE CONmtLastHbState ( CO_NMT * nmt , uint8_t nodeId ); Arguments Parameter Description nmt pointer to NMT object nodeId address heartbeat consumer for given node Returned Value ==CO_INVALID : an error is detected; e.g. the given node ID is not monitored by a heartbeat consumer !=CO_INVALID : the heartbeat consumer received state from the given node ID Example The following example shows how to check the heartbeat consumer received mode of the CANopen node AppNode for the CANopen Node with node ID = 10: CO_MODE state ; : state = CONmtLastHbState ( & ( AppNode . Nmt ), 10 ); if ( state == CO_INVALID ) { /* no heartbeat consumer running for node 10 */ } else { /* you may react on specific NMT states here... */ } : CONmtReset() # The possible values of the reset type CO_NMT_RESET are: Value Description CO_RESET_INVALID invalid reset type (for testing) CO_RESET_NODE reset node (application and communication) CO_RESET_COM reset communication Prototype void CONmtReset ( CO_NMT * nmt , CO_NMT_RESET type ); Arguments Parameter Description nmt pointer to NMT object type requested NMT reset type Returned Value none Example The following example shows how to request a communication reset of the CANopen node AppNode: : CONmtReset ( & ( AppNode . Nmt ), CO_RESET_COM ); : CONmtSetMode() # The possible values of the device mode CO_MODE are: Value Description CO_INVALID device in INVALID mode, e.g. not initialized CO_INIT device in INIT mode CO_PREOP device in PRE-OPERATIONAL mode CO_OPERATIONAL device in OPERATIONAL mode CO_STOP device in STOP mode Prototype void CONmtSetMode ( CO_NMT * nmt , CO_MODE mode ); Arguments Parameter Description nmt pointer to NMT object mode requested NMT mode Returned Value none Example The following example shows how to switch the CANopen node AppNode in the operational mode without a CANopen master network command: : CONmtSetMode ( & ( AppNode . Nmt ), CO_OPERATIONAL ); : CONmtSetNodeId() # The following errors are detected within this function: - CO_ERR_NMT_MODE - the CANopen device is not in INIT mode - CO_ERR_BAD_ARG - the given nodeId is invalid (e.g. zero) If one of these errors is detected, this function call will change nothing. Important After the successful operation, the function CONmtReset() must be called to re-initialize the internal SDO and PDO tables. Prototype void CONmtSetNodeId ( CO_NMT * nmt , uint8_t nodeId ); Arguments Parameter Description nmt pointer to NMT object nodeId requested NMT node ID Returned Value none Example The following example shows how to set a dynamically determined node-ID for the CANopen node AppNode: CO_ERR err ; uint8_t id ; : id = AppCalculateNodeId (); CONmtSetNodeId ( & ( AppNode . Nmt ), id ); err = CONodeGetErr ( & AppNode ); if ( err == CO_ERR_NONE ) { CONmtReset ( & ( AppNode . Nmt ), CO_RESET_NODE ); /* calculated node-ID is set */ } else { /* error during setting the node-ID */ } :","title":"Network Management"},{"location":"api/network/#network-management","text":"The network component provides an interface to the CANopen mode control, the node management, and the heartbeat handling.","title":"Network Management"},{"location":"api/network/#module-context","text":"classDiagram CO_NODE o-- CO_NMT : Node CO_MODE -- CO_NMT CO_NMT_RESET -- CO_NMT class CO_NMT { -int16_t Tmr -uint8_t Allowed +CONmtGetHbEvents(nodeId) int16_t +CONmtGetMode() CO_MODE +CONmtGetNodeId() uint8_t +CONmtLastHbState(nodeId) CO_MODE +CONmtReset(type) +CONmtSetMode(mode) +CONmtSetNodeId(nodeId) } class CO_NMT_RESET { <<enumeration>> }","title":"Module Context"},{"location":"api/network/#structure-data","text":"The class CO_NMT is defined within co_nmt.h and is responsible for the CANopen network slave management. The following data members are in this class: Data Member Type Description Allowed uint8_t encoding of allowed CANopen services Mode CO_MODE current NMT mode Node CO_NODE* pointer to parent node Tmr int16_t heartpeat producer timer identifier Info The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node.","title":"Structure Data"},{"location":"api/network/#member-functions","text":"The following table describes the API functions of the CANopen network management module. Furthermore, this module includes the heartbeat producer and consumer. These functions are implemented within the source file: co_nmt.c/h , co_hb_prod.c/h and co_hb_cons.c/h","title":"Member Functions"},{"location":"api/network/#conmtgethbevents","text":"If a second heartbeat is received within the heartbeat deadline, the heartbeat timing is marked as ok . If the second heartbeat is received after the heartbeat deadline, the heartbeat timing is marked as missed . Prototype int16_t CONmtGetHbEvents ( CO_NMT * nmt , uint8_t nodeId ); Arguments Parameter Description nmt pointer to NMT object nodeId address heartbeat consumer for given node Returned Value <0 : error, e.g. the given node ID is not monitored by a heartbeat consumer =0 : the heartbeat consumer detects no miss event for the given node ID >0 : the heartbeat consumer detects this number of missed heartbeat deadlines Example The following example shows how to check the heartbeat consumer results of the CANopen node AppNode for the CANopen Node with node-ID = 10: int16_t events ; : events = CONmtGetHbEvents ( & ( AppNode . Nmt ), 10 ); if ( events > 0 ) { /* number of missing heartbeats of the monitored node 10 */ } else if ( events < 0 ) { /* no heartbeat consumer running for node 10 */ } else { /* the heartbeats of node 10 are received as expected */ } :","title":"CONmtGetHbEvents()"},{"location":"api/network/#conmtgetmode","text":"The possible values of the reset type CO_MODE are: Value Description CO_INVALID device in INVALID mode, e.g. not initialized CO_INIT device in INIT mode CO_PREOP device in PRE-OPERATIONAL mode CO_OPERATIONAL device in OPERATIONAL mode CO_STOP device in STOP mode Prototype CO_MODE CONmtGetMode ( CO_NMT * nmt ); Arguments Parameter Description nmt pointer to NMT object Returned Value >0 : current NMT mode =0 : an error is detected Example The following example shows how to perform operations only in the operational mode of the CANopen node AppNode: CO_MODE mode ; : mode = CONmtGetMode ( & ( AppNode . Nmt )); if ( mode == CO_OPERATIONAL ) { /* perform actions in operational mode */ } :","title":"CONmtGetMode()"},{"location":"api/network/#conmtgetnodeid","text":"There should be always a valid node ID within the CANopen Stack. The default node ID is set in the node specification. Prototype uint8_t CONmtGetNodeId ( CO_NMT * nmt ); Arguments Parameter Description nmt pointer to NMT object nodeId requested NMT node ID Returned Value >0 : current NMT node ID =0 : an error is detected Example The following example shows how to get the node ID of the CANopen node AppNode: uint8_t id ; : id = CONmtGetNodeId ( & ( AppNode . Nmt )); if ( id == 0 ) { /* error during reading the node-ID */ } else { /* id holds the node ID */ } :","title":"CONmtGetNodeId()"},{"location":"api/network/#conmtlasthbstate","text":"The possible values of the device mode CO_MODE are: Value Description CO_INVALID device in INVALID mode, e.g. not initialized CO_INIT device in INIT mode CO_PREOP device in PRE-OPERATIONAL mode CO_OPERATIONAL device in OPERATIONAL mode CO_STOP device in STOP mode Prototype CO_MODE CONmtLastHbState ( CO_NMT * nmt , uint8_t nodeId ); Arguments Parameter Description nmt pointer to NMT object nodeId address heartbeat consumer for given node Returned Value ==CO_INVALID : an error is detected; e.g. the given node ID is not monitored by a heartbeat consumer !=CO_INVALID : the heartbeat consumer received state from the given node ID Example The following example shows how to check the heartbeat consumer received mode of the CANopen node AppNode for the CANopen Node with node ID = 10: CO_MODE state ; : state = CONmtLastHbState ( & ( AppNode . Nmt ), 10 ); if ( state == CO_INVALID ) { /* no heartbeat consumer running for node 10 */ } else { /* you may react on specific NMT states here... */ } :","title":"CONmtLastHbState()"},{"location":"api/network/#conmtreset","text":"The possible values of the reset type CO_NMT_RESET are: Value Description CO_RESET_INVALID invalid reset type (for testing) CO_RESET_NODE reset node (application and communication) CO_RESET_COM reset communication Prototype void CONmtReset ( CO_NMT * nmt , CO_NMT_RESET type ); Arguments Parameter Description nmt pointer to NMT object type requested NMT reset type Returned Value none Example The following example shows how to request a communication reset of the CANopen node AppNode: : CONmtReset ( & ( AppNode . Nmt ), CO_RESET_COM ); :","title":"CONmtReset()"},{"location":"api/network/#conmtsetmode","text":"The possible values of the device mode CO_MODE are: Value Description CO_INVALID device in INVALID mode, e.g. not initialized CO_INIT device in INIT mode CO_PREOP device in PRE-OPERATIONAL mode CO_OPERATIONAL device in OPERATIONAL mode CO_STOP device in STOP mode Prototype void CONmtSetMode ( CO_NMT * nmt , CO_MODE mode ); Arguments Parameter Description nmt pointer to NMT object mode requested NMT mode Returned Value none Example The following example shows how to switch the CANopen node AppNode in the operational mode without a CANopen master network command: : CONmtSetMode ( & ( AppNode . Nmt ), CO_OPERATIONAL ); :","title":"CONmtSetMode()"},{"location":"api/network/#conmtsetnodeid","text":"The following errors are detected within this function: - CO_ERR_NMT_MODE - the CANopen device is not in INIT mode - CO_ERR_BAD_ARG - the given nodeId is invalid (e.g. zero) If one of these errors is detected, this function call will change nothing. Important After the successful operation, the function CONmtReset() must be called to re-initialize the internal SDO and PDO tables. Prototype void CONmtSetNodeId ( CO_NMT * nmt , uint8_t nodeId ); Arguments Parameter Description nmt pointer to NMT object nodeId requested NMT node ID Returned Value none Example The following example shows how to set a dynamically determined node-ID for the CANopen node AppNode: CO_ERR err ; uint8_t id ; : id = AppCalculateNodeId (); CONmtSetNodeId ( & ( AppNode . Nmt ), id ); err = CONodeGetErr ( & AppNode ); if ( err == CO_ERR_NONE ) { CONmtReset ( & ( AppNode . Nmt ), CO_RESET_NODE ); /* calculated node-ID is set */ } else { /* error during setting the node-ID */ } :","title":"CONmtSetNodeId()"},{"location":"api/node/","text":"CANopen Node # The node component is the central component and includes all other components for a single CANopen node. The node component provides the interface to the node lifecycle operations. Module Context # classDiagram CO_DICT *-- CO_NODE : Dict CO_IF *-- CO_NODE : If CO_EMCY *-- CO_NODE : Emcy CO_TMR *-- CO_NODE : Tmr CO_NMT *-- CO_NODE : Nmt CO_SDO *-- CO_NODE : Sdo CO_LSS *-- CO_NODE : Lss CO_ERR -- CO_NODE : Error CO_NODE *-- CO_RPDO : RPdo CO_NODE *-- CO_TPDO : TPdo CO_NODE *-- CO_TPDO_LINK : TMap CO_NODE *-- CO_SYNC : Sync CO_NODE -- CO_NODE_SPEC CO_NODE -- CO_NMT_RESET class CO_NODE { -uint8_t SdoBuf -uint32_t Baudrate -uint8_t NodeId +CONodeGetErr() CO_ERR +CONodeInit(spec) +CONodeParaLoad(type) int16_t +CONodeProcess() +CONodeStart() +CONodeStop() } class CO_ERR { <<enumeration>> } class CO_NMT_RESET { <<enumeration>> } Structure Data # The class CO_NODE is defined within co_core.h and is responsible for the overall node management functions. The node is the central data point of a CANopen device. The following data members are in this class: Data Member Type Description Baudrate uint32_t default CAN communication baudrate Dict CO_DICT object dictionary object Emcy CO_EMCY node emergency object Error CO_ERR Internal error indentification code If CO_IF CAN bus interface object Lss CO_LSS LSS management object Nmt CO_NMT node network management object NodeId uint8_t default CANopen node ID Sdo CO_SDO SDO server object array SdoBuf uint8_t* pointer to SDO transfer buffer Tmr CO_TMR timer manager object TPdo[] CO_TPDO transmit PDO object array TMap[] CO_TPDO_LINK transmit PDO mapping link array RPdo[] CO_RPDO receive PDO object array Sync CO_SYNC SYNC management object Info The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node. Member Functions # During calling a member function of a class, the first parameter must be a reference to a corresponding object. This should be done as shown in the following examples: CO_NODE AppNode ; /* allocate application node */ : CONodeInit ( & AppNode ,...); /* call member of class CO_NODE */ CODirFind ( & ( AppNode . Dir ) ,...); /* call member of class CO_DIR */ COIfCanSend ( & ( AppNode . If ) ,...); /* call member of class CO_IF */ COEmcySet ( & ( AppNode . Emcy ),...); /* call member of class CO_EMCY */ COTmrCreate ( & ( AppNode . Tmr ) ,...); /* call member of class CO_TMR */ CONmtReset ( & ( AppNode . Nmt ) ,...); /* call member of class CO_NMT */ : Note, that in all application source files, which needs to call one or more CANopen API functions, the header file co_core.h must be included. The following table describes the API functions of the CANopen core module. These functions are implemented within the source file: co_core.c/h CONodeGetErr() # If an error was detected, the error is cleared with this function call. Prototype CO_ERR CONodeGetErr ( CO_NODE * node ); Arguments Parameter Description node pointer to node object Returned Value One of the following error codes: Error code Description CO_ERR_NONE no error CO_ERR_BAD_ARG invalid argument CO_ERR_OBJ_NOT_FOUND searched object not found in directory CO_ERR_OBJ_READ error during reading an object entry CO_ERR_OBJ_WRITE error during writing an object entry CO_ERR_OBJ_SIZE read/write with a wrong size to object CO_ERR_OBJ_MAP_LEN invalid mapping length CO_ERR_OBJ_MAP_TYPE invalid mapping type CO_ERR_OBJ_ACC unsupported access CO_ERR_OBJ_RANGE value range of parameter exceeded CO_ERR_OBJ_INCOMPATIBLE incompatible parameter value CO_ERR_PARA_IDX wrong index for parameter type CO_ERR_PARA_STORE error during storing parameter CO_ERR_PARA_RESTORE error during restoring parameter CO_ERR_PARA_LOAD error during loading parameter CO_ERR_CFG_1001_0 entry 1001:0 is bad/not existing CO_ERR_CFG_1003_0 entry 1003:0 is bad/not existing CO_ERR_CFG_1003_1 entry 1003:1 is bad/not existing CO_ERR_CFG_1005_0 entry 1005:0 is bad/not existing CO_ERR_CFG_1010_0 entry 1010:0 is bad/not existing CO_ERR_CFG_1011_0 entry 1011:0 is bad/not existing CO_ERR_CFG_1014_0 entry 1014:0 is bad/not existing CO_ERR_CFG_1016 entry in 1016 is bad/not existing CO_ERR_CFG_1017_0 entry 1017:0 is bad/not existing CO_ERR_CFG_1018 entry in 1018 is bad/not existing CO_ERR_TMR_NO_ACT no action available while creating CO_ERR_TMR_INSERT error during insert action in tmr-list CO_ERR_TMR_CREATE error during creating a timed action CO_ERR_TMR_DELETE error during deleting a timed action CO_ERR_NMT_INIT error during initializing NMT slave CO_ERR_NMT_APP_RESET error in resetting application CO_ERR_NMT_COM_RESET error in resetting communication CO_ERR_NMT_MODE action not allowed in current NMT mode CO_ERR_LSS_LOAD error during loading the LSS configuration CO_ERR_LSS_STORE error during writing the LSS configuration CO_ERR_EMCY_BAD_ROOT error in emcy structure, member: Root CO_ERR_TPDO_COM_OBJ config error in TPDO communication CO_ERR_TPDO_MAP_OBJ config error in TPDO mapping CO_ERR_TPDO_OBJ_TRIGGER error during trigger via an object CO_ERR_TPDO_NUM_TRIGGER error during trigger via a PDO number CO_ERR_TPDO_INHIBIT error during inhibit timer creation CO_ERR_TPDO_EVENT error during event timer creation CO_ERR_RPDO_COM_OBJ config error in RPDO communication CO_ERR_RPDO_MAP_OBJ config error in RPDO mapping CO_ERR_SDO_READ error during in SDO block reading CO_ERR_SDO_WRITE error during in SDO block writing CO_ERR_SYNC_MSG error during receive synchronous PDO CO_ERR_IF_INIT error during initialization CO_ERR_IF_ENABLE error during enabling the interface CO_ERR_IF_FLUSH_RX error during flushing RX interface CO_ERR_IF_FLUSH_TX error during flushing TX interface CO_ERR_IF_RESET error during resetting interface CO_ERR_IF_CLOSE error during closing the interface CO_ERR_IF_READ error during reading from interface CO_ERR_IF_SEND error during sending to interface CO_ERR_SIG_INIT error during initializing CAN signals CO_ERR_SIG_CREATE error during creating a needed signal CO_ERR_MSG_INIT error during message initialization CO_ERR_MSG_CREATE error during creating a message CO_ERR_MSG_READ error during reading a message CO_ERR_TYPE_RD error during reading type CO_ERR_TYPE_CTRL error during type control CO_ERR_TYPE_WR error during writing type Example The following example demonstrates a diagnostic section of a CANopen startup sequence: : CONodeInit ( & AppNode , ( CO_NODE_SPEC * ) & AppSpec ); err = CONodeGetErr ( & AppNode ); if ( err == CO_ERR_NONE ) { CONodeStart ( & AppNode ); } else { /* handle detected error according to your application */ } : CONodeInit() # The specification of the CANopen node, and the CANopen node object itself is given as a parameter. Prototype void CONodeInit ( CO_NODE * node , CO_NODE_SPEC * spec ); Arguments Parameter Description node pointer to node object spec pointer to node specification object Returned Value none Example The following example shows the external reference to the node specification AppSpec which is typically allocated within a configuration file and the allocation of the CANopen node memory AppNode. extern const CO_NODE_SPEC AppSpec ; CO_NODE AppNode ; With these objects, the CANopen node can be initialized and started: : CONodeInit ( & AppNode , ( CO_NODE_SPEC * ) & AppSpec ); : CONodeParaLoad() # A single parameter group will be loaded from NVM by calling the nvm driver function for reading data. This function considers all parameter groups, which are linked to the parameter store index (1010h) within the object dictionary. Every not linked parameter group is not the scope of this function and must be handled within the application. Prototype int16_t CONodeParaLoad ( CO_NODE * node , CO_NMT_RESET type ); Arguments Parameter Description node pointer to node object type reset type, e.g. CO_RESET_COM or CO_RESET_NODE Returned Value =0 : loading successful <0 : an error is detected and function aborted Example The function CONodeParaLoad() is rarely called from within the applications. Typically the CANopen master requests the parameter loading via NMT command. In some special cases it is useful to initiate a reset from the slave application. The following example shows the sequence to load all parameters, which are linked to the object directory entries related to the communication profile (index 1000h to 1FFFh). : success = CONodeParaLoad ( & AppNode , CO_RESET_COM ); if ( success < 0 ) { err = CONodeGetErr ( & AppNode ); /* handle error during parameter loading */ } : CONodeProcess() # This function is responsible for performing the necessary response to a received CAN frame. Prototype void CONodeProcess ( CO_NODE * node ); Arguments Parameter Description node pointer to node object Returned Value none Example The function CONodeProcess() is most likely called in the background function loop. When using an RTOS, the CANopen node processing from within a separate task is possible, too. In this case, the blocking mode is suitable for most applications: void CanRxTask ( void * arg_p ) { CO_NODE * node = ( CO_NODE * ) arg_p ; /* task parameter is a ptr to */ /* CANopen node object */ while ( 1 ) { /* endless RTOS task loop */ CONodeProcess ( node ); /* wait and process CAN frames */ } } CONodeStart() # The node will change into the PRE-OPERATIONAL state and is ready for communication. Prototype void CONodeStart ( CO_NODE * node ); Arguments Parameter Description node pointer to node object Returned Value none Example The following example shows the typical startup of a CANopen node AppNode with the specification AppSpec: CO_ERR err ; : CONodeInit ( & AppNode , ( CO_NODE_SPEC * ) & AppSpec ); err = CONodeGetErr ( & AppNode ); if ( err == CO_ERR_NONE ) { CONodeStart ( & AppNode ); } else { /* error handling and diagnostics */ } : CONodeStop() # This function removes the CANopen node from the CAN bus interface. To reactivate a stopped CANopen node, the functions CONodeInit() and CONodeStart() must be called again. Prototype void CONodeStop ( CO_NODE * node ); Arguments Parameter Description node pointer to node object Returned Value none Example The following example shows the sequence for restarting a CANopen node AppNode. Assuming the CANopen stack is initialized and started before, we can stop and re-initialize the stack to reset the node completely. : CONodeStop ( & AppNode ); : /* do something with stopped CANopen node */ : CONodeInit ( & AppNode , ( CO_NODE_SPEC * ) & AppSpec ); err = CONodeGetErr ( & AppNode ); if ( err == CO_ERR_NONE ) { CONodeStart ( & AppNode ); } else { /* error handling and diagnostics */ } : Attention The shown example is NOT identical to the standard node reset which can be requested from the CANopen master or via the API function CONmtReset() . The difference is: the example will transmit the boot-up message.","title":"CANopen Node"},{"location":"api/node/#canopen-node","text":"The node component is the central component and includes all other components for a single CANopen node. The node component provides the interface to the node lifecycle operations.","title":"CANopen Node"},{"location":"api/node/#module-context","text":"classDiagram CO_DICT *-- CO_NODE : Dict CO_IF *-- CO_NODE : If CO_EMCY *-- CO_NODE : Emcy CO_TMR *-- CO_NODE : Tmr CO_NMT *-- CO_NODE : Nmt CO_SDO *-- CO_NODE : Sdo CO_LSS *-- CO_NODE : Lss CO_ERR -- CO_NODE : Error CO_NODE *-- CO_RPDO : RPdo CO_NODE *-- CO_TPDO : TPdo CO_NODE *-- CO_TPDO_LINK : TMap CO_NODE *-- CO_SYNC : Sync CO_NODE -- CO_NODE_SPEC CO_NODE -- CO_NMT_RESET class CO_NODE { -uint8_t SdoBuf -uint32_t Baudrate -uint8_t NodeId +CONodeGetErr() CO_ERR +CONodeInit(spec) +CONodeParaLoad(type) int16_t +CONodeProcess() +CONodeStart() +CONodeStop() } class CO_ERR { <<enumeration>> } class CO_NMT_RESET { <<enumeration>> }","title":"Module Context"},{"location":"api/node/#structure-data","text":"The class CO_NODE is defined within co_core.h and is responsible for the overall node management functions. The node is the central data point of a CANopen device. The following data members are in this class: Data Member Type Description Baudrate uint32_t default CAN communication baudrate Dict CO_DICT object dictionary object Emcy CO_EMCY node emergency object Error CO_ERR Internal error indentification code If CO_IF CAN bus interface object Lss CO_LSS LSS management object Nmt CO_NMT node network management object NodeId uint8_t default CANopen node ID Sdo CO_SDO SDO server object array SdoBuf uint8_t* pointer to SDO transfer buffer Tmr CO_TMR timer manager object TPdo[] CO_TPDO transmit PDO object array TMap[] CO_TPDO_LINK transmit PDO mapping link array RPdo[] CO_RPDO receive PDO object array Sync CO_SYNC SYNC management object Info The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node.","title":"Structure Data"},{"location":"api/node/#member-functions","text":"During calling a member function of a class, the first parameter must be a reference to a corresponding object. This should be done as shown in the following examples: CO_NODE AppNode ; /* allocate application node */ : CONodeInit ( & AppNode ,...); /* call member of class CO_NODE */ CODirFind ( & ( AppNode . Dir ) ,...); /* call member of class CO_DIR */ COIfCanSend ( & ( AppNode . If ) ,...); /* call member of class CO_IF */ COEmcySet ( & ( AppNode . Emcy ),...); /* call member of class CO_EMCY */ COTmrCreate ( & ( AppNode . Tmr ) ,...); /* call member of class CO_TMR */ CONmtReset ( & ( AppNode . Nmt ) ,...); /* call member of class CO_NMT */ : Note, that in all application source files, which needs to call one or more CANopen API functions, the header file co_core.h must be included. The following table describes the API functions of the CANopen core module. These functions are implemented within the source file: co_core.c/h","title":"Member Functions"},{"location":"api/node/#conodegeterr","text":"If an error was detected, the error is cleared with this function call. Prototype CO_ERR CONodeGetErr ( CO_NODE * node ); Arguments Parameter Description node pointer to node object Returned Value One of the following error codes: Error code Description CO_ERR_NONE no error CO_ERR_BAD_ARG invalid argument CO_ERR_OBJ_NOT_FOUND searched object not found in directory CO_ERR_OBJ_READ error during reading an object entry CO_ERR_OBJ_WRITE error during writing an object entry CO_ERR_OBJ_SIZE read/write with a wrong size to object CO_ERR_OBJ_MAP_LEN invalid mapping length CO_ERR_OBJ_MAP_TYPE invalid mapping type CO_ERR_OBJ_ACC unsupported access CO_ERR_OBJ_RANGE value range of parameter exceeded CO_ERR_OBJ_INCOMPATIBLE incompatible parameter value CO_ERR_PARA_IDX wrong index for parameter type CO_ERR_PARA_STORE error during storing parameter CO_ERR_PARA_RESTORE error during restoring parameter CO_ERR_PARA_LOAD error during loading parameter CO_ERR_CFG_1001_0 entry 1001:0 is bad/not existing CO_ERR_CFG_1003_0 entry 1003:0 is bad/not existing CO_ERR_CFG_1003_1 entry 1003:1 is bad/not existing CO_ERR_CFG_1005_0 entry 1005:0 is bad/not existing CO_ERR_CFG_1010_0 entry 1010:0 is bad/not existing CO_ERR_CFG_1011_0 entry 1011:0 is bad/not existing CO_ERR_CFG_1014_0 entry 1014:0 is bad/not existing CO_ERR_CFG_1016 entry in 1016 is bad/not existing CO_ERR_CFG_1017_0 entry 1017:0 is bad/not existing CO_ERR_CFG_1018 entry in 1018 is bad/not existing CO_ERR_TMR_NO_ACT no action available while creating CO_ERR_TMR_INSERT error during insert action in tmr-list CO_ERR_TMR_CREATE error during creating a timed action CO_ERR_TMR_DELETE error during deleting a timed action CO_ERR_NMT_INIT error during initializing NMT slave CO_ERR_NMT_APP_RESET error in resetting application CO_ERR_NMT_COM_RESET error in resetting communication CO_ERR_NMT_MODE action not allowed in current NMT mode CO_ERR_LSS_LOAD error during loading the LSS configuration CO_ERR_LSS_STORE error during writing the LSS configuration CO_ERR_EMCY_BAD_ROOT error in emcy structure, member: Root CO_ERR_TPDO_COM_OBJ config error in TPDO communication CO_ERR_TPDO_MAP_OBJ config error in TPDO mapping CO_ERR_TPDO_OBJ_TRIGGER error during trigger via an object CO_ERR_TPDO_NUM_TRIGGER error during trigger via a PDO number CO_ERR_TPDO_INHIBIT error during inhibit timer creation CO_ERR_TPDO_EVENT error during event timer creation CO_ERR_RPDO_COM_OBJ config error in RPDO communication CO_ERR_RPDO_MAP_OBJ config error in RPDO mapping CO_ERR_SDO_READ error during in SDO block reading CO_ERR_SDO_WRITE error during in SDO block writing CO_ERR_SYNC_MSG error during receive synchronous PDO CO_ERR_IF_INIT error during initialization CO_ERR_IF_ENABLE error during enabling the interface CO_ERR_IF_FLUSH_RX error during flushing RX interface CO_ERR_IF_FLUSH_TX error during flushing TX interface CO_ERR_IF_RESET error during resetting interface CO_ERR_IF_CLOSE error during closing the interface CO_ERR_IF_READ error during reading from interface CO_ERR_IF_SEND error during sending to interface CO_ERR_SIG_INIT error during initializing CAN signals CO_ERR_SIG_CREATE error during creating a needed signal CO_ERR_MSG_INIT error during message initialization CO_ERR_MSG_CREATE error during creating a message CO_ERR_MSG_READ error during reading a message CO_ERR_TYPE_RD error during reading type CO_ERR_TYPE_CTRL error during type control CO_ERR_TYPE_WR error during writing type Example The following example demonstrates a diagnostic section of a CANopen startup sequence: : CONodeInit ( & AppNode , ( CO_NODE_SPEC * ) & AppSpec ); err = CONodeGetErr ( & AppNode ); if ( err == CO_ERR_NONE ) { CONodeStart ( & AppNode ); } else { /* handle detected error according to your application */ } :","title":"CONodeGetErr()"},{"location":"api/node/#conodeinit","text":"The specification of the CANopen node, and the CANopen node object itself is given as a parameter. Prototype void CONodeInit ( CO_NODE * node , CO_NODE_SPEC * spec ); Arguments Parameter Description node pointer to node object spec pointer to node specification object Returned Value none Example The following example shows the external reference to the node specification AppSpec which is typically allocated within a configuration file and the allocation of the CANopen node memory AppNode. extern const CO_NODE_SPEC AppSpec ; CO_NODE AppNode ; With these objects, the CANopen node can be initialized and started: : CONodeInit ( & AppNode , ( CO_NODE_SPEC * ) & AppSpec ); :","title":"CONodeInit()"},{"location":"api/node/#conodeparaload","text":"A single parameter group will be loaded from NVM by calling the nvm driver function for reading data. This function considers all parameter groups, which are linked to the parameter store index (1010h) within the object dictionary. Every not linked parameter group is not the scope of this function and must be handled within the application. Prototype int16_t CONodeParaLoad ( CO_NODE * node , CO_NMT_RESET type ); Arguments Parameter Description node pointer to node object type reset type, e.g. CO_RESET_COM or CO_RESET_NODE Returned Value =0 : loading successful <0 : an error is detected and function aborted Example The function CONodeParaLoad() is rarely called from within the applications. Typically the CANopen master requests the parameter loading via NMT command. In some special cases it is useful to initiate a reset from the slave application. The following example shows the sequence to load all parameters, which are linked to the object directory entries related to the communication profile (index 1000h to 1FFFh). : success = CONodeParaLoad ( & AppNode , CO_RESET_COM ); if ( success < 0 ) { err = CONodeGetErr ( & AppNode ); /* handle error during parameter loading */ } :","title":"CONodeParaLoad()"},{"location":"api/node/#conodeprocess","text":"This function is responsible for performing the necessary response to a received CAN frame. Prototype void CONodeProcess ( CO_NODE * node ); Arguments Parameter Description node pointer to node object Returned Value none Example The function CONodeProcess() is most likely called in the background function loop. When using an RTOS, the CANopen node processing from within a separate task is possible, too. In this case, the blocking mode is suitable for most applications: void CanRxTask ( void * arg_p ) { CO_NODE * node = ( CO_NODE * ) arg_p ; /* task parameter is a ptr to */ /* CANopen node object */ while ( 1 ) { /* endless RTOS task loop */ CONodeProcess ( node ); /* wait and process CAN frames */ } }","title":"CONodeProcess()"},{"location":"api/node/#conodestart","text":"The node will change into the PRE-OPERATIONAL state and is ready for communication. Prototype void CONodeStart ( CO_NODE * node ); Arguments Parameter Description node pointer to node object Returned Value none Example The following example shows the typical startup of a CANopen node AppNode with the specification AppSpec: CO_ERR err ; : CONodeInit ( & AppNode , ( CO_NODE_SPEC * ) & AppSpec ); err = CONodeGetErr ( & AppNode ); if ( err == CO_ERR_NONE ) { CONodeStart ( & AppNode ); } else { /* error handling and diagnostics */ } :","title":"CONodeStart()"},{"location":"api/node/#conodestop","text":"This function removes the CANopen node from the CAN bus interface. To reactivate a stopped CANopen node, the functions CONodeInit() and CONodeStart() must be called again. Prototype void CONodeStop ( CO_NODE * node ); Arguments Parameter Description node pointer to node object Returned Value none Example The following example shows the sequence for restarting a CANopen node AppNode. Assuming the CANopen stack is initialized and started before, we can stop and re-initialize the stack to reset the node completely. : CONodeStop ( & AppNode ); : /* do something with stopped CANopen node */ : CONodeInit ( & AppNode , ( CO_NODE_SPEC * ) & AppSpec ); err = CONodeGetErr ( & AppNode ); if ( err == CO_ERR_NONE ) { CONodeStart ( & AppNode ); } else { /* error handling and diagnostics */ } : Attention The shown example is NOT identical to the standard node reset which can be requested from the CANopen master or via the API function CONmtReset() . The difference is: the example will transmit the boot-up message.","title":"CONodeStop()"},{"location":"api/object/","text":"Object Entry # The object component provides an interface to the individual object entries. Module Context # classDiagram CO_NODE o-- CO_OBJ : Node CO_OBJ_TYPE o-- CO_OBJ : Type CO_DATA *-- CO_OBJ : Data class CO_OBJ { -uint32_t Key +COObjGetSize(width) uint32_t +COObjRdBufCont(destination, size) int16_t +COObjRdBufStart(destination, size) int16_t +COObjRdValue(destination, width, nodeId) int16_t +COObjWrBufCont(source, size) int16_t +COObjWrBufStart(source, size) int16_t +COObjWrValue(source, width, nodeId) int16_t +COObjTypeUserSDOAbort(node, code) void } Structure Data # The class CO_OBJ is defined within co_obj.h and is responsible for the CANopen object entry data access handling. The following data members are in this class: Data Member Type Description Data CO_DATA data information of object entry Key uint32_t Encoded object entry properties Type CO_OBJ_TYPE* pointer to object type Info The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node. Member Functions # The following table describes the API functions of the CANopen object entry module. These functions are implemented within the source file: co_obj.c/h COObjGetSize() # The argument width is most likely given '0' (=unknown) when getting the size of an object entry. The intended use of this argument is for write access of dynamic sizes of user type objects (e.g. firmware loading with a maximum size). Prototype uint32_t COObjGetSize ( CO_OBJ * obj , CO_NODE * node , uint32_t width ); Arguments Parameter Description obj pointer to object entry node pointer to parent node width expected object size in byte (or 0 if unknown) Returned Value >0 : object entry size in bytes =0 : an error is detected Example The following example gets the size of the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. uint32_t size ; CO_OBJ * entry ; : entry = CODictFind ( & ( AppNode . Dict ), CO_DEV ( 0x1234 , 0x56 )); size = COObjGetSize ( entry , & AppNode , 0 ); : COObjRdBufCont() # The function is used together with COObjRdBufStart() to read an object entry with a size greater than 4. Prototype int16_t COObjRdBufCont ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint8_t size ); Arguments Parameter Description obj pointer to object entry node pointer to parent node buffer pointer to destination memory size size of destination buffer Returned Value ==CO_ERR_NONE : successful operation !=CO_ERR_NONE : an error is detected Example see Example in COObjRdBufStart() Attention This function is used when reading data in smaller junks (e.g. internaly the SDO transfers is using this function). Within the application you most likely use the related memory area due to performance issues. COObjRdBufStart() # The function is used together with COObjRdBufCont() to read an object entry with a size greater than 4. Prototype int16_t COObjRdBufStart ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint8_t size ); Arguments Parameter Description obj pointer to object entry node pointer to parent node buffer pointer to destination memory size size of destination buffer Returned Value ==CO_ERR_NONE : successful operation !=CO_ERR_NONE : an error is detected Example The following example reads the byte-stream of the hypothetical application-specific object entry \"[1234:56]\" within the object directory of the CANopen node AppNode in junks of 10 Byte. uint8_t active ; : uint8_t buffer [ 10 ]; int16_t err ; CO_OBJ * entry ; : entry = CODictFind ( & ( AppNode . Dict ), CO_DEV ( 0x1234 , 0x56 )); if ( active = 0 ) { err = COObjRdBufStart ( entry , & AppNode , buffer , 10 ); if ( err == CO_ERR_NONE ) { active = 1 ; } else { /* error handline and diagnostics */ } } else { /* read the next 10 Byte snippet from object entry */ err = COObjRdBufCont ( entry , & AppNode , buffer , 10 ); if ( err == CO_ERR_NONE ) { /* do something with the 10 Byte data snippet */ } else { active = 0 ; } } : Attention This function is used when reading data in smaller junks (e.g. internaly the SDO transfers is using this function). Within the application you most likely use the related memory area due to performance issues. COObjRdValue() # The access with this function to an object entry will be done with the casting of the object entry values to the requested value width. Prototype int16_t COObjRdValue ( CO_OBJ * obj , CO_NODE * node , void * value , uint8_t width ); Arguments Parameter Description obj pointer to object entry node pointer to parent node value pointer to destination variable width width of read value (must be 1, 2 or 4 and reflecting the width of the referenced variable) Returned Value ==CO_ERR_NONE : successful operation !=CO_ERR_NONE : an error is detected Example The following example gets the value of the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. uint32_t value ; CO_OBJ * entry ; : entry = CODictFind ( & ( AppNode . Dict ), CO_DEV ( 0x1234 , 0x56 )); err = COObjRdValue ( entry , & AppNode , & value , sizeof ( value )); : COObjTypeUserSDOAbort() # This function allows the definition of user defined SDO abort codes within user type function implementations. Prototype void COObjTypeUserSDOAbort ( CO_OBJ * obj , CO_NODE * node , uint32_t abort ); Arguments Parameter Description obj pointer to object entry node pointer to parent node abort user defined abort code Example The following write-function for the type COTDemo send the user defined SDO Abort code \"0x01020304\" on a write access to object entries with this user type. const CO_OBJ_TYPE COTDemo = { 0 , 0 , 0 , DemoWrite }; #define CO_TDEMO ((CO_OBJ_TYPE*)&COTDemo) int16_t DemoWrite ( CO_OBJ * obj , struct CO_NODE_T * node , void * buffer , uint32_t size ) { /* define the SDO Abort code */ COObjTypeUserSDOAbort ( obj , node , 0x01020304 ); /* indicate an write error */ return CO_ERR_TYPE_WR ; } Attention The CiA standard doesn't reserve or allow any manufacturer specific SDO Abort code regions. Therefore, use this function with care. COObjWrBufCont() # The function is used together with COObjWrBufStart() to write an object entry with a size greater than 4. Prototype int16_t COObjWrBufCont ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint8_t size ); Arguments Parameter Description obj pointer to object entry node pointer to parent node buffer pointer to source memory size size of source buffer Returned Value ==CO_ERR_NONE : successful operation !=CO_ERR_NONE : an error is detected Example see Example in COObjWrBufStart() COObjWrBufStart() # The function is used together with COObjWrBufCont() to write an object entry with a size greater than 4. Prototype int16_t COObjWrBufStart ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint8_t size ); Arguments Parameter Description obj pointer to object entry node pointer to parent node buffer pointer to source memory size size of source buffer Returned Value ==CO_ERR_NONE : successful operation !=CO_ERR_NONE : an error is detected Example The following example writes a byte-stream to the hypothetical application-specific object entry \"[1234:56]\" within the object directory of the CANopen node AppNode. CPU_INT08U buffer [ 10 ] = { 'H' , 'e' , 'l' , 'l' , 'o' , 'W' , 'o' , 'r' , 'l' , 'd' }; CPU_INT16S err ; CO_OBJ * entry ; : entry = CODictFind ( & ( AppNode . Dict ), CO_DEV ( 0x1234 , 0x56 )); err = COObjWrBufStart ( entry , & AppNode , buffer , 10 ); if ( err == CO_ERR_NONE ) { do { /* stream bytes to object */ err = COObjWrBufCont ( entry , & AppNode , buffer , 10 ); } while ( err == CO_ERR_NONE ); } else { /* error during writing */ } : Attention This function is used when reading data in smaller junks (e.g. internaly the SDO transfers is using this function). Within the application you most likely use the related memory area due to performance issues. COObjWrValue() # The access with this function to an object entry will be done with the casting of the object entry values to the requested value width. Prototype int16_t COObjWrValue ( CO_OBJ * obj , CO_NODE * node , void * value , uint8_t width ); Arguments Parameter Description obj pointer to object entry node pointer to parent node value pointer to source memory width width of write value (must be 1, 2 or 4 and reflecting the width of the referenced variable) Returned Value ==CO_ERR_NONE : successful operation !=CO_ERR_NONE : an error is detected Example The following example writes a byte-stream to the hypothetical application-specific object entry \"[1234:56]\" within the object directory of the CANopen node AppNode. uint32_t value = 1234 ; CO_OBJ * entry ; : entry = CODictFind ( & ( AppNode . Dict ), CO_DEV ( 0x1234 , 0x56 )); err = COObjWrValue ( entry , & AppNode , & value , sizeof ( value )); :","title":"Object Entry"},{"location":"api/object/#object-entry","text":"The object component provides an interface to the individual object entries.","title":"Object Entry"},{"location":"api/object/#module-context","text":"classDiagram CO_NODE o-- CO_OBJ : Node CO_OBJ_TYPE o-- CO_OBJ : Type CO_DATA *-- CO_OBJ : Data class CO_OBJ { -uint32_t Key +COObjGetSize(width) uint32_t +COObjRdBufCont(destination, size) int16_t +COObjRdBufStart(destination, size) int16_t +COObjRdValue(destination, width, nodeId) int16_t +COObjWrBufCont(source, size) int16_t +COObjWrBufStart(source, size) int16_t +COObjWrValue(source, width, nodeId) int16_t +COObjTypeUserSDOAbort(node, code) void }","title":"Module Context"},{"location":"api/object/#structure-data","text":"The class CO_OBJ is defined within co_obj.h and is responsible for the CANopen object entry data access handling. The following data members are in this class: Data Member Type Description Data CO_DATA data information of object entry Key uint32_t Encoded object entry properties Type CO_OBJ_TYPE* pointer to object type Info The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node.","title":"Structure Data"},{"location":"api/object/#member-functions","text":"The following table describes the API functions of the CANopen object entry module. These functions are implemented within the source file: co_obj.c/h","title":"Member Functions"},{"location":"api/object/#coobjgetsize","text":"The argument width is most likely given '0' (=unknown) when getting the size of an object entry. The intended use of this argument is for write access of dynamic sizes of user type objects (e.g. firmware loading with a maximum size). Prototype uint32_t COObjGetSize ( CO_OBJ * obj , CO_NODE * node , uint32_t width ); Arguments Parameter Description obj pointer to object entry node pointer to parent node width expected object size in byte (or 0 if unknown) Returned Value >0 : object entry size in bytes =0 : an error is detected Example The following example gets the size of the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. uint32_t size ; CO_OBJ * entry ; : entry = CODictFind ( & ( AppNode . Dict ), CO_DEV ( 0x1234 , 0x56 )); size = COObjGetSize ( entry , & AppNode , 0 ); :","title":"COObjGetSize()"},{"location":"api/object/#coobjrdbufcont","text":"The function is used together with COObjRdBufStart() to read an object entry with a size greater than 4. Prototype int16_t COObjRdBufCont ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint8_t size ); Arguments Parameter Description obj pointer to object entry node pointer to parent node buffer pointer to destination memory size size of destination buffer Returned Value ==CO_ERR_NONE : successful operation !=CO_ERR_NONE : an error is detected Example see Example in COObjRdBufStart() Attention This function is used when reading data in smaller junks (e.g. internaly the SDO transfers is using this function). Within the application you most likely use the related memory area due to performance issues.","title":"COObjRdBufCont()"},{"location":"api/object/#coobjrdbufstart","text":"The function is used together with COObjRdBufCont() to read an object entry with a size greater than 4. Prototype int16_t COObjRdBufStart ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint8_t size ); Arguments Parameter Description obj pointer to object entry node pointer to parent node buffer pointer to destination memory size size of destination buffer Returned Value ==CO_ERR_NONE : successful operation !=CO_ERR_NONE : an error is detected Example The following example reads the byte-stream of the hypothetical application-specific object entry \"[1234:56]\" within the object directory of the CANopen node AppNode in junks of 10 Byte. uint8_t active ; : uint8_t buffer [ 10 ]; int16_t err ; CO_OBJ * entry ; : entry = CODictFind ( & ( AppNode . Dict ), CO_DEV ( 0x1234 , 0x56 )); if ( active = 0 ) { err = COObjRdBufStart ( entry , & AppNode , buffer , 10 ); if ( err == CO_ERR_NONE ) { active = 1 ; } else { /* error handline and diagnostics */ } } else { /* read the next 10 Byte snippet from object entry */ err = COObjRdBufCont ( entry , & AppNode , buffer , 10 ); if ( err == CO_ERR_NONE ) { /* do something with the 10 Byte data snippet */ } else { active = 0 ; } } : Attention This function is used when reading data in smaller junks (e.g. internaly the SDO transfers is using this function). Within the application you most likely use the related memory area due to performance issues.","title":"COObjRdBufStart()"},{"location":"api/object/#coobjrdvalue","text":"The access with this function to an object entry will be done with the casting of the object entry values to the requested value width. Prototype int16_t COObjRdValue ( CO_OBJ * obj , CO_NODE * node , void * value , uint8_t width ); Arguments Parameter Description obj pointer to object entry node pointer to parent node value pointer to destination variable width width of read value (must be 1, 2 or 4 and reflecting the width of the referenced variable) Returned Value ==CO_ERR_NONE : successful operation !=CO_ERR_NONE : an error is detected Example The following example gets the value of the hypothetical application-specific object entry \"[1234:56]\" within the object dictionary of the CANopen node AppNode. uint32_t value ; CO_OBJ * entry ; : entry = CODictFind ( & ( AppNode . Dict ), CO_DEV ( 0x1234 , 0x56 )); err = COObjRdValue ( entry , & AppNode , & value , sizeof ( value )); :","title":"COObjRdValue()"},{"location":"api/object/#coobjtypeusersdoabort","text":"This function allows the definition of user defined SDO abort codes within user type function implementations. Prototype void COObjTypeUserSDOAbort ( CO_OBJ * obj , CO_NODE * node , uint32_t abort ); Arguments Parameter Description obj pointer to object entry node pointer to parent node abort user defined abort code Example The following write-function for the type COTDemo send the user defined SDO Abort code \"0x01020304\" on a write access to object entries with this user type. const CO_OBJ_TYPE COTDemo = { 0 , 0 , 0 , DemoWrite }; #define CO_TDEMO ((CO_OBJ_TYPE*)&COTDemo) int16_t DemoWrite ( CO_OBJ * obj , struct CO_NODE_T * node , void * buffer , uint32_t size ) { /* define the SDO Abort code */ COObjTypeUserSDOAbort ( obj , node , 0x01020304 ); /* indicate an write error */ return CO_ERR_TYPE_WR ; } Attention The CiA standard doesn't reserve or allow any manufacturer specific SDO Abort code regions. Therefore, use this function with care.","title":"COObjTypeUserSDOAbort()"},{"location":"api/object/#coobjwrbufcont","text":"The function is used together with COObjWrBufStart() to write an object entry with a size greater than 4. Prototype int16_t COObjWrBufCont ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint8_t size ); Arguments Parameter Description obj pointer to object entry node pointer to parent node buffer pointer to source memory size size of source buffer Returned Value ==CO_ERR_NONE : successful operation !=CO_ERR_NONE : an error is detected Example see Example in COObjWrBufStart()","title":"COObjWrBufCont()"},{"location":"api/object/#coobjwrbufstart","text":"The function is used together with COObjWrBufCont() to write an object entry with a size greater than 4. Prototype int16_t COObjWrBufStart ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint8_t size ); Arguments Parameter Description obj pointer to object entry node pointer to parent node buffer pointer to source memory size size of source buffer Returned Value ==CO_ERR_NONE : successful operation !=CO_ERR_NONE : an error is detected Example The following example writes a byte-stream to the hypothetical application-specific object entry \"[1234:56]\" within the object directory of the CANopen node AppNode. CPU_INT08U buffer [ 10 ] = { 'H' , 'e' , 'l' , 'l' , 'o' , 'W' , 'o' , 'r' , 'l' , 'd' }; CPU_INT16S err ; CO_OBJ * entry ; : entry = CODictFind ( & ( AppNode . Dict ), CO_DEV ( 0x1234 , 0x56 )); err = COObjWrBufStart ( entry , & AppNode , buffer , 10 ); if ( err == CO_ERR_NONE ) { do { /* stream bytes to object */ err = COObjWrBufCont ( entry , & AppNode , buffer , 10 ); } while ( err == CO_ERR_NONE ); } else { /* error during writing */ } : Attention This function is used when reading data in smaller junks (e.g. internaly the SDO transfers is using this function). Within the application you most likely use the related memory area due to performance issues.","title":"COObjWrBufStart()"},{"location":"api/object/#coobjwrvalue","text":"The access with this function to an object entry will be done with the casting of the object entry values to the requested value width. Prototype int16_t COObjWrValue ( CO_OBJ * obj , CO_NODE * node , void * value , uint8_t width ); Arguments Parameter Description obj pointer to object entry node pointer to parent node value pointer to source memory width width of write value (must be 1, 2 or 4 and reflecting the width of the referenced variable) Returned Value ==CO_ERR_NONE : successful operation !=CO_ERR_NONE : an error is detected Example The following example writes a byte-stream to the hypothetical application-specific object entry \"[1234:56]\" within the object directory of the CANopen node AppNode. uint32_t value = 1234 ; CO_OBJ * entry ; : entry = CODictFind ( & ( AppNode . Dict ), CO_DEV ( 0x1234 , 0x56 )); err = COObjWrValue ( entry , & AppNode , & value , sizeof ( value )); :","title":"COObjWrValue()"},{"location":"api/parameter/","text":"Parameter Storage # The parameter component provides an interface to the parameter group handling. Module Context # classDiagram CO_NODE -- CO_PARA CO_NMT_RESET *-- CO_PARA : Type class CO_PARA { -uint32_t Size -uint8_t Start -uint8_t Default -uintptr_t Ident -uint32_t Value +COParaRestore(node) +COParaStore(node) } class CO_NMT_RESET { <<enumeration>> } Structure Data # The class CO_PARA is defined within co_para.h and is responsible for storing and restoring the right CANopen parameter groups in dependency to the NMT reset type. The following data members are in this class: Data Member Type Description Default uint8_t* pointer to default parameter block Ident uintptr_t* pointer to user identification code Size uint32_t size of parameter memory block Start uint8_t* pointer to parameter memory block Type CO_NMT_RESET parameter group reset type Value uint32_t value, when reading this parameter group Member Functions # The following table describes the API functions of the CANopen parameter module. These functions are implemented within the source file: co_para.c/h COParaRestore() # The changes in the NVM of the given parameter group will be replaced with the default values by calling the user callback function CO_ParaDefault() . Prototype CO_ERR COParaRestore ( CO_PARA * pg , CO_NODE * node ); Arguments Parameter Description pg pointer to parameter group node pointer to parent node Returned Value ==CO_ERR_NONE : successful operation !=CO_ERR_NONE : an error is detected COParaStore() # The whole parameter group will be stored in NVM by calling the NVM driver function for writing data. Prototype CO_ERR COParaStore ( CO_PARA * pg , CO_NODE * node ); Arguments Parameter Description pg pointer to parameter group node pointer to parent node Returned Value ==CO_ERR_NONE : successful operation !=CO_ERR_NONE : an error is detected","title":"Parameter Storage"},{"location":"api/parameter/#parameter-storage","text":"The parameter component provides an interface to the parameter group handling.","title":"Parameter Storage"},{"location":"api/parameter/#module-context","text":"classDiagram CO_NODE -- CO_PARA CO_NMT_RESET *-- CO_PARA : Type class CO_PARA { -uint32_t Size -uint8_t Start -uint8_t Default -uintptr_t Ident -uint32_t Value +COParaRestore(node) +COParaStore(node) } class CO_NMT_RESET { <<enumeration>> }","title":"Module Context"},{"location":"api/parameter/#structure-data","text":"The class CO_PARA is defined within co_para.h and is responsible for storing and restoring the right CANopen parameter groups in dependency to the NMT reset type. The following data members are in this class: Data Member Type Description Default uint8_t* pointer to default parameter block Ident uintptr_t* pointer to user identification code Size uint32_t size of parameter memory block Start uint8_t* pointer to parameter memory block Type CO_NMT_RESET parameter group reset type Value uint32_t value, when reading this parameter group","title":"Structure Data"},{"location":"api/parameter/#member-functions","text":"The following table describes the API functions of the CANopen parameter module. These functions are implemented within the source file: co_para.c/h","title":"Member Functions"},{"location":"api/parameter/#copararestore","text":"The changes in the NVM of the given parameter group will be replaced with the default values by calling the user callback function CO_ParaDefault() . Prototype CO_ERR COParaRestore ( CO_PARA * pg , CO_NODE * node ); Arguments Parameter Description pg pointer to parameter group node pointer to parent node Returned Value ==CO_ERR_NONE : successful operation !=CO_ERR_NONE : an error is detected","title":"COParaRestore()"},{"location":"api/parameter/#coparastore","text":"The whole parameter group will be stored in NVM by calling the NVM driver function for writing data. Prototype CO_ERR COParaStore ( CO_PARA * pg , CO_NODE * node ); Arguments Parameter Description pg pointer to parameter group node pointer to parent node Returned Value ==CO_ERR_NONE : successful operation !=CO_ERR_NONE : an error is detected","title":"COParaStore()"},{"location":"api/timer/","text":"Timer Handling # The timer component provides an interface to function executions initiated by a timer. Module Context # classDiagram CO_NODE o-- CO_TMR CO_TMR_ACTION o-- CO_TMR : APool, Acts CO_TMR_TIME o-- CO_TMR : TPool, Free, Use, Elapsed class CO_TMR { -uint32_t Max -uint32_t Freq +COTmrCreate(start, cycle, function, para) int16_t +COTmrDelete(action) int16_t +COTmrGetMinTime(unit) uint16_t +COTmrGetTicks(time, unit) int32_t +COTmrProcess() +COTmrService() int16_t } Structure Data # The class CO_TMR is defined within co_tmr.h and is responsible for the CANopen highspeed timer management. The following data members are in this class: Data Member Type Description Acts CO_TMR_ACTION* pointer to the root of free actions linked list APool[] CO_TMR_ACTION timer action pool array Elapsed CO_TMR_TIME* pointer to the root of elapsed timers linked list Free CO_TMR_TIME* pointer to the root of free events linked list Freq uint32_t timer ticks per second Max uint32_t maximum nunber of timed actions Node CO_NODE* pointer to parent node object TPool[] CO_TMR_TIME timer event pool array Use CO_TMR_TIME* pointer to the root of used events linked list Note The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node. Member Functions # The following table describes the API functions of the CANopen timer module. With the listed functions we can define the execution of actions after a given time interval with or without a cycle time. The functions are implemented within the source files: co_tmr.c/h . COTmrCreate() # This function is used within the CANopen stack for timed actions. It is possible to use timed actions in the application, too. Prototype int16_t COTmrCreate ( CO_TMR * tmr , uint32_t start , uint32_t cycle , CO_TMR_FUNC function , void * para ); Arguments Parameter Description tmr pointer to timer object start delta time in ticks for the first timer-event cycle if != 0, the delta time in ticks for the cyclic timer events function pointer to the action callback function para pointer to the callback function parameter Returned Value >=0 : action identifier (successful operation) <0 : an error is detected Example The following example installs a cyclic called function AppCyclicFunc() to the CANopen node AppNode. The timed function will be called the first time after 10ms and then every 25ms with the parameter: 0xcafe. CO_TMR * tmr ; int16_t aid ; uint32_t start ; uint32_t cycle ; : tmr = & AppNode . Tmr ; start = COTmrGetTicks ( tmr , 10 , CO_TMR_UNIT_1MS ); cycle = COTmrGetTicks ( tmr , 25 , CO_TMR_UNIT_1MS ); aid = COTmrCreate ( tmr , start , cycle , AppCyclicFunc , 0xcafe ); if ( aid >= 0 ) { /* tid holds the timer identifier */ } else { /* error during creation of timed action */ } : Note The example assumes, that the timer callback function AppCyclicFunc() is implemented with the correct prototype. The hardware timer is configured with sufficient timer clock frequency to achieve the 5ms resolution. COTmrDelete() # This function is used within the CANopen stack for timed actions. It is possible to use timed actions in the application, too. Prototype int16_t COTmrDelete ( CO_TMR * tmr , int16_t action ); Arguments Parameter Description tmr pointer to timer object action action identifier, returned by COTmrCreate() Returned Value >=0 : action identifier (successful operation) <0 : an error is detected Example The following calls a critical function AppCritFunc() and installs a function AppEmcyFunc() to the CANopen node AppNode to guarantee a maximum runtime of 150ms. The timed function will be called after 150ms and perform emergency handling with the parameter 0xdead. If the AppCritFunc() is finished before 150ms, the timed emergency function call will be removed. CO_TMR * tmr ; CPU_INT16S aid ; uint32_t max ; : tmr = & AppNode . Tmr ; max = COTmrGetTicks ( tmr , 150 , CO_TMR_UNIT_1MS ); aid = COTmrCreate ( tmr , max , 0 , AppEmcyFunc , 0xdead ); if ( aid >= 0 ) { AppCritFunc (); err = COTmrDelete ( tmr , aid ); if ( err < 0 ) { /* error during deleting the timed action */ } } else { /* error during creation of timed action */ } : Note The example assumes, that the timer callback function AppEmcyFunc() and the application function AppCritFunc() are implemented with the correct prototype. The hardware timer is configured with sufficient timer clock frequency to achieve the 50ms resolution. COTmrGetMinTime() # This function returns the time interval in the given unit, which represents a single configured timer tick. Prototype uint16_t COTmrGetMinTime ( CO_TMR * tmr , uint32_t unit ); Arguments Parameter Description tmr pointer to timer object unit unit of given time ( CO_TMR_UNIT_1MS or CO_TMR_UNIT_100US ) Returned Value >0 : time value in the given time interval for a single timer tick =0 : a single given time interval unit is not possible with the used timer Example The following example calculates the smallest possible time interval in 100us. CO_TMR * tmr ; uint32_t min_100us ; : tmr = & AppNode . Tmr ; : min_100us = COTmrGetMinTime ( tmr , CO_TMR_UNIT_100US ); if ( min_100us == 0 ) { /* timer is not configured */ } else { /* you can use time intervals with multiple of min_100us */ } : COTmrGetTicks() # This function is used within the CANopen stack for calculating timeouts, event-times and other needed time intervals. Prototype int32_t COTmrGetTicks ( CO_TMR * tmr , uint16_t time , uint32_t unit ); Arguments Parameter Description tmr pointer to timer object time time interval as a value of given units unit unit of given time ( CO_TMR_UNIT_1MS or CO_TMR_UNIT_100US ) Returned Value >0 : timer ticks for the given time interval =0 : given time interval is not possible with the used timer Example The following example calculates the number of ticks for 10.7ms and for 2.5s. CO_TMR * tmr ; uint32_t tick_10_7ms ; uint32_t tick_2500ms ; : tmr = & AppNode . Tmr ; : tick_10_7ms = COTmrGetTicks ( tmr , 107 , CO_TMR_UNIT_100US ); if ( tick_10_7ms == 0 ) { /* time interval 10.7ms is not possible */ } else { /* you can use the time interval 10.7ms */ } : tick_2500ms = COTmrGetTicks ( tmr , 2500 , CO_TMR_UNIT_1MS ); if ( tick_2500ms == 0 ) { /* time interval 2.5s is not possible */ } else { /* you can use the time interval 2.5s */ } : Note The example assumes that the CANopen node is already initialized with CONodeInit() because the specified frequency in the specification structure is the foundation for these calculations. COTmrProcess() # The function is used decouple the generation of the periodic time base and the timed action processing. Prototype void COTmrProcess ( CO_TMR * tmr ); Arguments Parameter Description tmr pointer to timer object Returned Value none Example The timed action processing must be called cyclic. Due to the timer management, the calling sequence is irrelevant. Therefore the function may be called in the background loop of the application: void main ( int argc , char * argv []) { : while ( 1 ) { : COTmrProcess ( & ( AppNode . Tmr )); : } } COTmrService() # The function is used to generate a periodic time base and must be called cyclic. Prototype int16_t COTmrService ( CO_TMR * tmr ); Arguments Parameter Description tmr pointer to timer object Returned Value =0 : no timer is elapsed >0 : at least one timer is elapsed <0 : an error is detected Example The following interrupt service function generates the time base for the CANopen timed actions with periodic calls of the function COTmrService() . When using an RTOS, the return value may be used to decide of triggering a separate timer task to process the elapsed events. void HardwareTimerISR ( void ) { int16_t num ; num = COTmrService ( & ( AppNode . Tmr )); if ( num > 0 ) { /* post an event to the timer processing task */ } }","title":"Timer Handling"},{"location":"api/timer/#timer-handling","text":"The timer component provides an interface to function executions initiated by a timer.","title":"Timer Handling"},{"location":"api/timer/#module-context","text":"classDiagram CO_NODE o-- CO_TMR CO_TMR_ACTION o-- CO_TMR : APool, Acts CO_TMR_TIME o-- CO_TMR : TPool, Free, Use, Elapsed class CO_TMR { -uint32_t Max -uint32_t Freq +COTmrCreate(start, cycle, function, para) int16_t +COTmrDelete(action) int16_t +COTmrGetMinTime(unit) uint16_t +COTmrGetTicks(time, unit) int32_t +COTmrProcess() +COTmrService() int16_t }","title":"Module Context"},{"location":"api/timer/#structure-data","text":"The class CO_TMR is defined within co_tmr.h and is responsible for the CANopen highspeed timer management. The following data members are in this class: Data Member Type Description Acts CO_TMR_ACTION* pointer to the root of free actions linked list APool[] CO_TMR_ACTION timer action pool array Elapsed CO_TMR_TIME* pointer to the root of elapsed timers linked list Free CO_TMR_TIME* pointer to the root of free events linked list Freq uint32_t timer ticks per second Max uint32_t maximum nunber of timed actions Node CO_NODE* pointer to parent node object TPool[] CO_TMR_TIME timer event pool array Use CO_TMR_TIME* pointer to the root of used events linked list Note The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node.","title":"Structure Data"},{"location":"api/timer/#member-functions","text":"The following table describes the API functions of the CANopen timer module. With the listed functions we can define the execution of actions after a given time interval with or without a cycle time. The functions are implemented within the source files: co_tmr.c/h .","title":"Member Functions"},{"location":"api/timer/#cotmrcreate","text":"This function is used within the CANopen stack for timed actions. It is possible to use timed actions in the application, too. Prototype int16_t COTmrCreate ( CO_TMR * tmr , uint32_t start , uint32_t cycle , CO_TMR_FUNC function , void * para ); Arguments Parameter Description tmr pointer to timer object start delta time in ticks for the first timer-event cycle if != 0, the delta time in ticks for the cyclic timer events function pointer to the action callback function para pointer to the callback function parameter Returned Value >=0 : action identifier (successful operation) <0 : an error is detected Example The following example installs a cyclic called function AppCyclicFunc() to the CANopen node AppNode. The timed function will be called the first time after 10ms and then every 25ms with the parameter: 0xcafe. CO_TMR * tmr ; int16_t aid ; uint32_t start ; uint32_t cycle ; : tmr = & AppNode . Tmr ; start = COTmrGetTicks ( tmr , 10 , CO_TMR_UNIT_1MS ); cycle = COTmrGetTicks ( tmr , 25 , CO_TMR_UNIT_1MS ); aid = COTmrCreate ( tmr , start , cycle , AppCyclicFunc , 0xcafe ); if ( aid >= 0 ) { /* tid holds the timer identifier */ } else { /* error during creation of timed action */ } : Note The example assumes, that the timer callback function AppCyclicFunc() is implemented with the correct prototype. The hardware timer is configured with sufficient timer clock frequency to achieve the 5ms resolution.","title":"COTmrCreate()"},{"location":"api/timer/#cotmrdelete","text":"This function is used within the CANopen stack for timed actions. It is possible to use timed actions in the application, too. Prototype int16_t COTmrDelete ( CO_TMR * tmr , int16_t action ); Arguments Parameter Description tmr pointer to timer object action action identifier, returned by COTmrCreate() Returned Value >=0 : action identifier (successful operation) <0 : an error is detected Example The following calls a critical function AppCritFunc() and installs a function AppEmcyFunc() to the CANopen node AppNode to guarantee a maximum runtime of 150ms. The timed function will be called after 150ms and perform emergency handling with the parameter 0xdead. If the AppCritFunc() is finished before 150ms, the timed emergency function call will be removed. CO_TMR * tmr ; CPU_INT16S aid ; uint32_t max ; : tmr = & AppNode . Tmr ; max = COTmrGetTicks ( tmr , 150 , CO_TMR_UNIT_1MS ); aid = COTmrCreate ( tmr , max , 0 , AppEmcyFunc , 0xdead ); if ( aid >= 0 ) { AppCritFunc (); err = COTmrDelete ( tmr , aid ); if ( err < 0 ) { /* error during deleting the timed action */ } } else { /* error during creation of timed action */ } : Note The example assumes, that the timer callback function AppEmcyFunc() and the application function AppCritFunc() are implemented with the correct prototype. The hardware timer is configured with sufficient timer clock frequency to achieve the 50ms resolution.","title":"COTmrDelete()"},{"location":"api/timer/#cotmrgetmintime","text":"This function returns the time interval in the given unit, which represents a single configured timer tick. Prototype uint16_t COTmrGetMinTime ( CO_TMR * tmr , uint32_t unit ); Arguments Parameter Description tmr pointer to timer object unit unit of given time ( CO_TMR_UNIT_1MS or CO_TMR_UNIT_100US ) Returned Value >0 : time value in the given time interval for a single timer tick =0 : a single given time interval unit is not possible with the used timer Example The following example calculates the smallest possible time interval in 100us. CO_TMR * tmr ; uint32_t min_100us ; : tmr = & AppNode . Tmr ; : min_100us = COTmrGetMinTime ( tmr , CO_TMR_UNIT_100US ); if ( min_100us == 0 ) { /* timer is not configured */ } else { /* you can use time intervals with multiple of min_100us */ } :","title":"COTmrGetMinTime()"},{"location":"api/timer/#cotmrgetticks","text":"This function is used within the CANopen stack for calculating timeouts, event-times and other needed time intervals. Prototype int32_t COTmrGetTicks ( CO_TMR * tmr , uint16_t time , uint32_t unit ); Arguments Parameter Description tmr pointer to timer object time time interval as a value of given units unit unit of given time ( CO_TMR_UNIT_1MS or CO_TMR_UNIT_100US ) Returned Value >0 : timer ticks for the given time interval =0 : given time interval is not possible with the used timer Example The following example calculates the number of ticks for 10.7ms and for 2.5s. CO_TMR * tmr ; uint32_t tick_10_7ms ; uint32_t tick_2500ms ; : tmr = & AppNode . Tmr ; : tick_10_7ms = COTmrGetTicks ( tmr , 107 , CO_TMR_UNIT_100US ); if ( tick_10_7ms == 0 ) { /* time interval 10.7ms is not possible */ } else { /* you can use the time interval 10.7ms */ } : tick_2500ms = COTmrGetTicks ( tmr , 2500 , CO_TMR_UNIT_1MS ); if ( tick_2500ms == 0 ) { /* time interval 2.5s is not possible */ } else { /* you can use the time interval 2.5s */ } : Note The example assumes that the CANopen node is already initialized with CONodeInit() because the specified frequency in the specification structure is the foundation for these calculations.","title":"COTmrGetTicks()"},{"location":"api/timer/#cotmrprocess","text":"The function is used decouple the generation of the periodic time base and the timed action processing. Prototype void COTmrProcess ( CO_TMR * tmr ); Arguments Parameter Description tmr pointer to timer object Returned Value none Example The timed action processing must be called cyclic. Due to the timer management, the calling sequence is irrelevant. Therefore the function may be called in the background loop of the application: void main ( int argc , char * argv []) { : while ( 1 ) { : COTmrProcess ( & ( AppNode . Tmr )); : } }","title":"COTmrProcess()"},{"location":"api/timer/#cotmrservice","text":"The function is used to generate a periodic time base and must be called cyclic. Prototype int16_t COTmrService ( CO_TMR * tmr ); Arguments Parameter Description tmr pointer to timer object Returned Value =0 : no timer is elapsed >0 : at least one timer is elapsed <0 : an error is detected Example The following interrupt service function generates the time base for the CANopen timed actions with periodic calls of the function COTmrService() . When using an RTOS, the return value may be used to decide of triggering a separate timer task to process the elapsed events. void HardwareTimerISR ( void ) { int16_t num ; num = COTmrService ( & ( AppNode . Tmr )); if ( num > 0 ) { /* post an event to the timer processing task */ } }","title":"COTmrService()"},{"location":"api/tpdo/","text":"TPDO Event # The TPDO component provides an interface to the CANopen PDO transmission triggers. Module Context # classDiagram CO_NODE o-- CO_TPDO CO_OBJ o-- CO_TPDO : Map class CO_TPDO { -uint32_t Identifier -int16_t EvTmr -uint16_t Event -int16_t InTmr -uint16_t Inhibit -uint8_t Flags -uint8_t ObjNum -uint8_t Size[] +COTPdoTrigObj(obj) +COTPdoTrigPdo(num) } Structure Data # The class CO_TPDO is defined within co_tpdo.h and is responsible for the CANopen transmit process data objects (TPDO). The following data members are in this class: Data Member Type Description Event uint16_t event time in timer ticks EvTmr int16_t event timer identifier Flags uint8_t transmit status flags Identifier uint32_t CAN message identifier Inhibit uint16_t inhibit timer in timer ticks InTmr int16_t inhibit timer identifier Map[] CO_OBJ* pointer list to mapped object entries Size[] uint8_t* size of mapped values in PDO payload Node CO_NODE* pointer to parent node ObjNum uint8_t number of mapped object entries Info The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node. Member Functions # The following table describes the API functions of the CANopen transmit PDO module. These functions are implemented within the source file: co_tpdo.c/h COTPdoTrigObj() # The event will be distributed to all TPDOs, which holds an active mapping entry to this object entry. Prototype void COTPdoTrigObj ( CO_TPDO * pdo , CO_OBJ * obj ); Arguments Parameter Description pdo pointer to start of TPDO array obj pointer to object entry Returned Value none Example The following example triggers the transmission of all TPDOs of the CANopen node AppNode, which contains the hypothetical object directory entry \"[1234:56]\". CO_OBJ * entry ; : entry = CODirFind ( & ( AppNode . Dir ), CO_DEV ( 0x1234 , 0x56 )); COTPdoTrigObj ( & ( AppNode . TPdo [ 0 ]), entry ); : COTPdoTrigPdo() # The function call will immediately initiate the TPDO transmission, independent on the TPDO communication type settings in the object dictionary. Prototype void COTPdoTrigPdo ( CO_TPDO * pdo , uint16_t num ); Arguments Parameter Description pdo pointer to start of TPDO array num number of TPDO (0..511) Returned Value none Example The following example triggers the transmission of TPDO #3 of the CANopen node AppNode. : COTPdoTrigPdo ( & ( AppNode . TPdo [ 0 ]), 3 ); :","title":"TPDO Event"},{"location":"api/tpdo/#tpdo-event","text":"The TPDO component provides an interface to the CANopen PDO transmission triggers.","title":"TPDO Event"},{"location":"api/tpdo/#module-context","text":"classDiagram CO_NODE o-- CO_TPDO CO_OBJ o-- CO_TPDO : Map class CO_TPDO { -uint32_t Identifier -int16_t EvTmr -uint16_t Event -int16_t InTmr -uint16_t Inhibit -uint8_t Flags -uint8_t ObjNum -uint8_t Size[] +COTPdoTrigObj(obj) +COTPdoTrigPdo(num) }","title":"Module Context"},{"location":"api/tpdo/#structure-data","text":"The class CO_TPDO is defined within co_tpdo.h and is responsible for the CANopen transmit process data objects (TPDO). The following data members are in this class: Data Member Type Description Event uint16_t event time in timer ticks EvTmr int16_t event timer identifier Flags uint8_t transmit status flags Identifier uint32_t CAN message identifier Inhibit uint16_t inhibit timer in timer ticks InTmr int16_t inhibit timer identifier Map[] CO_OBJ* pointer list to mapped object entries Size[] uint8_t* size of mapped values in PDO payload Node CO_NODE* pointer to parent node ObjNum uint8_t number of mapped object entries Info The data within this structure must never be manipulated without the corresponding class member functions. This can lead to unpredictable behavior of the node.","title":"Structure Data"},{"location":"api/tpdo/#member-functions","text":"The following table describes the API functions of the CANopen transmit PDO module. These functions are implemented within the source file: co_tpdo.c/h","title":"Member Functions"},{"location":"api/tpdo/#cotpdotrigobj","text":"The event will be distributed to all TPDOs, which holds an active mapping entry to this object entry. Prototype void COTPdoTrigObj ( CO_TPDO * pdo , CO_OBJ * obj ); Arguments Parameter Description pdo pointer to start of TPDO array obj pointer to object entry Returned Value none Example The following example triggers the transmission of all TPDOs of the CANopen node AppNode, which contains the hypothetical object directory entry \"[1234:56]\". CO_OBJ * entry ; : entry = CODirFind ( & ( AppNode . Dir ), CO_DEV ( 0x1234 , 0x56 )); COTPdoTrigObj ( & ( AppNode . TPdo [ 0 ]), entry ); :","title":"COTPdoTrigObj()"},{"location":"api/tpdo/#cotpdotrigpdo","text":"The function call will immediately initiate the TPDO transmission, independent on the TPDO communication type settings in the object dictionary. Prototype void COTPdoTrigPdo ( CO_TPDO * pdo , uint16_t num ); Arguments Parameter Description pdo pointer to start of TPDO array num number of TPDO (0..511) Returned Value none Example The following example triggers the transmission of TPDO #3 of the CANopen node AppNode. : COTPdoTrigPdo ( & ( AppNode . TPdo [ 0 ]), 3 ); :","title":"COTPdoTrigPdo()"},{"location":"examples/flash-user-domain/","text":"Firmware Upload # The CANopen block transfer protocoll is efficient for uploading and programming a firmware update. This example explains the implementation of a flash-domain object entry. Example Goal # The example focus on a manufacturer specific data type, which allows writing a domain into a FLASH memory area. Object Entry Definitions # We define some manufacturer specific entries in the object dictionary (free choice): Index Subindex Type Access Value Description 6789h 0 UNSIGNED8 Const 2 Highest Subindex 6789h 1 UNSIGNED32 Write Only 1 Control Commands 6789h 2 DOMAIN Write Only 0 Firmware Image The subindex 1h is used to control the firmware reprogramming with some specific commands. For example writing the value 0xdead will erase the current firmware. Some other command ideas are: unlock firmware (statemachine with passphrase or a seed/key algorithm) activate firmware (calculate and store checksum to activate new image) verify firmware (calculate and return checksum for user interface) The subindex 2h is used to program the firmware image into the FLASH memory region. Type: Control Commands # Lets implement the firmware control user type as shown in CANopen Usage: User Object : uint32_t FwCtrlSize ( CO_OBJ * obj , CO_NODE * node , uint32_t width ); CO_ERR FwCtrlWrite ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ); const CO_OBJ_TYPE FwCtrl = { FwCtrlSize , 0 , 0 , FwCtrlWrite }; #define FW_CTRL ((CO_OBJ_TYPE*)&FwCtrl) Erase Firmware # The write access to this object entry triggers actions depending on the writing value. For a most simple implementation, we start erasing the firmware when writing the value 0xdeadbeef to the object entry. All other write values are ignored. uint32_t FwCtrlSize ( CO_OBJ * obj , CO_NODE * node , uint32_t width ) { const CO_OBJ_TYPE * uint32 = CO_TUNSIGNED32 ; return uint32 -> Size ( obj , node , width ); } CO_ERR FwCtrlWrite ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ) { uint32_t command = * (( uint32_t * ) buffer ); CO_ERR result = CO_ERR_TYPE_WR ; if ( command == ' 0xdeadbeef ' ) { /* erase your firmware region in FLASH here */ result = CO_ERR_NONE ; } return result ; } Warning You should implement a much more sophisticated sequence for unlocking and erasing your FLASH device. This is simplified for demo purpose only! Type: Firmware Image # Implementing the firmware image upload user type needs three callback functions: uint32_t FwImageSize ( CO_OBJ * obj , CO_NODE * node , uint32_t width ); CO_ERR FwImageInit ( CO_OBJ * obj , CO_NODE * node ); CO_ERR FwImageWrite ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ); const CO_OBJ_TYPE FwImage = { FwImageSize , FwImageInit , 0 , FwImageWrite }; #define FW_IMAGE ((CO_OBJ_TYPE*)&FwImage) Image size # We want to allow uploading firmware images which are smaller than whole FLASH domain area. For this reason, we return the given width of the started firmware upload sequence as size of this domain. uint32_t FwImageSize ( CO_OBJ * obj , CO_NODE * node , uint32_t width ); { CO_OBJ_DOM * domain = ( CO_OBJ_DOM * )( obj -> Data ); uint32_t size = domain -> Size ; /* allow firmware image smaller or equal to the domain memory area */ if (( width < size ) && ( width > 0 )) { size = width ; } return size ; } Image initialization # During multiple the SDO server transfers, the working offset changes. This is internaly done with calling this function with the function id CO_CTRL_SET_OFF and a corresponsing offset value in the argument para CO_ERR FwImageInit ( CO_OBJ * obj , CO_NODE * node ) { CO_OBJ_DOM * domain = ( CO_OBJ_DOM * )( obj -> Data ); domain -> Offset = 0 ; return ( CO_ERR_NONE ); } Image write # The core of the firmware image write function is your project specific FLASH write function. The required basic information for calling your function are managed by the stack. CO_ERR FwImageWrite ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ); { CO_OBJ_DOM * domain = ( CO_OBJ_DOM * )( obj -> Data ); CO_ERR result = CO_ERR_TYPE_WR ; uint32_t address = ( uint32_t ) domain -> Start + domain -> Offset ; uint32_t success ; /* use your FLASH driver for writing the buffer to given address, e.g.: */ success = MyFlashDriverWrite ( address , ( uint8_t * buffer ), size ); if ( success ) domain -> Offset += size ; result = CO_ERR_NONE } return ( result ); } Info If you need to consider additional constraints due to your FLASH backend hardware, this constraints should be handled within your FLASH driver function, e.g.: programm granularity of 8 byte portions due to continuously running ECC checks, and similar.","title":"Firmware Upload"},{"location":"examples/flash-user-domain/#firmware-upload","text":"The CANopen block transfer protocoll is efficient for uploading and programming a firmware update. This example explains the implementation of a flash-domain object entry.","title":"Firmware Upload"},{"location":"examples/flash-user-domain/#example-goal","text":"The example focus on a manufacturer specific data type, which allows writing a domain into a FLASH memory area.","title":"Example Goal"},{"location":"examples/flash-user-domain/#object-entry-definitions","text":"We define some manufacturer specific entries in the object dictionary (free choice): Index Subindex Type Access Value Description 6789h 0 UNSIGNED8 Const 2 Highest Subindex 6789h 1 UNSIGNED32 Write Only 1 Control Commands 6789h 2 DOMAIN Write Only 0 Firmware Image The subindex 1h is used to control the firmware reprogramming with some specific commands. For example writing the value 0xdead will erase the current firmware. Some other command ideas are: unlock firmware (statemachine with passphrase or a seed/key algorithm) activate firmware (calculate and store checksum to activate new image) verify firmware (calculate and return checksum for user interface) The subindex 2h is used to program the firmware image into the FLASH memory region.","title":"Object Entry Definitions"},{"location":"examples/flash-user-domain/#type-control-commands","text":"Lets implement the firmware control user type as shown in CANopen Usage: User Object : uint32_t FwCtrlSize ( CO_OBJ * obj , CO_NODE * node , uint32_t width ); CO_ERR FwCtrlWrite ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ); const CO_OBJ_TYPE FwCtrl = { FwCtrlSize , 0 , 0 , FwCtrlWrite }; #define FW_CTRL ((CO_OBJ_TYPE*)&FwCtrl)","title":"Type: Control Commands"},{"location":"examples/flash-user-domain/#erase-firmware","text":"The write access to this object entry triggers actions depending on the writing value. For a most simple implementation, we start erasing the firmware when writing the value 0xdeadbeef to the object entry. All other write values are ignored. uint32_t FwCtrlSize ( CO_OBJ * obj , CO_NODE * node , uint32_t width ) { const CO_OBJ_TYPE * uint32 = CO_TUNSIGNED32 ; return uint32 -> Size ( obj , node , width ); } CO_ERR FwCtrlWrite ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ) { uint32_t command = * (( uint32_t * ) buffer ); CO_ERR result = CO_ERR_TYPE_WR ; if ( command == ' 0xdeadbeef ' ) { /* erase your firmware region in FLASH here */ result = CO_ERR_NONE ; } return result ; } Warning You should implement a much more sophisticated sequence for unlocking and erasing your FLASH device. This is simplified for demo purpose only!","title":"Erase Firmware"},{"location":"examples/flash-user-domain/#type-firmware-image","text":"Implementing the firmware image upload user type needs three callback functions: uint32_t FwImageSize ( CO_OBJ * obj , CO_NODE * node , uint32_t width ); CO_ERR FwImageInit ( CO_OBJ * obj , CO_NODE * node ); CO_ERR FwImageWrite ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ); const CO_OBJ_TYPE FwImage = { FwImageSize , FwImageInit , 0 , FwImageWrite }; #define FW_IMAGE ((CO_OBJ_TYPE*)&FwImage)","title":"Type: Firmware Image"},{"location":"examples/flash-user-domain/#image-size","text":"We want to allow uploading firmware images which are smaller than whole FLASH domain area. For this reason, we return the given width of the started firmware upload sequence as size of this domain. uint32_t FwImageSize ( CO_OBJ * obj , CO_NODE * node , uint32_t width ); { CO_OBJ_DOM * domain = ( CO_OBJ_DOM * )( obj -> Data ); uint32_t size = domain -> Size ; /* allow firmware image smaller or equal to the domain memory area */ if (( width < size ) && ( width > 0 )) { size = width ; } return size ; }","title":"Image size"},{"location":"examples/flash-user-domain/#image-initialization","text":"During multiple the SDO server transfers, the working offset changes. This is internaly done with calling this function with the function id CO_CTRL_SET_OFF and a corresponsing offset value in the argument para CO_ERR FwImageInit ( CO_OBJ * obj , CO_NODE * node ) { CO_OBJ_DOM * domain = ( CO_OBJ_DOM * )( obj -> Data ); domain -> Offset = 0 ; return ( CO_ERR_NONE ); }","title":"Image initialization"},{"location":"examples/flash-user-domain/#image-write","text":"The core of the firmware image write function is your project specific FLASH write function. The required basic information for calling your function are managed by the stack. CO_ERR FwImageWrite ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ); { CO_OBJ_DOM * domain = ( CO_OBJ_DOM * )( obj -> Data ); CO_ERR result = CO_ERR_TYPE_WR ; uint32_t address = ( uint32_t ) domain -> Start + domain -> Offset ; uint32_t success ; /* use your FLASH driver for writing the buffer to given address, e.g.: */ success = MyFlashDriverWrite ( address , ( uint8_t * buffer ), size ); if ( success ) domain -> Offset += size ; result = CO_ERR_NONE } return ( result ); } Info If you need to consider additional constraints due to your FLASH backend hardware, this constraints should be handled within your FLASH driver function, e.g.: programm granularity of 8 byte portions due to continuously running ECC checks, and similar.","title":"Image write"},{"location":"examples/setup-calibration-mode/","text":"Setup calibration mode # When dealing with analog values, there is often a calibration of the hardware required to achieve the best accuracy. This example situation is a good reason for implementing a manufacturer-specific factory area. Example Goal # The example focus is the user object for CAN triggered write access to a manufacturer-specific area. Object Type Idea # The main idea is a collection of object entries, which are writable after a simple identification mechanism. For a tiny use-case we assume to achieve a simple calibration mechanism. The application uses the calibration values to transform input values with a formula: adcValue = ( adcRaw * calFactor ) / calDivisor + calOffset ; Object Entry Definitions # We define some manufacturer specific entries in the object dictionary: Index Subindex Type Access Value Description 2F00h 0 UNSIGNED32 Const 4 Max. Subindex 2F00h 1 UNSIGNED32 Write Only 0 Calibration Key 2F00h 2 SIGNED32 Read Write 1 Cal. Factor 2F09h 3 SIGNED32 Read Write 1 Cal. Divisor 2F00h 4 SIGNED32 Read Write 0 Cal. Offset To achieve the permanent calibration after setting the values, the subindex 2 to 4 must be storable in NVM. The Number of Entries is a constant, which is read-only for the CAN network and conforms to the standard way of defining subindex 0 of an array. The key to get the wanted functionality is the entry at subindex 1. This object entry accepts write access of a calibration key value. With the correct key, this operation enables the write access to the other calibration object entries from subindex 2 to 4. A wrong key disables the write access. Implement Object Type # Lets implement the calibration user type as shown in the CANopen Usage: User Object : uint8_t calWriteAllowed = 0u ; const CO_OBJ_TYPE COTCal = { 0 , 0 , 0 , CalWrite }; #define CO_TCAL ((CO_OBJ_TYPE*)&COTCal) The write function is called when the CAN network writes to the related object entry via SDO request. We typically send an error, because the calibration data is read-only per default: int16_t CalWrite ( CO_OBJ * obj , struct CO_NODE_T * node , void * buf , uint32_t size ) { /* indicate an write error */ return CO_ERR_TYPE_WR ; } Now we want to change this function to enable the write access for the calibration values after a secret key-value is written to the object entry at subindex 1. #define CAL_KEY 0x1f3c7a3b /* a random value for enabling write access */ int16_t CalWrite ( CO_OBJ * obj , struct CO_NODE_T * node , void * buf , uint32_t size ) { uint32_t value = * (( uint32_t * ) buf ); CO_ERR result = CO_ERR_TYPE_WR ; uint8_t subidx = CO_GET_SUB ( obj -> Key ); if ( subidx == 1u ) { if ( value == CAL_KEY ) { calWriteAllowed = 1u ; } else { calWriteAllowed = 0u ; } result = 0u ; } else { if (( subidx != 0u ) && ( calWriteAllowed == 1u )) { * ( int32_t * ) obj -> Data = value ; result = 0u ; } } return result ; } Implement Object Entries # Parameter Handling # First, we need to get a memory area for our calibration data. We get this area by creating a structure with the calibration data values: struct CAL_MEM_T { int32_t Factor ; int32_t Divisor ; int32_t Offset ; }; struct CAL_MEM_T CalDefaults = { ( int32_t ) 1u , /* factor */ ( int32_t ) 1u , /* divisor */ ( int32_t ) 0u /* offset */ }; struct CAL_MEM_T CalValue ; For store and restore operations, the parameter group control structure specifies the memory area and the reset type of these parameters: const CO_PARA CalParaObj = { 0L , /* placement in non-volatile memory */ sizeof ( struct CAL_MEM_T ), /* size of parameter memory */ ( uint8_t * ) & CalValue , /* start address of parameter mem */ ( uint8_t * ) & CalDefaults , /* start address of default para. */ CO_RESET_NODE , /* reset type for reload parameter */ ( void * ) \"Calibration\" , /* user parameter identification */ CO_PARA___E /* enable parameter storage on cmd */ }; Finally, in the standard parameter store/restore entries, we use a separate subindex for the calibration values (for example: subindex #2): const CO_OBJ ExampleObjDir [] = { : { CO_KEY ( 0x1010 , 2 , CO_OBJ_____RW ), CO_TPARA_STORE , ( CO_DATA )( & CalParaObj ) }, : }; Calibration Object Entry # We use our user type to define the calibration object entry: const CO_OBJ ExampleObjDir [] = { : { CO_KEY ( 0x2F00 , 0 , CO_OBJ_D___RW ), CO_TUNSIGNED8 , ( CO_DATA )( 4u ) }, { CO_KEY ( 0x2F00 , 1 , CO_OBJ_D____W ), CO_TCAL , ( CO_DATA )( 0u ) }, { CO_KEY ( 0x2F00 , 2 , CO_OBJ_____RW ), CO_TCAL , ( CO_DATA )( & CalValue . Factor ) }, { CO_KEY ( 0x2F00 , 3 , CO_OBJ_____RW ), CO_TCAL , ( CO_DATA )( & CalValue . Divisor ) }, { CO_KEY ( 0x2F00 , 4 , CO_OBJ_____RW ), CO_TCAL , ( CO_DATA )( & CalValue . Offset ) }, : }; Well, that's it. Now we have an (unsecured) protected calibration area for manufacturer-specific data. This concept is a starting point for more secure solutions with advanced algorithms.","title":"Calibration Mode"},{"location":"examples/setup-calibration-mode/#setup-calibration-mode","text":"When dealing with analog values, there is often a calibration of the hardware required to achieve the best accuracy. This example situation is a good reason for implementing a manufacturer-specific factory area.","title":"Setup calibration mode"},{"location":"examples/setup-calibration-mode/#example-goal","text":"The example focus is the user object for CAN triggered write access to a manufacturer-specific area.","title":"Example Goal"},{"location":"examples/setup-calibration-mode/#object-type-idea","text":"The main idea is a collection of object entries, which are writable after a simple identification mechanism. For a tiny use-case we assume to achieve a simple calibration mechanism. The application uses the calibration values to transform input values with a formula: adcValue = ( adcRaw * calFactor ) / calDivisor + calOffset ;","title":"Object Type Idea"},{"location":"examples/setup-calibration-mode/#object-entry-definitions","text":"We define some manufacturer specific entries in the object dictionary: Index Subindex Type Access Value Description 2F00h 0 UNSIGNED32 Const 4 Max. Subindex 2F00h 1 UNSIGNED32 Write Only 0 Calibration Key 2F00h 2 SIGNED32 Read Write 1 Cal. Factor 2F09h 3 SIGNED32 Read Write 1 Cal. Divisor 2F00h 4 SIGNED32 Read Write 0 Cal. Offset To achieve the permanent calibration after setting the values, the subindex 2 to 4 must be storable in NVM. The Number of Entries is a constant, which is read-only for the CAN network and conforms to the standard way of defining subindex 0 of an array. The key to get the wanted functionality is the entry at subindex 1. This object entry accepts write access of a calibration key value. With the correct key, this operation enables the write access to the other calibration object entries from subindex 2 to 4. A wrong key disables the write access.","title":"Object Entry Definitions"},{"location":"examples/setup-calibration-mode/#implement-object-type","text":"Lets implement the calibration user type as shown in the CANopen Usage: User Object : uint8_t calWriteAllowed = 0u ; const CO_OBJ_TYPE COTCal = { 0 , 0 , 0 , CalWrite }; #define CO_TCAL ((CO_OBJ_TYPE*)&COTCal) The write function is called when the CAN network writes to the related object entry via SDO request. We typically send an error, because the calibration data is read-only per default: int16_t CalWrite ( CO_OBJ * obj , struct CO_NODE_T * node , void * buf , uint32_t size ) { /* indicate an write error */ return CO_ERR_TYPE_WR ; } Now we want to change this function to enable the write access for the calibration values after a secret key-value is written to the object entry at subindex 1. #define CAL_KEY 0x1f3c7a3b /* a random value for enabling write access */ int16_t CalWrite ( CO_OBJ * obj , struct CO_NODE_T * node , void * buf , uint32_t size ) { uint32_t value = * (( uint32_t * ) buf ); CO_ERR result = CO_ERR_TYPE_WR ; uint8_t subidx = CO_GET_SUB ( obj -> Key ); if ( subidx == 1u ) { if ( value == CAL_KEY ) { calWriteAllowed = 1u ; } else { calWriteAllowed = 0u ; } result = 0u ; } else { if (( subidx != 0u ) && ( calWriteAllowed == 1u )) { * ( int32_t * ) obj -> Data = value ; result = 0u ; } } return result ; }","title":"Implement Object Type"},{"location":"examples/setup-calibration-mode/#implement-object-entries","text":"","title":"Implement Object Entries"},{"location":"examples/setup-calibration-mode/#parameter-handling","text":"First, we need to get a memory area for our calibration data. We get this area by creating a structure with the calibration data values: struct CAL_MEM_T { int32_t Factor ; int32_t Divisor ; int32_t Offset ; }; struct CAL_MEM_T CalDefaults = { ( int32_t ) 1u , /* factor */ ( int32_t ) 1u , /* divisor */ ( int32_t ) 0u /* offset */ }; struct CAL_MEM_T CalValue ; For store and restore operations, the parameter group control structure specifies the memory area and the reset type of these parameters: const CO_PARA CalParaObj = { 0L , /* placement in non-volatile memory */ sizeof ( struct CAL_MEM_T ), /* size of parameter memory */ ( uint8_t * ) & CalValue , /* start address of parameter mem */ ( uint8_t * ) & CalDefaults , /* start address of default para. */ CO_RESET_NODE , /* reset type for reload parameter */ ( void * ) \"Calibration\" , /* user parameter identification */ CO_PARA___E /* enable parameter storage on cmd */ }; Finally, in the standard parameter store/restore entries, we use a separate subindex for the calibration values (for example: subindex #2): const CO_OBJ ExampleObjDir [] = { : { CO_KEY ( 0x1010 , 2 , CO_OBJ_____RW ), CO_TPARA_STORE , ( CO_DATA )( & CalParaObj ) }, : };","title":"Parameter Handling"},{"location":"examples/setup-calibration-mode/#calibration-object-entry","text":"We use our user type to define the calibration object entry: const CO_OBJ ExampleObjDir [] = { : { CO_KEY ( 0x2F00 , 0 , CO_OBJ_D___RW ), CO_TUNSIGNED8 , ( CO_DATA )( 4u ) }, { CO_KEY ( 0x2F00 , 1 , CO_OBJ_D____W ), CO_TCAL , ( CO_DATA )( 0u ) }, { CO_KEY ( 0x2F00 , 2 , CO_OBJ_____RW ), CO_TCAL , ( CO_DATA )( & CalValue . Factor ) }, { CO_KEY ( 0x2F00 , 3 , CO_OBJ_____RW ), CO_TCAL , ( CO_DATA )( & CalValue . Divisor ) }, { CO_KEY ( 0x2F00 , 4 , CO_OBJ_____RW ), CO_TCAL , ( CO_DATA )( & CalValue . Offset ) }, : }; Well, that's it. Now we have an (unsecured) protected calibration area for manufacturer-specific data. This concept is a starting point for more secure solutions with advanced algorithms.","title":"Calibration Object Entry"},{"location":"examples/setup-dynamic-object-dictionary/","text":"Dynamic Object Dictionary - Part I # Projects using CANopen may need to realize an adaptive CANopen Object Dictionary. For example, the CANopen device acts as a standard IO-Device or as a proprietary device - depending on external system settings. In this example, we will discover the needed steps to get a fully dynamic CANopen Object Dictionary for our CANopen Stack. Functional Specification # This example is the first of two writings to achieve a flexible and comfortable way of managing CANopen device software with dynamically generated object dictionaries during runtime. The first part describes tool functions for managing the object directory, while the second part illustrates the usage of the introduced tool functions. Resource Estimation # The CANopen stack is optimized for minimal resource requirements. The default examples and descriptions assume that you want to minimize the usage of RAM. For this reason, the manuals and templates declare the object dictionary storage as a const array which is placed into FLASH memory. For an estimation of how big the difference is, we have a quick look into the manual. The manual explains that each object dictionary entry needs 3 x 32bit values. Therefore, at an object dictionary with 256 object entries, we talk about: 256 * 12 Byte = 3 kByte In case of a static object dictionary, the CANopen stack stores the entire dictionary (including pointers to the changing data) in non-volatile memory. On the dynamic side, the CANopen stack stores the object dictionary in RAM, along with the changing data. The use of pointers to the changing data is optional. Note, the term \" dynamic \" means that we can create and change an object entry within the object dictionary during runtime up to a defined amount of object entries. The allocation of the required memory is still \" static \" - we don't need (and want) to use dynamic memory allocation in embedded systems with all the well-known drawbacks. Finally: We can improve the flexibility of our CANopen application software when working with a dynamic object dictionary. Module: app_dict # The object dictionary is an array of object entries. We must store the object entries ascending by the index/sub-index information. This requirement ensures that the CANopen stack can perform fast and efficient access to a specific entry. Object Definition # Let's start with introducing a new module, called app_dict (application dictionary). This module is responsible for the object directory management. First, we define a structure for holding the variable data of the dynamic object directory: typedef struct { CO_OBJ * Root ; uint32_t Length ; uint32_t Used ; } OD_DYN ; The member Root will hold the start address of the object dictionary. The member Length stores the maximal number of object entries in the object dictionary, and the member Used will hold the current number of used object entries. Local Helper # Some small local functions will help us to get the following implementations of the object dictionary management functions as readable as possible. The service ObjSet() allows us to set the values of a single object entry to the given values. static void ObjSet ( CO_OBJ * obj , uint32_t key , const CO_OBJ_TYPE * type , CO_DATA data ) { obj -> Key = key ; obj -> Type = type ; obj -> Data = data ; } The service ObjCpy() will copy all values from the second given object entry to the first given object entry. static void ObjCpy ( CO_OBJ * a , CO_OBJ * b ) { a -> Key = b -> Key ; a -> Type = b -> Type ; a -> Data = b -> Data ; } The service ObjSwap() will exchange the content of the given object entries. static void ObjSwap ( CO_OBJ * a , CO_OBJ * b ) { CO_OBJ x ; ObjCpy ( & x , a ); ObjCpy ( a , b ); ObjCpy ( b , & x ); } The service ObjCmp() will compare the index and subindex information and return the result of the comparison similar to strcmp() static int16_t ObjCmp ( CO_OBJ * a , CO_OBJ * b ) { int16_t result = 1 ; if ( CO_GET_DEV ( a -> Key ) == CO_GET_DEV ( b -> Key )) { result = 0 ; } else if ( CO_GET_DEV ( a -> Key ) < CO_GET_DEV ( b -> Key )) { result = -1 ; } return ( result ); } Initialization Function # When starting the CANopen node, we have to specify the object dictionary as an argument for this node. The next service function will provide us a clean and empty object dictionary. void ODInit ( OD_DYN * self , CO_OBJ * root , uint32_t length ) { uint32_t idx ; CO_OBJ end = CO_OBJ_DICT_ENDMARK ; CO_OBJ * od ; idx = 0 ; od = root ; while ( idx < length ) { ObjCpy ( od , & end ); od ++ ; idx ++ ; } self -> Root = root ; self -> Length = length - 1 ; self -> Used = 0 ; } Note the marked line for setting the maximal number of object entries. The CANopen stack requires a CO_OBJ_DICT_ENDMARK at the end of the used object dictionary area. For this reason, we reduce the maximal number of (user) object entries by 1. Add & Update Function # The function for adding a new object entry needs three arguments besides the object handle reference self : First argument is the key which includes the information of index, subindex, type and some additional flags to a single 32bit value. We should create this value with the macro CO_KEY(..). The second argument, type is a reference to a structure of type-functions. The last argument data holds the data of this object entry. The interpretation of this data depends on the flags in the argument key . We have a look at this relationship later in the examples. void ODAddUpdate ( OD_DYN * self , uint32_t key , const CO_OBJ_TYPE * type , CO_DATA data ) { CO_OBJ temp ; CO_OBJ * od ; if (( key == 0 ) || ( self -> Used == self -> Length )) { return ; } od = self -> Root ; ObjSet ( & temp , key , type , data ); /* find position in dictionary */ while (( od -> Key != 0 ) && ( ObjCmp ( od , & temp ) < 0 )) { od ++ ; } if ( ObjCmp ( od , & temp ) == 0 ) { /* Change existing entry */ ObjSet ( od , key , type , data ); } else if ( od -> Key == 0 ) { /* Append at end of dictionary */ ObjSet ( od , key , type , data ); self -> Used ++ ; } else { /* Insert in middle of dictionary */ do { ObjSwap ( od , & temp ); od ++ ; } while ( od -> Key != 0 ); ObjCpy ( od , & temp ); self -> Used ++ ; } } The generation of the object dictionary executes during the initialization phase of the CANopen node. Therefore the performance is not the most critical part. Nevertheless, we want to have an algorithm, which is linear ( O(n) ) when raising the number of object entries. In principle, we want to walk through the (sorted) list one time and insert the new object entry in the right position. All used object entries behind the insert position must be shifted by one place to the end. Conclusion # That's it. Now we have a set of functions for managing the object dictionary. This set includes services for: Object Handling (Set, Copy, Swap Compare) Object Dictionary Handling (Init, Add & Update) We are now ready to go for using these functions in the next example: Dynamic Object Dictionary - Part II .","title":"Dynamic Dictionary I"},{"location":"examples/setup-dynamic-object-dictionary/#dynamic-object-dictionary-part-i","text":"Projects using CANopen may need to realize an adaptive CANopen Object Dictionary. For example, the CANopen device acts as a standard IO-Device or as a proprietary device - depending on external system settings. In this example, we will discover the needed steps to get a fully dynamic CANopen Object Dictionary for our CANopen Stack.","title":"Dynamic Object Dictionary - Part I"},{"location":"examples/setup-dynamic-object-dictionary/#functional-specification","text":"This example is the first of two writings to achieve a flexible and comfortable way of managing CANopen device software with dynamically generated object dictionaries during runtime. The first part describes tool functions for managing the object directory, while the second part illustrates the usage of the introduced tool functions.","title":"Functional Specification"},{"location":"examples/setup-dynamic-object-dictionary/#resource-estimation","text":"The CANopen stack is optimized for minimal resource requirements. The default examples and descriptions assume that you want to minimize the usage of RAM. For this reason, the manuals and templates declare the object dictionary storage as a const array which is placed into FLASH memory. For an estimation of how big the difference is, we have a quick look into the manual. The manual explains that each object dictionary entry needs 3 x 32bit values. Therefore, at an object dictionary with 256 object entries, we talk about: 256 * 12 Byte = 3 kByte In case of a static object dictionary, the CANopen stack stores the entire dictionary (including pointers to the changing data) in non-volatile memory. On the dynamic side, the CANopen stack stores the object dictionary in RAM, along with the changing data. The use of pointers to the changing data is optional. Note, the term \" dynamic \" means that we can create and change an object entry within the object dictionary during runtime up to a defined amount of object entries. The allocation of the required memory is still \" static \" - we don't need (and want) to use dynamic memory allocation in embedded systems with all the well-known drawbacks. Finally: We can improve the flexibility of our CANopen application software when working with a dynamic object dictionary.","title":"Resource Estimation"},{"location":"examples/setup-dynamic-object-dictionary/#module-app_dict","text":"The object dictionary is an array of object entries. We must store the object entries ascending by the index/sub-index information. This requirement ensures that the CANopen stack can perform fast and efficient access to a specific entry.","title":"Module: app_dict"},{"location":"examples/setup-dynamic-object-dictionary/#object-definition","text":"Let's start with introducing a new module, called app_dict (application dictionary). This module is responsible for the object directory management. First, we define a structure for holding the variable data of the dynamic object directory: typedef struct { CO_OBJ * Root ; uint32_t Length ; uint32_t Used ; } OD_DYN ; The member Root will hold the start address of the object dictionary. The member Length stores the maximal number of object entries in the object dictionary, and the member Used will hold the current number of used object entries.","title":"Object Definition"},{"location":"examples/setup-dynamic-object-dictionary/#local-helper","text":"Some small local functions will help us to get the following implementations of the object dictionary management functions as readable as possible. The service ObjSet() allows us to set the values of a single object entry to the given values. static void ObjSet ( CO_OBJ * obj , uint32_t key , const CO_OBJ_TYPE * type , CO_DATA data ) { obj -> Key = key ; obj -> Type = type ; obj -> Data = data ; } The service ObjCpy() will copy all values from the second given object entry to the first given object entry. static void ObjCpy ( CO_OBJ * a , CO_OBJ * b ) { a -> Key = b -> Key ; a -> Type = b -> Type ; a -> Data = b -> Data ; } The service ObjSwap() will exchange the content of the given object entries. static void ObjSwap ( CO_OBJ * a , CO_OBJ * b ) { CO_OBJ x ; ObjCpy ( & x , a ); ObjCpy ( a , b ); ObjCpy ( b , & x ); } The service ObjCmp() will compare the index and subindex information and return the result of the comparison similar to strcmp() static int16_t ObjCmp ( CO_OBJ * a , CO_OBJ * b ) { int16_t result = 1 ; if ( CO_GET_DEV ( a -> Key ) == CO_GET_DEV ( b -> Key )) { result = 0 ; } else if ( CO_GET_DEV ( a -> Key ) < CO_GET_DEV ( b -> Key )) { result = -1 ; } return ( result ); }","title":"Local Helper"},{"location":"examples/setup-dynamic-object-dictionary/#initialization-function","text":"When starting the CANopen node, we have to specify the object dictionary as an argument for this node. The next service function will provide us a clean and empty object dictionary. void ODInit ( OD_DYN * self , CO_OBJ * root , uint32_t length ) { uint32_t idx ; CO_OBJ end = CO_OBJ_DICT_ENDMARK ; CO_OBJ * od ; idx = 0 ; od = root ; while ( idx < length ) { ObjCpy ( od , & end ); od ++ ; idx ++ ; } self -> Root = root ; self -> Length = length - 1 ; self -> Used = 0 ; } Note the marked line for setting the maximal number of object entries. The CANopen stack requires a CO_OBJ_DICT_ENDMARK at the end of the used object dictionary area. For this reason, we reduce the maximal number of (user) object entries by 1.","title":"Initialization Function"},{"location":"examples/setup-dynamic-object-dictionary/#add-update-function","text":"The function for adding a new object entry needs three arguments besides the object handle reference self : First argument is the key which includes the information of index, subindex, type and some additional flags to a single 32bit value. We should create this value with the macro CO_KEY(..). The second argument, type is a reference to a structure of type-functions. The last argument data holds the data of this object entry. The interpretation of this data depends on the flags in the argument key . We have a look at this relationship later in the examples. void ODAddUpdate ( OD_DYN * self , uint32_t key , const CO_OBJ_TYPE * type , CO_DATA data ) { CO_OBJ temp ; CO_OBJ * od ; if (( key == 0 ) || ( self -> Used == self -> Length )) { return ; } od = self -> Root ; ObjSet ( & temp , key , type , data ); /* find position in dictionary */ while (( od -> Key != 0 ) && ( ObjCmp ( od , & temp ) < 0 )) { od ++ ; } if ( ObjCmp ( od , & temp ) == 0 ) { /* Change existing entry */ ObjSet ( od , key , type , data ); } else if ( od -> Key == 0 ) { /* Append at end of dictionary */ ObjSet ( od , key , type , data ); self -> Used ++ ; } else { /* Insert in middle of dictionary */ do { ObjSwap ( od , & temp ); od ++ ; } while ( od -> Key != 0 ); ObjCpy ( od , & temp ); self -> Used ++ ; } } The generation of the object dictionary executes during the initialization phase of the CANopen node. Therefore the performance is not the most critical part. Nevertheless, we want to have an algorithm, which is linear ( O(n) ) when raising the number of object entries. In principle, we want to walk through the (sorted) list one time and insert the new object entry in the right position. All used object entries behind the insert position must be shifted by one place to the end.","title":"Add &amp; Update Function"},{"location":"examples/setup-dynamic-object-dictionary/#conclusion","text":"That's it. Now we have a set of functions for managing the object dictionary. This set includes services for: Object Handling (Set, Copy, Swap Compare) Object Dictionary Handling (Init, Add & Update) We are now ready to go for using these functions in the next example: Dynamic Object Dictionary - Part II .","title":"Conclusion"},{"location":"examples/usage-with-rtos-and-baremetal/","text":"RTOS and Baremetal # This example describes the usage and differences when using the CANopen Stack with an RTOS or within a foreground / background system. The overall architecture of a CANopen device is standardized and shown in the following figure: In this example, only the high-level usage within the component Your Application is addressed. We focus the description in the examples to the startup, event service, and CANopen stack processing API functions: Function Name Description CONodeInit() Initialization of CANopen stack CONodeStart() Start of CANopen stack CONodeProcess() Processing of CAN communication COTmrService() Trigger elapsed configured time quanta COTmrProcess() Processing of timed actions CANopen Baremetal # When using the CANopen stack in a foreground / background system, we establish a timer interrupt for triggering the elapsed time quantum and the CAN receive interrupt. The following figure shows an overview of the application: The figure shows the hardware components which drives the CANopen stack operation. The CAN Controller is the interface to the CAN network. The Hardware Timer is the time base for all timed actions of the CANopen stack. Both hardware components are generating asynchronous events. We handle these events with the interrupt service routines (ISR) CAN Receive ISR and Cyclic Timer ISR . The processing of the collected events is checked and processed in the main loop controls Node Processing and Timer Processing . The Node Processing is responsible for all CAN communication requests. The Time Processing is responsible for all timed actions. CANopen Node Startup # The following source shows the global variables and the initialization and startup of the CANopen device node. The external variable AppSpec is a part of the CANopen configuration, see quickstart for details. The global variable MyNode represents the CANopen node itself. /* get external node specification */ extern const CO_NODE_SPEC AppSpec ; /* Allocate a global CANopen node object */ CO_NODE MyNode ; The main() function is responsible for the initialization and startup activities for the CANopen device. void main ( int argc , char * argv []) { /* Initialization of Hardware: * - Setup cyclic timer interrupt source * - Setup CAN bus operation */ /* Startup of CANopen stack */ CONodeInit ( & MyNode , ( CO_NODE_SPEC * ) & AppSpec ); CONodeStart ( & MyNode ); /* The background loop */ FOREVER { : } } CAN Receive ISR # The following function handles the CAN receive interrupt. void App_CanRxIsrHandler ( void ) { CONodeProcess ( & MyNode ); } Cyclic Timer ISR # The following source lines handles the cyclic timer interrupt. void App_TmrIsrHandler ( void ) { /* Hardware timer handling (e.g. interrupt acknowledge) */ COTmrService ( & ( MyNode . Tmr )); } Background Loop # The following source lines shows the background loop function calls. void main ( int argc , char * argv []) { : /* The background loop */ FOREVER { COTmrProcess ( & ( MyNode . Tmr )); : /* other application functions */ : } } CANopen with RTOS # When using the CANopen stack with an RTOS, we establish a timer interrupt for triggering the elapsed time quantum and the CAN receive interrupt. The following figure shows an overview of the application: The figure shows the hardware components which drives the CANopen stack operation. The CAN controller is the interface to the CAN network. The Hardware Timer is the time base for all timed actions. Within your RTOS, there is most likely a callback function which you can use as time service trigger. Both hardware components are producing asynchronous events. We collect these events by the interrupt service routines (ISR) CAN Receive ISR and Cyclic Timer ISR . For the processing of the events we use two separate tasks for Node Processing and Timer Processing . The Node Processing is responsible for all CAN communication requests. The Time Processing is responsible for all timed actions. RTOS Startup # Let's have a look in the implementation for the Flexible Safety RTOS . There is no limitation to this RTOS; you can use any RTOS you already have or want. The following source shows the global variables and the initialization and startup of the CANopen device node. The external variable AppSpec is a part of the CANopen configuration, see quickstart for details. The global variable MyNode represents the CANopen node itself. /* get external node specification */ extern const CO_NODE_SPEC AppSpec ; /* Allocate CANopen node object */ CO_NODE MyNode ; /* Allocate RTOS semaphores */ OS_EVENT * AppCanSem ; OS_EVENT * AppTmrSem ; The main() function is responsible for the initialization and startup activities for the Flexible Safety RTOS. void main ( int argc , char * argv []) { /* Initialize and start CANopen stack */ CONodeInit ( & MyNode , ( CO_NODE_SPEC * ) & AppSpec ); CONodeStart ( & MyNode ); /* Initialize and start real time kernel */ OSInit (); OSTaskCreate ( AppStart , ... ); OSStart (); } CANopen Node Startup # The first created application task AppStart is responsible for the initialization of the peripherals and the creation of the operational application tasks. At the end this task deletes itself. void AppStart ( void * arg ) { /* Initialization of Hardware: * - setup cyclic OS tick timer * - Setup CAN bus operation */ /* Create RTOS semaphores */ AppTmrSem = OSSemCreate ( 0 ); AppCanSem = OSSemCreate ( 0 ); /* Create CANopen tasks */ OSTaskCreate ( AppTmrTask , ... ); OSTaskCreate ( AppRxTask , ... ); : /* Create other application tasks */ : OSTaskDel ( OS_PRIO_SELF ); } CAN Receive ISR # The following function handles the CAN receive interrupt. void App_CanRxIsrHandler ( void ) { /* Signal the received CAN frame */ OSSemPost ( AppTmrSem ); } Cyclic Timer ISR # The following source lines handles the cyclic timer event within the OS specific time tick hook function (a function which is called every OS time tick). void App_TimeTickHook ( void ) { int16_t num ; num = COTmrService ( & ( MyNode . Tmr )); while ( num > 0 ) { /* Signal all elapsed timer actions */ OSSemPost ( AppTmrSem ); num -- ; } } Rx Task # The following source lines shows the CAN receive task. This task is waiting with the counting semaphore AppCanSem for received CAN messages. void AppCanTask ( void * arg ) { FOREVER { OSSemPend ( AppCanSem , ...); CONodeProcess ( & MyNode ); } } Timer Task # The following source lines shows the timer task. This task is waiting with the counting semaphore AppTmrSem for elapsed timer actions. void AppTmrTask ( void * arg ) { FOREVER { OSSemPend ( AppTmrSem , ...); COTmrProcess ( & ( MyNode -> Tmr )); } }","title":"RTOS and Baremetal"},{"location":"examples/usage-with-rtos-and-baremetal/#rtos-and-baremetal","text":"This example describes the usage and differences when using the CANopen Stack with an RTOS or within a foreground / background system. The overall architecture of a CANopen device is standardized and shown in the following figure: In this example, only the high-level usage within the component Your Application is addressed. We focus the description in the examples to the startup, event service, and CANopen stack processing API functions: Function Name Description CONodeInit() Initialization of CANopen stack CONodeStart() Start of CANopen stack CONodeProcess() Processing of CAN communication COTmrService() Trigger elapsed configured time quanta COTmrProcess() Processing of timed actions","title":"RTOS and Baremetal"},{"location":"examples/usage-with-rtos-and-baremetal/#canopen-baremetal","text":"When using the CANopen stack in a foreground / background system, we establish a timer interrupt for triggering the elapsed time quantum and the CAN receive interrupt. The following figure shows an overview of the application: The figure shows the hardware components which drives the CANopen stack operation. The CAN Controller is the interface to the CAN network. The Hardware Timer is the time base for all timed actions of the CANopen stack. Both hardware components are generating asynchronous events. We handle these events with the interrupt service routines (ISR) CAN Receive ISR and Cyclic Timer ISR . The processing of the collected events is checked and processed in the main loop controls Node Processing and Timer Processing . The Node Processing is responsible for all CAN communication requests. The Time Processing is responsible for all timed actions.","title":"CANopen Baremetal"},{"location":"examples/usage-with-rtos-and-baremetal/#canopen-node-startup","text":"The following source shows the global variables and the initialization and startup of the CANopen device node. The external variable AppSpec is a part of the CANopen configuration, see quickstart for details. The global variable MyNode represents the CANopen node itself. /* get external node specification */ extern const CO_NODE_SPEC AppSpec ; /* Allocate a global CANopen node object */ CO_NODE MyNode ; The main() function is responsible for the initialization and startup activities for the CANopen device. void main ( int argc , char * argv []) { /* Initialization of Hardware: * - Setup cyclic timer interrupt source * - Setup CAN bus operation */ /* Startup of CANopen stack */ CONodeInit ( & MyNode , ( CO_NODE_SPEC * ) & AppSpec ); CONodeStart ( & MyNode ); /* The background loop */ FOREVER { : } }","title":"CANopen Node Startup"},{"location":"examples/usage-with-rtos-and-baremetal/#can-receive-isr","text":"The following function handles the CAN receive interrupt. void App_CanRxIsrHandler ( void ) { CONodeProcess ( & MyNode ); }","title":"CAN Receive ISR"},{"location":"examples/usage-with-rtos-and-baremetal/#cyclic-timer-isr","text":"The following source lines handles the cyclic timer interrupt. void App_TmrIsrHandler ( void ) { /* Hardware timer handling (e.g. interrupt acknowledge) */ COTmrService ( & ( MyNode . Tmr )); }","title":"Cyclic Timer ISR"},{"location":"examples/usage-with-rtos-and-baremetal/#background-loop","text":"The following source lines shows the background loop function calls. void main ( int argc , char * argv []) { : /* The background loop */ FOREVER { COTmrProcess ( & ( MyNode . Tmr )); : /* other application functions */ : } }","title":"Background Loop"},{"location":"examples/usage-with-rtos-and-baremetal/#canopen-with-rtos","text":"When using the CANopen stack with an RTOS, we establish a timer interrupt for triggering the elapsed time quantum and the CAN receive interrupt. The following figure shows an overview of the application: The figure shows the hardware components which drives the CANopen stack operation. The CAN controller is the interface to the CAN network. The Hardware Timer is the time base for all timed actions. Within your RTOS, there is most likely a callback function which you can use as time service trigger. Both hardware components are producing asynchronous events. We collect these events by the interrupt service routines (ISR) CAN Receive ISR and Cyclic Timer ISR . For the processing of the events we use two separate tasks for Node Processing and Timer Processing . The Node Processing is responsible for all CAN communication requests. The Time Processing is responsible for all timed actions.","title":"CANopen with RTOS"},{"location":"examples/usage-with-rtos-and-baremetal/#rtos-startup","text":"Let's have a look in the implementation for the Flexible Safety RTOS . There is no limitation to this RTOS; you can use any RTOS you already have or want. The following source shows the global variables and the initialization and startup of the CANopen device node. The external variable AppSpec is a part of the CANopen configuration, see quickstart for details. The global variable MyNode represents the CANopen node itself. /* get external node specification */ extern const CO_NODE_SPEC AppSpec ; /* Allocate CANopen node object */ CO_NODE MyNode ; /* Allocate RTOS semaphores */ OS_EVENT * AppCanSem ; OS_EVENT * AppTmrSem ; The main() function is responsible for the initialization and startup activities for the Flexible Safety RTOS. void main ( int argc , char * argv []) { /* Initialize and start CANopen stack */ CONodeInit ( & MyNode , ( CO_NODE_SPEC * ) & AppSpec ); CONodeStart ( & MyNode ); /* Initialize and start real time kernel */ OSInit (); OSTaskCreate ( AppStart , ... ); OSStart (); }","title":"RTOS Startup"},{"location":"examples/usage-with-rtos-and-baremetal/#canopen-node-startup_1","text":"The first created application task AppStart is responsible for the initialization of the peripherals and the creation of the operational application tasks. At the end this task deletes itself. void AppStart ( void * arg ) { /* Initialization of Hardware: * - setup cyclic OS tick timer * - Setup CAN bus operation */ /* Create RTOS semaphores */ AppTmrSem = OSSemCreate ( 0 ); AppCanSem = OSSemCreate ( 0 ); /* Create CANopen tasks */ OSTaskCreate ( AppTmrTask , ... ); OSTaskCreate ( AppRxTask , ... ); : /* Create other application tasks */ : OSTaskDel ( OS_PRIO_SELF ); }","title":"CANopen Node Startup"},{"location":"examples/usage-with-rtos-and-baremetal/#can-receive-isr_1","text":"The following function handles the CAN receive interrupt. void App_CanRxIsrHandler ( void ) { /* Signal the received CAN frame */ OSSemPost ( AppTmrSem ); }","title":"CAN Receive ISR"},{"location":"examples/usage-with-rtos-and-baremetal/#cyclic-timer-isr_1","text":"The following source lines handles the cyclic timer event within the OS specific time tick hook function (a function which is called every OS time tick). void App_TimeTickHook ( void ) { int16_t num ; num = COTmrService ( & ( MyNode . Tmr )); while ( num > 0 ) { /* Signal all elapsed timer actions */ OSSemPost ( AppTmrSem ); num -- ; } }","title":"Cyclic Timer ISR"},{"location":"examples/usage-with-rtos-and-baremetal/#rx-task","text":"The following source lines shows the CAN receive task. This task is waiting with the counting semaphore AppCanSem for received CAN messages. void AppCanTask ( void * arg ) { FOREVER { OSSemPend ( AppCanSem , ...); CONodeProcess ( & MyNode ); } }","title":"Rx Task"},{"location":"examples/usage-with-rtos-and-baremetal/#timer-task","text":"The following source lines shows the timer task. This task is waiting with the counting semaphore AppTmrSem for elapsed timer actions. void AppTmrTask ( void * arg ) { FOREVER { OSSemPend ( AppTmrSem , ...); COTmrProcess ( & ( MyNode -> Tmr )); } }","title":"Timer Task"},{"location":"examples/use-dynamic-object-dictionary/","text":"Dynamic Object Dictionary - Part II # In the first part of this example, we discover the needed activities to create and manage a dynamic CANopen Object Dictionary. With this example, we will have a look at using the dynamic CANopen Dictionary functions. We will see, how powerful these little functions are and how we can use them to get a dynamic Quickstart application. For details of the object entries, please have a look to the example Quickstart . Overview # We should have a short look into the Quickstart example as well. The following list summarizes the needed Object Directory entries. Object Entries, mandatory in CiA DS301: Device Type (Index 1000h) Error Register (Index 1001h) Heartbeat Time (Index 1017h) Identity Object (Index 1018h) SDO Server (Index 1200h) Object Entries, optional in CiA DS301 but needed by our demo: Transmit PDO Communication (Index 1800h) Transmit PDO Mapping (Index 1A00h) Manufacturer specific object entry for this demo: Clock Data (Index 2100h) Create Object Entries # First, we will take a look at all CiA DS301 object entries one by one. After getting these building blocks, we will combine them into a function, which creates our complete Object Directory. Device Type # The device type is a 32bit value, which identifies the CANopen device. Due to the fact, that our demo is not a real CANopen device, we store a constant 32bit dummy value (0x00000000) in this entry. ODAddUpdate ( self , CO_KEY ( 0x1000 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( 0x00000000 )); We choose the additional flags CO_OBJ_D___R_ to store the data directly ( D ) in the object entry and allow read access ( R ) from the communication interface. Error Register # The error register is an 8bit value, which holds the error register flags. The CANopen EMGY module manages the single error register flags. ODAddUpdate ( self , CO_KEY ( 0x1001 , 0 , CO_OBJ____PR_ ), CO_TUNSIGNED32 , ( CO_DATA )( & ErrReg )); For this entry, we choose the additional flags CO_OBJ____PR_ to store a pointer to the data in the object entry ( _ instead of D ), allow the PDO mapping ( P ) and allow read access ( R ) from the communication interface. Heartbeat Time # The heartbeat producer is a 16bit value, which holds the time in ms between two heartbeats. The entry is a system type, which injects the heartbeat callback functions into this entry. The callback functions are responsible for the system behavior when reading or writing this entry. ODAddUpdate ( self , CO_KEY ( 0x1017 , 0 , CO_OBJ_____RW ), CO_THB_PROD , ( CO_DATA )( & HbTime )); For the system type CO_THB_PROD we must choose the storage of a data pointer in the object directory ( _ instead of D ). To get a system, which conforms to CiA DS301, we disallow the PDO mapping ( _ instead of P ) and allow read ( R ) and write ( W ) access from the communication interface. Therefore we set the additional flags: CO_OBJ_____RW . Identity Object # The identity object is a structure of detailed node information. Due to the fact, that our demo is not a real CANopen device, we store a constant 32bit dummy value (0x00000000) in the mandatory entry at Sub-index 01h. ODAddUpdate ( self , CO_KEY ( 0x1018 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 0x01 )); ODAddUpdate ( self , CO_KEY ( 0x1018 , 1 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( 0x00000000 )); The subindex 00h holds the highest supported subindex in this index as a constant 8bit value. SDO Server Function # We encapsulate the SDO server communication object entry in a separate function. This function allows us to add multiple SDO servers with a smile. The subindex 01h is the COB-ID for the SDO request. The subindex 02h holds the COB-ID for the SDO response. Note: The CiA DS301 specifies for SDO server #0 the fixed COB-IDs: SDO request : COB-ID = 600h + NodeID SDO response : COB-ID = 580h + NodeID For all additional SDO servers (#1 .. #127) we can specify the COB-IDs. To get full flexibility and highest possible guidance by the function, we define the following function: static void ODCreateSDOServer ( OD_DYN * self , uint8_t srv , uint32_t request , uint32_t response ) { if ( srv == 0 ) { request = ( uint32_t ) 0x600 ; response = ( uint32_t ) 0x580 ; } ODAddUpdate ( self , CO_KEY ( 0x1200 + srv , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 0x02 )); ODAddUpdate ( self , CO_KEY ( 0x1200 + srv , 1 , CO_OBJ_DN__R_ ), CO_TUNSIGNED32 , ( CO_DATA )( request )); ODAddUpdate ( self , CO_KEY ( 0x1200 + srv , 2 , CO_OBJ_DN__R_ ), CO_TUNSIGNED32 , ( CO_DATA )( response )); } We choose the additional flags for the request and response identifiers to allow the storage of the identifiers independent of the used CANopen node ID. The node ID may change over time, and we don't want to update all depending object entries. Well, we can realize this by enabling the node ID flag N in the flags to remove the current node ID while writing and adding the current node ID while reading the object entry. TPDO Communication Function # Now we want to setup the transmit PDO (TPDO) communication object entry with a similar service function. This static PDO communication index array contains powerful settings. For details on the influence on the transmission behavior of every single subindex, please have a look into the CiA DS301 specification. static void ODCreateTPDOCom ( OD_DYN * self , uint8_t num , uint32_t id , uint8_t type , uint16_t inhibit , uint16_t evtimer ) { ODAddUpdate ( self , CO_KEY ( 0x1800 + num , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 0x05 )); ODAddUpdate ( self , CO_KEY ( 0x1800 + num , 1 , CO_OBJ_DN__R_ ), CO_TUNSIGNED32 , ( CO_DATA )( id )); ODAddUpdate ( self , CO_KEY ( 0x1800 + num , 2 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( type )); ODAddUpdate ( self , CO_KEY ( 0x1800 + num , 3 , CO_OBJ_D___RW ), CO_TUNSIGNED16 , ( CO_DATA )( inhibit )); ODAddUpdate ( self , CO_KEY ( 0x1800 + num , 5 , CO_OBJ_D___RW ), CO_TPDO_EVENT , ( CO_DATA )( evtimer )); } Note, that the subindex 04h is missing in this array. This gab is specified in the CiA DS301 for backward compatibility reasons. Furthermore, the subindex 00h states the highest accessible subindex (05h) and NOT the number of entries. This definition is a small pitfall when building this object entry. TPDO Mapping Function # The PDO mapping for the TPDOs needs an array with the mapping information as an argument to our service function. The mapping information is specified in CiA DS301 and is very similar to the key information of an object entry: Index : 16bit value (0000h to FFFFh) Subindex : 8bit value (0 to 255) Width : 8bit value with the number of bits (e.g., 8, 16 or 32) For building this mapping information, we can use the well known CO_KEY(..) macro where we use the 3 rd argument with the number of bits. static void ODCreateTPdoMap ( OD_DYN * self , uint8_t num , uint32_t * map , uint8_t len ) { uint8_t n ; ODAddUpdate ( self , CO_KEY ( 0x1A00 + num , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( len )); for ( n = 0 ; n < len ; n ++ ) { ODAddUpdate ( self , CO_KEY ( 0x1A00 + num , 1 + n , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( map [ n ])); } } This function will work correctly, but you can improve it with some guidance checks. The CANopen stack supports the number of bits 8, 16, and 32. Other values are not supported. Furthermore, the sum of all bits could be checked to be lower or equal to 64 bits. Create Directory Function # Now we are ready for building our dynamic object directory for the quickstart project smartly and efficiently: static uint8_t Obj1001_00_08 ; static uint32_t Obj2100_01_20 ; static uint8_t Obj2100_02_08 ; static uint8_t Obj2100_03_08 ; : static void ODCreateDict ( OD_DYN * self ) { uint32_t map [ 3 ]; Obj1001_00_08 = 0 ; ODAddUpdate ( self , CO_KEY ( 0x1000 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( 0x00000000 )); ODAddUpdate ( self , CO_KEY ( 0x1001 , 0 , CO_OBJ____PR_ ), CO_TUNSIGNED8 , ( CO_DATA )( & Obj1001_00_08 )); ODAddUpdate ( self , CO_KEY ( 0x1005 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( 0x80 )); ODAddUpdate ( self , CO_KEY ( 0x1017 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED16 , ( CO_DATA )( 0 )); ODAddUpdate ( self , CO_KEY ( 0x1018 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 4 )); ODAddUpdate ( self , CO_KEY ( 0x1018 , 1 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( 0 )); ODAddUpdate ( self , CO_KEY ( 0x1018 , 2 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( 0 )); ODAddUpdate ( self , CO_KEY ( 0x1018 , 3 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( 0 )); ODAddUpdate ( self , CO_KEY ( 0x1018 , 4 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( 0 )); ODCreateSDOServer ( self , 0 , CO_COBID_SDO_REQUEST (), CO_COBID_SDO_RESPONSE ()); ODCreateTPDOCom ( self , 0 , CO_COBID_TPDO_DEFAULT ( 0 ), 254 , 0 , 0 ); map [ 0 ] = CO_LINK ( 0x2100 , 1 , 32 ); map [ 1 ] = CO_LINK ( 0x2100 , 2 , 8 ); map [ 2 ] = CO_LINK ( 0x2100 , 3 , 8 ); ODCreateTPdoMap ( self , 0 , map , 3 ); ODAddUpdate ( self , CO_KEY ( 0x2100 , 0 , CO_OBJ_D___R_ ), CO_UNSIGNED8 , ( CO_DATA )( 3 )); ODAddUpdate ( self , CO_KEY ( 0x2100 , 1 , CO_OBJ____PR_ ), CO_UNSIGNED32 , ( CO_DATA )( & Obj2100_01_20 )); ODAddUpdate ( self , CO_KEY ( 0x2100 , 2 , CO_OBJ____PR_ ), CO_UNSIGNED8 , ( CO_DATA )( & Obj2100_02_08 )); ODAddUpdate ( self , CO_KEY ( 0x2100 , 3 , CO_OBJ___APR_ ), CO_UNSIGNED8 , ( CO_DATA )( & Obj2100_03_08 )); } Note, in the marked line we use the system type CO_TASYNC to specify the manufacturer specific trigger event \"on change\" for this object entry. This setting results in the transmission of any TPDO which holds a communication type 254 and a mapping entry for this signal, if the node is in operational mode. For our demo, this results in the transmission of the TPDO with the clock values every second. Starting the Node # For setup and starting a CANopen node, we can now integrate the functions to a startup sequence: #define APP_OBJ_N 128 : static OD_DYN DynDict ; static CO_OBJ ClockOD [ APP_OBJ_N ]; : struct CO_NODE_SPEC_T AppSpec = { APP_NODE_ID , /* default Node-Id */ APP_BAUDRATE , /* default Baudrate */ & ClockOD [ 0 ], /* pointer to object dictionary */ APP_OBJ_N , /* object dictionary max length */ & AppEmcyTbl [ 0 ], /* EMCY code & register bit table */ & TmrMem [ 0 ], /* pointer to timer memory blocks */ APP_TMR_N , /* number of timer memory blocks */ APP_TICKS_PER_SEC , /* timer clock frequency in Hz */ & AppDriver , /* select drivers for application */ & SdoSrvMem [ 0 ] /* SDO Transfer Buffer Memory */ }; : void ClkStartNode ( CO_NODE * node ) { /* Clear all entries in object dictionary */ ODInit ( & DynDict , & ClockOD [ 0 ], APP_OBJ_N ); /* Setup the object dictionary during runtime */ ODCreateDict ( & DynDict ); /* Create a node with generated object dictionary */ CONodeInit ( node , & AppSpec ); } This function will generate a (temporary) node specification, initializes our new dynamic object directory and initializes the CANopen node with this specification. To integrate this in the delivered quick start demo, the only line we must change is the initialization of the specified CANopen node: void main ( int argc , char * argv []) { : /* CONodeInit(&Clk, (CO_NODE_SPEC *)&AppSpec); OLD */ ClkStartNode ( & Clk ); /* NEW */ : } Well, that's it. Enjoy the new flexibility with our dynamic generated object directories.","title":"Dynamic Dictionary II"},{"location":"examples/use-dynamic-object-dictionary/#dynamic-object-dictionary-part-ii","text":"In the first part of this example, we discover the needed activities to create and manage a dynamic CANopen Object Dictionary. With this example, we will have a look at using the dynamic CANopen Dictionary functions. We will see, how powerful these little functions are and how we can use them to get a dynamic Quickstart application. For details of the object entries, please have a look to the example Quickstart .","title":"Dynamic Object Dictionary - Part II"},{"location":"examples/use-dynamic-object-dictionary/#overview","text":"We should have a short look into the Quickstart example as well. The following list summarizes the needed Object Directory entries. Object Entries, mandatory in CiA DS301: Device Type (Index 1000h) Error Register (Index 1001h) Heartbeat Time (Index 1017h) Identity Object (Index 1018h) SDO Server (Index 1200h) Object Entries, optional in CiA DS301 but needed by our demo: Transmit PDO Communication (Index 1800h) Transmit PDO Mapping (Index 1A00h) Manufacturer specific object entry for this demo: Clock Data (Index 2100h)","title":"Overview"},{"location":"examples/use-dynamic-object-dictionary/#create-object-entries","text":"First, we will take a look at all CiA DS301 object entries one by one. After getting these building blocks, we will combine them into a function, which creates our complete Object Directory.","title":"Create Object Entries"},{"location":"examples/use-dynamic-object-dictionary/#device-type","text":"The device type is a 32bit value, which identifies the CANopen device. Due to the fact, that our demo is not a real CANopen device, we store a constant 32bit dummy value (0x00000000) in this entry. ODAddUpdate ( self , CO_KEY ( 0x1000 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( 0x00000000 )); We choose the additional flags CO_OBJ_D___R_ to store the data directly ( D ) in the object entry and allow read access ( R ) from the communication interface.","title":"Device Type"},{"location":"examples/use-dynamic-object-dictionary/#error-register","text":"The error register is an 8bit value, which holds the error register flags. The CANopen EMGY module manages the single error register flags. ODAddUpdate ( self , CO_KEY ( 0x1001 , 0 , CO_OBJ____PR_ ), CO_TUNSIGNED32 , ( CO_DATA )( & ErrReg )); For this entry, we choose the additional flags CO_OBJ____PR_ to store a pointer to the data in the object entry ( _ instead of D ), allow the PDO mapping ( P ) and allow read access ( R ) from the communication interface.","title":"Error Register"},{"location":"examples/use-dynamic-object-dictionary/#heartbeat-time","text":"The heartbeat producer is a 16bit value, which holds the time in ms between two heartbeats. The entry is a system type, which injects the heartbeat callback functions into this entry. The callback functions are responsible for the system behavior when reading or writing this entry. ODAddUpdate ( self , CO_KEY ( 0x1017 , 0 , CO_OBJ_____RW ), CO_THB_PROD , ( CO_DATA )( & HbTime )); For the system type CO_THB_PROD we must choose the storage of a data pointer in the object directory ( _ instead of D ). To get a system, which conforms to CiA DS301, we disallow the PDO mapping ( _ instead of P ) and allow read ( R ) and write ( W ) access from the communication interface. Therefore we set the additional flags: CO_OBJ_____RW .","title":"Heartbeat Time"},{"location":"examples/use-dynamic-object-dictionary/#identity-object","text":"The identity object is a structure of detailed node information. Due to the fact, that our demo is not a real CANopen device, we store a constant 32bit dummy value (0x00000000) in the mandatory entry at Sub-index 01h. ODAddUpdate ( self , CO_KEY ( 0x1018 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 0x01 )); ODAddUpdate ( self , CO_KEY ( 0x1018 , 1 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( 0x00000000 )); The subindex 00h holds the highest supported subindex in this index as a constant 8bit value.","title":"Identity Object"},{"location":"examples/use-dynamic-object-dictionary/#sdo-server-function","text":"We encapsulate the SDO server communication object entry in a separate function. This function allows us to add multiple SDO servers with a smile. The subindex 01h is the COB-ID for the SDO request. The subindex 02h holds the COB-ID for the SDO response. Note: The CiA DS301 specifies for SDO server #0 the fixed COB-IDs: SDO request : COB-ID = 600h + NodeID SDO response : COB-ID = 580h + NodeID For all additional SDO servers (#1 .. #127) we can specify the COB-IDs. To get full flexibility and highest possible guidance by the function, we define the following function: static void ODCreateSDOServer ( OD_DYN * self , uint8_t srv , uint32_t request , uint32_t response ) { if ( srv == 0 ) { request = ( uint32_t ) 0x600 ; response = ( uint32_t ) 0x580 ; } ODAddUpdate ( self , CO_KEY ( 0x1200 + srv , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 0x02 )); ODAddUpdate ( self , CO_KEY ( 0x1200 + srv , 1 , CO_OBJ_DN__R_ ), CO_TUNSIGNED32 , ( CO_DATA )( request )); ODAddUpdate ( self , CO_KEY ( 0x1200 + srv , 2 , CO_OBJ_DN__R_ ), CO_TUNSIGNED32 , ( CO_DATA )( response )); } We choose the additional flags for the request and response identifiers to allow the storage of the identifiers independent of the used CANopen node ID. The node ID may change over time, and we don't want to update all depending object entries. Well, we can realize this by enabling the node ID flag N in the flags to remove the current node ID while writing and adding the current node ID while reading the object entry.","title":"SDO Server Function"},{"location":"examples/use-dynamic-object-dictionary/#tpdo-communication-function","text":"Now we want to setup the transmit PDO (TPDO) communication object entry with a similar service function. This static PDO communication index array contains powerful settings. For details on the influence on the transmission behavior of every single subindex, please have a look into the CiA DS301 specification. static void ODCreateTPDOCom ( OD_DYN * self , uint8_t num , uint32_t id , uint8_t type , uint16_t inhibit , uint16_t evtimer ) { ODAddUpdate ( self , CO_KEY ( 0x1800 + num , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 0x05 )); ODAddUpdate ( self , CO_KEY ( 0x1800 + num , 1 , CO_OBJ_DN__R_ ), CO_TUNSIGNED32 , ( CO_DATA )( id )); ODAddUpdate ( self , CO_KEY ( 0x1800 + num , 2 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( type )); ODAddUpdate ( self , CO_KEY ( 0x1800 + num , 3 , CO_OBJ_D___RW ), CO_TUNSIGNED16 , ( CO_DATA )( inhibit )); ODAddUpdate ( self , CO_KEY ( 0x1800 + num , 5 , CO_OBJ_D___RW ), CO_TPDO_EVENT , ( CO_DATA )( evtimer )); } Note, that the subindex 04h is missing in this array. This gab is specified in the CiA DS301 for backward compatibility reasons. Furthermore, the subindex 00h states the highest accessible subindex (05h) and NOT the number of entries. This definition is a small pitfall when building this object entry.","title":"TPDO Communication Function"},{"location":"examples/use-dynamic-object-dictionary/#tpdo-mapping-function","text":"The PDO mapping for the TPDOs needs an array with the mapping information as an argument to our service function. The mapping information is specified in CiA DS301 and is very similar to the key information of an object entry: Index : 16bit value (0000h to FFFFh) Subindex : 8bit value (0 to 255) Width : 8bit value with the number of bits (e.g., 8, 16 or 32) For building this mapping information, we can use the well known CO_KEY(..) macro where we use the 3 rd argument with the number of bits. static void ODCreateTPdoMap ( OD_DYN * self , uint8_t num , uint32_t * map , uint8_t len ) { uint8_t n ; ODAddUpdate ( self , CO_KEY ( 0x1A00 + num , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( len )); for ( n = 0 ; n < len ; n ++ ) { ODAddUpdate ( self , CO_KEY ( 0x1A00 + num , 1 + n , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( map [ n ])); } } This function will work correctly, but you can improve it with some guidance checks. The CANopen stack supports the number of bits 8, 16, and 32. Other values are not supported. Furthermore, the sum of all bits could be checked to be lower or equal to 64 bits.","title":"TPDO Mapping Function"},{"location":"examples/use-dynamic-object-dictionary/#create-directory-function","text":"Now we are ready for building our dynamic object directory for the quickstart project smartly and efficiently: static uint8_t Obj1001_00_08 ; static uint32_t Obj2100_01_20 ; static uint8_t Obj2100_02_08 ; static uint8_t Obj2100_03_08 ; : static void ODCreateDict ( OD_DYN * self ) { uint32_t map [ 3 ]; Obj1001_00_08 = 0 ; ODAddUpdate ( self , CO_KEY ( 0x1000 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( 0x00000000 )); ODAddUpdate ( self , CO_KEY ( 0x1001 , 0 , CO_OBJ____PR_ ), CO_TUNSIGNED8 , ( CO_DATA )( & Obj1001_00_08 )); ODAddUpdate ( self , CO_KEY ( 0x1005 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( 0x80 )); ODAddUpdate ( self , CO_KEY ( 0x1017 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED16 , ( CO_DATA )( 0 )); ODAddUpdate ( self , CO_KEY ( 0x1018 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 4 )); ODAddUpdate ( self , CO_KEY ( 0x1018 , 1 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( 0 )); ODAddUpdate ( self , CO_KEY ( 0x1018 , 2 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( 0 )); ODAddUpdate ( self , CO_KEY ( 0x1018 , 3 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( 0 )); ODAddUpdate ( self , CO_KEY ( 0x1018 , 4 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( 0 )); ODCreateSDOServer ( self , 0 , CO_COBID_SDO_REQUEST (), CO_COBID_SDO_RESPONSE ()); ODCreateTPDOCom ( self , 0 , CO_COBID_TPDO_DEFAULT ( 0 ), 254 , 0 , 0 ); map [ 0 ] = CO_LINK ( 0x2100 , 1 , 32 ); map [ 1 ] = CO_LINK ( 0x2100 , 2 , 8 ); map [ 2 ] = CO_LINK ( 0x2100 , 3 , 8 ); ODCreateTPdoMap ( self , 0 , map , 3 ); ODAddUpdate ( self , CO_KEY ( 0x2100 , 0 , CO_OBJ_D___R_ ), CO_UNSIGNED8 , ( CO_DATA )( 3 )); ODAddUpdate ( self , CO_KEY ( 0x2100 , 1 , CO_OBJ____PR_ ), CO_UNSIGNED32 , ( CO_DATA )( & Obj2100_01_20 )); ODAddUpdate ( self , CO_KEY ( 0x2100 , 2 , CO_OBJ____PR_ ), CO_UNSIGNED8 , ( CO_DATA )( & Obj2100_02_08 )); ODAddUpdate ( self , CO_KEY ( 0x2100 , 3 , CO_OBJ___APR_ ), CO_UNSIGNED8 , ( CO_DATA )( & Obj2100_03_08 )); } Note, in the marked line we use the system type CO_TASYNC to specify the manufacturer specific trigger event \"on change\" for this object entry. This setting results in the transmission of any TPDO which holds a communication type 254 and a mapping entry for this signal, if the node is in operational mode. For our demo, this results in the transmission of the TPDO with the clock values every second.","title":"Create Directory Function"},{"location":"examples/use-dynamic-object-dictionary/#starting-the-node","text":"For setup and starting a CANopen node, we can now integrate the functions to a startup sequence: #define APP_OBJ_N 128 : static OD_DYN DynDict ; static CO_OBJ ClockOD [ APP_OBJ_N ]; : struct CO_NODE_SPEC_T AppSpec = { APP_NODE_ID , /* default Node-Id */ APP_BAUDRATE , /* default Baudrate */ & ClockOD [ 0 ], /* pointer to object dictionary */ APP_OBJ_N , /* object dictionary max length */ & AppEmcyTbl [ 0 ], /* EMCY code & register bit table */ & TmrMem [ 0 ], /* pointer to timer memory blocks */ APP_TMR_N , /* number of timer memory blocks */ APP_TICKS_PER_SEC , /* timer clock frequency in Hz */ & AppDriver , /* select drivers for application */ & SdoSrvMem [ 0 ] /* SDO Transfer Buffer Memory */ }; : void ClkStartNode ( CO_NODE * node ) { /* Clear all entries in object dictionary */ ODInit ( & DynDict , & ClockOD [ 0 ], APP_OBJ_N ); /* Setup the object dictionary during runtime */ ODCreateDict ( & DynDict ); /* Create a node with generated object dictionary */ CONodeInit ( node , & AppSpec ); } This function will generate a (temporary) node specification, initializes our new dynamic object directory and initializes the CANopen node with this specification. To integrate this in the delivered quick start demo, the only line we must change is the initialization of the specified CANopen node: void main ( int argc , char * argv []) { : /* CONodeInit(&Clk, (CO_NODE_SPEC *)&AppSpec); OLD */ ClkStartNode ( & Clk ); /* NEW */ : } Well, that's it. Enjoy the new flexibility with our dynamic generated object directories.","title":"Starting the Node"},{"location":"examples/write-serial-number/","text":"Write serial number # In the production line, the devices should be programmed with the identical firmware image. The object entry 1018 holds optionally a serial number which sould be unique for each device. We need a one-time programmable object entry. Example Goal # The main idea is a manufacturer specific data type, which allows writing into a FLASH memory area if the current FLASH memory area is empty. Object Type Idea # The main idea is an object entry, which is directly mapped to FLASH cells. The type checks on a write access for empty FLASH cells and allows writing with a FLASH write algorithm if FLASH cells are empty. Object Entry Definitions # We define some manufacturer specific entries in the object dictionary: Index Subindex Type Access Value Description 1018h 4 UNSIGNED32 Const FFFFFFFF Serial No. The key to get the wanted functionality is the object type for the entry at subindex 4. This object type accepts a single permanent write access if the current value is 0xFFFFFFFF . Implement Object Type # Lets implement the one time programmable (OTP) user type as shown in the CANopen Usage: User Object : const uint32_t serialNo = 0xFFFFFFFFu ; /* locate this variable to FLASH and initialize with empty cell value */ const CO_OBJ_TYPE COTOtp = { 0 , 0 , 0 , OtpWrite }; #define CO_TOTP ((CO_OBJ_TYPE*)&COTOtp) The write function is called, when the CAN network writes to the related object entry via a SDO request. Now we want to allow the write algorithm for the constant FLASH value after a serial-no is written to the object entry at subindex 4. int16_t OtpWrite ( CO_OBJ * obj , struct CO_NODE_T * node , void * buffer , uint32_t size ) { uint32_t value = * (( uint32_t * ) buffer ); uint32_t serial = * (( uinter_t * ) obj -> Data ); CO_ERR result = CO_ERR_TYPE_WR ; if ( serial == 0xFFFFFFFF ) { /* call your hardware specific FLASH algorithm with * - start address in FLASH * - new serial value * - length of constant */ HwFlashWriteAlgorithm ( obj -> Data , value , 4 ); } return ( result ); } Implement Object Entries # We use our user type to define the calibration object entry: const CO_OBJ ExampleObjDir [] = { : { CO_KEY ( 0x1018 , 4 , CO_OBJ_D___R_ ), CO_TOTP , ( CO_DATA )( & serialNo ) }, : }; Now we have a one time programmable object entry for the serial number. This concept shows how to integrate application specific logic to specific object entry access.","title":"Write Serial Number"},{"location":"examples/write-serial-number/#write-serial-number","text":"In the production line, the devices should be programmed with the identical firmware image. The object entry 1018 holds optionally a serial number which sould be unique for each device. We need a one-time programmable object entry.","title":"Write serial number"},{"location":"examples/write-serial-number/#example-goal","text":"The main idea is a manufacturer specific data type, which allows writing into a FLASH memory area if the current FLASH memory area is empty.","title":"Example Goal"},{"location":"examples/write-serial-number/#object-type-idea","text":"The main idea is an object entry, which is directly mapped to FLASH cells. The type checks on a write access for empty FLASH cells and allows writing with a FLASH write algorithm if FLASH cells are empty.","title":"Object Type Idea"},{"location":"examples/write-serial-number/#object-entry-definitions","text":"We define some manufacturer specific entries in the object dictionary: Index Subindex Type Access Value Description 1018h 4 UNSIGNED32 Const FFFFFFFF Serial No. The key to get the wanted functionality is the object type for the entry at subindex 4. This object type accepts a single permanent write access if the current value is 0xFFFFFFFF .","title":"Object Entry Definitions"},{"location":"examples/write-serial-number/#implement-object-type","text":"Lets implement the one time programmable (OTP) user type as shown in the CANopen Usage: User Object : const uint32_t serialNo = 0xFFFFFFFFu ; /* locate this variable to FLASH and initialize with empty cell value */ const CO_OBJ_TYPE COTOtp = { 0 , 0 , 0 , OtpWrite }; #define CO_TOTP ((CO_OBJ_TYPE*)&COTOtp) The write function is called, when the CAN network writes to the related object entry via a SDO request. Now we want to allow the write algorithm for the constant FLASH value after a serial-no is written to the object entry at subindex 4. int16_t OtpWrite ( CO_OBJ * obj , struct CO_NODE_T * node , void * buffer , uint32_t size ) { uint32_t value = * (( uint32_t * ) buffer ); uint32_t serial = * (( uinter_t * ) obj -> Data ); CO_ERR result = CO_ERR_TYPE_WR ; if ( serial == 0xFFFFFFFF ) { /* call your hardware specific FLASH algorithm with * - start address in FLASH * - new serial value * - length of constant */ HwFlashWriteAlgorithm ( obj -> Data , value , 4 ); } return ( result ); }","title":"Implement Object Type"},{"location":"examples/write-serial-number/#implement-object-entries","text":"We use our user type to define the calibration object entry: const CO_OBJ ExampleObjDir [] = { : { CO_KEY ( 0x1018 , 4 , CO_OBJ_D___R_ ), CO_TOTP , ( CO_DATA )( & serialNo ) }, : }; Now we have a one time programmable object entry for the serial number. This concept shows how to integrate application specific logic to specific object entry access.","title":"Implement Object Entries"},{"location":"hardware/can/","text":"CAN Driver # CAN Driver Functions # The CAN driver contains a set of functions, which are called at specific locations within the CANopen stack. driver function calling location Init() during the start of node and bit timing switching Enable() during the start of node and bit timing switching Send() when the node needs to send a CAN message Read() when the node processing is started Reset() when NMT resets the communication Close() when the node is stopped and bit timing switching CAN Init # This driver function is called during the initialization phase and the bit timing switching of the CANopen stack. The function is intended to prepare the CAN controller for operation. void DrvCanInit ( void ); The function initializes the internal driver variables for managing the CAN communication and prepares the CAN controller for operation. Note The CAN controller must not active on the network because at this calling time the bit timing is not known. CAN Enable # This driver function is called during the initialization phase and the bit timing switching of the CANopen stack. The function is intended to setup the bit timing and activate the CAN controller on the network. void DrvCanEnable ( uint32_t baudrate ); The function initializes the bit timing according to the given baudrate and enables the CAN communication. Note Check the specified sample points from the CiA specifications and from your own specification. Wrong settings may result in instable networks. CAN Send # This driver function is called when the CANopen node needs to send a message to the CAN network. The function returns the number processed bytes sizeof(CO_IF_FRM) on success, (int16_t)0 in case transmission is not possible, or (int16_t)-1 when an error is detected. int16_t DrvCanSend ( CO_IF_FRM * frm ); Note You must ensure that the messages on the CAN bus keeps the order. Check the behavior of your CAN controller when you want to use multiple message buffers for a queued transmission. CAN Read # This driver function is called when the CANopen node processing is started. This function is intended to receive all messages from the CAN network. The function returns the number processed bytes sizeof(CO_IF_FRM) on success, (int16_t)0 in case of no reception, or (int16_t)-1 when an error is detected. int16_t DrvCanRead ( CO_IF_FRM * frm ); Note You must ensure that the messages are processed in the same order as they arrived from the CAN bus. Check the behavior of your CAN controller when you want to use multiple message buffers for a queued reception. Attention For evaluation, demonstration, or testing purpose this CAN read function may poll for a new CAN frame. In this special case, the additional return value with no received CAN frame is possible. Don't use the polling mode in production; you should use interrupt-driven CAN communication (ideally with some kind of CAN frame queueing). The CAN polling is not suitable for robust CANopen communication. CAN Reset # This driver function is called when the CANopen node needs to perform a communication reset. This function is intended to clear all errors from the CAN controller bus statistics and (re-)establishes the CAN communication. void DrvCanReset ( void ); CAN Close # This driver function is called when the CANopen node is stopped (e.g. with the API function CONodeStop() ). This function is intended to remove the node from the CAN bus. void DrvCanClose ( void ); CAN Driver Integration # During the design of the driver interface for usage with the CANopen stack, we want to decouple the CANopen library from the driver implementation. At the same time, we want to keep the overall usage as easy as possible. The solution for this requirement is the implementation of the CAN driver function as static functions within a single file and an allocated interface structure of type CO_IF_CAN_DRV : #include \"co_if.h\" : static void DrvCanInit ( void ); static void DrvCanEnable ( uint32_t baudrate ); static int16_t DrvCanSend ( CO_IF_FRM * frm ); static int16_t DrvCanRead ( CO_IF_FRM * frm ); static void DrvCanReset ( void ); static void DrvCanClose ( void ); : const CO_IF_CAN_DRV < MyDeviceDriverName > CanDriver = { DrvCanInit , DrvCanEnable , DrvCanRead , DrvCanSend , DrvCanReset , DrvCanClose }; With this kind of implementation, the usage is simply the import of the interface structure as an external symbol, and we are ready to go: : extern const CO_IF_CAN_DRV < MyDeviceDriverName > CanDriver ; : To keep the drivers organized, we put the implementation in a file which follows the naming convention: co_can_<my-device-driver-name>.c , and the declaration of the external symbol in the corresponding header file co_can_<my-device-driver-name>.h . CAN Driver Template # The files /driver/source/co_can_dummy.c and /driver/include/co_can_dummy.h are templates for CAN drivers.","title":"CAN Driver"},{"location":"hardware/can/#can-driver","text":"","title":"CAN Driver"},{"location":"hardware/can/#can-driver-functions","text":"The CAN driver contains a set of functions, which are called at specific locations within the CANopen stack. driver function calling location Init() during the start of node and bit timing switching Enable() during the start of node and bit timing switching Send() when the node needs to send a CAN message Read() when the node processing is started Reset() when NMT resets the communication Close() when the node is stopped and bit timing switching","title":"CAN Driver Functions"},{"location":"hardware/can/#can-init","text":"This driver function is called during the initialization phase and the bit timing switching of the CANopen stack. The function is intended to prepare the CAN controller for operation. void DrvCanInit ( void ); The function initializes the internal driver variables for managing the CAN communication and prepares the CAN controller for operation. Note The CAN controller must not active on the network because at this calling time the bit timing is not known.","title":"CAN Init"},{"location":"hardware/can/#can-enable","text":"This driver function is called during the initialization phase and the bit timing switching of the CANopen stack. The function is intended to setup the bit timing and activate the CAN controller on the network. void DrvCanEnable ( uint32_t baudrate ); The function initializes the bit timing according to the given baudrate and enables the CAN communication. Note Check the specified sample points from the CiA specifications and from your own specification. Wrong settings may result in instable networks.","title":"CAN Enable"},{"location":"hardware/can/#can-send","text":"This driver function is called when the CANopen node needs to send a message to the CAN network. The function returns the number processed bytes sizeof(CO_IF_FRM) on success, (int16_t)0 in case transmission is not possible, or (int16_t)-1 when an error is detected. int16_t DrvCanSend ( CO_IF_FRM * frm ); Note You must ensure that the messages on the CAN bus keeps the order. Check the behavior of your CAN controller when you want to use multiple message buffers for a queued transmission.","title":"CAN Send"},{"location":"hardware/can/#can-read","text":"This driver function is called when the CANopen node processing is started. This function is intended to receive all messages from the CAN network. The function returns the number processed bytes sizeof(CO_IF_FRM) on success, (int16_t)0 in case of no reception, or (int16_t)-1 when an error is detected. int16_t DrvCanRead ( CO_IF_FRM * frm ); Note You must ensure that the messages are processed in the same order as they arrived from the CAN bus. Check the behavior of your CAN controller when you want to use multiple message buffers for a queued reception. Attention For evaluation, demonstration, or testing purpose this CAN read function may poll for a new CAN frame. In this special case, the additional return value with no received CAN frame is possible. Don't use the polling mode in production; you should use interrupt-driven CAN communication (ideally with some kind of CAN frame queueing). The CAN polling is not suitable for robust CANopen communication.","title":"CAN Read"},{"location":"hardware/can/#can-reset","text":"This driver function is called when the CANopen node needs to perform a communication reset. This function is intended to clear all errors from the CAN controller bus statistics and (re-)establishes the CAN communication. void DrvCanReset ( void );","title":"CAN Reset"},{"location":"hardware/can/#can-close","text":"This driver function is called when the CANopen node is stopped (e.g. with the API function CONodeStop() ). This function is intended to remove the node from the CAN bus. void DrvCanClose ( void );","title":"CAN Close"},{"location":"hardware/can/#can-driver-integration","text":"During the design of the driver interface for usage with the CANopen stack, we want to decouple the CANopen library from the driver implementation. At the same time, we want to keep the overall usage as easy as possible. The solution for this requirement is the implementation of the CAN driver function as static functions within a single file and an allocated interface structure of type CO_IF_CAN_DRV : #include \"co_if.h\" : static void DrvCanInit ( void ); static void DrvCanEnable ( uint32_t baudrate ); static int16_t DrvCanSend ( CO_IF_FRM * frm ); static int16_t DrvCanRead ( CO_IF_FRM * frm ); static void DrvCanReset ( void ); static void DrvCanClose ( void ); : const CO_IF_CAN_DRV < MyDeviceDriverName > CanDriver = { DrvCanInit , DrvCanEnable , DrvCanRead , DrvCanSend , DrvCanReset , DrvCanClose }; With this kind of implementation, the usage is simply the import of the interface structure as an external symbol, and we are ready to go: : extern const CO_IF_CAN_DRV < MyDeviceDriverName > CanDriver ; : To keep the drivers organized, we put the implementation in a file which follows the naming convention: co_can_<my-device-driver-name>.c , and the declaration of the external symbol in the corresponding header file co_can_<my-device-driver-name>.h .","title":"CAN Driver Integration"},{"location":"hardware/can/#can-driver-template","text":"The files /driver/source/co_can_dummy.c and /driver/include/co_can_dummy.h are templates for CAN drivers.","title":"CAN Driver Template"},{"location":"hardware/nvm/","text":"NVM Driver # NVM Driver Functions # The NVM driver contains a set of functions, which are called at specific locations within the CANopen stack. driver function calling location Init() during the start of node Read() during the start of node and parameter load requests Write() when parameter storage is requested NVM Init # This driver function is called during the startup phase of the CANopen stack. The function is intended to initialize the driver internal variables and setup the non-volatile memory communication. void DrvNvmInit ( void ); NVM Read # This driver function is called during the startup phase of the CANopen stack. The function is intended to read stored data out of the non-volatile memory from the address start with a given size and copy them into the given buffer . The function returns the number of successfully read bytes. uint32_t DrvNvmRead ( uint32_t start , uint8_t * buffer , uint32_t size ); NVM Write # This driver function is called during the storing data in the CANopen stack. The function is intended to write data given by the given buffer into the non-volatile memory starting at the address start with a given size . The function returns the number of successfully written bytes. uint32_t DrvNvmWrite ( uint32_t start , uint8_t * buffer , uint32_t size ); NVM Driver Reference # During the design of the driver interface for usage with the CANopen stack, we want to decouple the CANopen library from the driver implementation. At the same time, we want to keep the overall usage as easy as possible. The solution for this requirement is the implementation of the NVM driver function as static functions within a single file and an allocated interface structure of type CO_IF_NVM_DRV : #include \"co_if.h\" : static void DrvNvmInit ( void ); static uint32_t DrvNvmRead ( uint32_t start , uint8_t * buffer , uint32_t size ); static uint32_t DrvNvmWrite ( uint32_t start , uint8_t * buffer , uint32_t size ); : const CO_IF_NVM_DRV < MyDeviceDriverName > NvmDriver = { DrvNvmInit , DrvNvmRead , DrvNvmWrite }; With this kind of implementation, the usage is simply the import of the interface structure as an external symbol, and we are ready to go: : extern const CO_IF_NVM_DRV < MyDeviceDriverName > NvmDriver ; : To keep the drivers organized, we put the implementation in a file which follows the naming convention: co_nvm_<my-device-driver-name>.c , and the declaration of the external symbol in the corresponding header file co_nvm_<my-device-driver-name>.h . NVM Driver Template # The files /driver/source/co_nvm_dummy.c and /driver/include/co_nvm_dummy.h are templates for NVM drivers.","title":"NVM Driver"},{"location":"hardware/nvm/#nvm-driver","text":"","title":"NVM Driver"},{"location":"hardware/nvm/#nvm-driver-functions","text":"The NVM driver contains a set of functions, which are called at specific locations within the CANopen stack. driver function calling location Init() during the start of node Read() during the start of node and parameter load requests Write() when parameter storage is requested","title":"NVM Driver Functions"},{"location":"hardware/nvm/#nvm-init","text":"This driver function is called during the startup phase of the CANopen stack. The function is intended to initialize the driver internal variables and setup the non-volatile memory communication. void DrvNvmInit ( void );","title":"NVM Init"},{"location":"hardware/nvm/#nvm-read","text":"This driver function is called during the startup phase of the CANopen stack. The function is intended to read stored data out of the non-volatile memory from the address start with a given size and copy them into the given buffer . The function returns the number of successfully read bytes. uint32_t DrvNvmRead ( uint32_t start , uint8_t * buffer , uint32_t size );","title":"NVM Read"},{"location":"hardware/nvm/#nvm-write","text":"This driver function is called during the storing data in the CANopen stack. The function is intended to write data given by the given buffer into the non-volatile memory starting at the address start with a given size . The function returns the number of successfully written bytes. uint32_t DrvNvmWrite ( uint32_t start , uint8_t * buffer , uint32_t size );","title":"NVM Write"},{"location":"hardware/nvm/#nvm-driver-reference","text":"During the design of the driver interface for usage with the CANopen stack, we want to decouple the CANopen library from the driver implementation. At the same time, we want to keep the overall usage as easy as possible. The solution for this requirement is the implementation of the NVM driver function as static functions within a single file and an allocated interface structure of type CO_IF_NVM_DRV : #include \"co_if.h\" : static void DrvNvmInit ( void ); static uint32_t DrvNvmRead ( uint32_t start , uint8_t * buffer , uint32_t size ); static uint32_t DrvNvmWrite ( uint32_t start , uint8_t * buffer , uint32_t size ); : const CO_IF_NVM_DRV < MyDeviceDriverName > NvmDriver = { DrvNvmInit , DrvNvmRead , DrvNvmWrite }; With this kind of implementation, the usage is simply the import of the interface structure as an external symbol, and we are ready to go: : extern const CO_IF_NVM_DRV < MyDeviceDriverName > NvmDriver ; : To keep the drivers organized, we put the implementation in a file which follows the naming convention: co_nvm_<my-device-driver-name>.c , and the declaration of the external symbol in the corresponding header file co_nvm_<my-device-driver-name>.h .","title":"NVM Driver Reference"},{"location":"hardware/nvm/#nvm-driver-template","text":"The files /driver/source/co_nvm_dummy.c and /driver/include/co_nvm_dummy.h are templates for NVM drivers.","title":"NVM Driver Template"},{"location":"hardware/timer/","text":"Timer Driver # Timer Modes # As a source for CANopen timer management, we need some kind of interrupt which is related to real-time. We distinguish between two different modes for generating the needed time intervals out of the real-time related interrupt: the Cyclic Mode and the Delta Mode . Cyclic Mode # In this mode, a periodic interrupt source is (re-)used. The period time of the interrupts represents the granularity for the generation of needed time intervals. no dedicated hardware timer required small and easy timer implementation Delta Mode # In this mode, a hardware timer is used as a source for the interrupts. The input clock frequency of the timer represents the granularity for the generation of needed time intervals. interrupt occurs only when needed higher accuracy of time intervals possible Timer Driver Functions # The timer driver contains a set of functions, which are called at specific locations within the CANopen stack. driver function calling location Init() during initialization of CANopen node Reload() when running time interval is elapsed Delay() when the needed time interval is created Stop() when last running time interval is deleted Start() when the first time interval is created Update() when timer interrupt occurs Timer Init # This driver function is called during the initialization phase of the CANopen stack. The function is intended to prepare the real-time related interrupt. void DrvTimerInit ( uint32_t freq ); The required implementation depends on time generation mode: Cyclic Mode - the function initializes the internal driver variables for counting the periodic interrupts (and ignores the given frequency freq ). Delta Mode - the function initializes a hardware timer with the given frequency freq as timer counting frequency. Timer Reload # This driver function is called when a running time interval is elapsed. The function is intended to prepare the next needed time interval. void DrvTimerReload ( uint32_t reload ); The required implementation depends on time generation mode: Cyclic Mode - the function sets the internal driver interrupt counting variable to the given number of interrupts: reload . Delta Mode - the function uses the value reload to setup the hardware timer for the next needed interrupt. Timer Delay # This driver function is called during creating a needed time interval. This function is intended to return the number of ticks before the current running time is elapsed. uint32_t DrvTimerDelay ( void ); The required implementation is independent of the time generation mode. Timer Stop # This driver function is called after deleting or elapsing of the last needed time interval. This function is intended to stop further interrupts. void DrvTimerStop ( void ); The required implementation depends on time generation mode: Cyclic Mode - the function may optionally reset the internal driver interrupt counting variable. The interrupt are still generated (by the (re)used source), but have no impact on the timer management. Delta Mode - the function stops the hardware timer to avoid unnecessary interrupts. Timer Start # This function is called after creating the first needed time interval. This function is intended to enable the interrupts. void DrvTimerStart ( void ); The required implementation depends on time generation mode: Cyclic Mode - the function is most likely empty because the interrupts are (re)used from an independent source. Delta Mode - the function starts the hardware timer to get the already programmed timer interrupts. Timer Update # This function is called when a real-time related interrupt occurs. This function is intended to update the timer driver state. uint8_t DrvTimerUpdate ( void ); The required implementation depends on time generation mode: Cyclic Mode - the function counts the amount of cyclic interrupts and indicates an elapsed time interval by returning (uint8_t)1u . Delta Mode - this function returns always an elapsed time interval (uint8_t)1u because each interrupt represents a needed time interval. Timer Driver Integration # During the design of the driver interface for usage with the CANopen stack, we want to decouple the CANopen library from the driver implementation. At the same time, we want to keep the overall usage as easy as possible. The solution for this requirement is the implementation of the timer driver function as static functions within a single file and an allocated interface structure of type CO_IF_TIMER_DRV : #include \"co_if.h\" : static void DrvTimerInit ( uint32_t freq ); static void DrvTimerReload ( uint32_t reload ); static uint32_t DrvTimerDelay ( void ); static void DrvTimerStop ( void ); static void DrvTimerStart ( void ); static uint8_t DrvTimerUpdate ( void ); : const CO_IF_TIMER_DRV < MyDeviceDriverName > TimerDriver = { DrvTimerInit , DrvTimerReload , DrvTimerDelay , DrvTimerStop , DrvTimerStart , DrvTimerUpdate }; With this kind of implementation, the usage is simply the import of the interface structure as an external symbol, and we are ready to go: : extern const CO_IF_TIMER_DRV < MyDeviceDriverName > TimerDriver ; : To keep the drivers organized, we put the implementation in a file which follows the naming convention: co_timer_<my-device-driver-name>.c , and the declaration of the external symbol in the corresponding header file co_timer_<my-device-driver-name>.h . Timer Driver Template # The files /driver/source/co_timer_dummy.c and /driver/include/co_timer_dummy.h are templates for timer drivers.","title":"Timer Driver"},{"location":"hardware/timer/#timer-driver","text":"","title":"Timer Driver"},{"location":"hardware/timer/#timer-modes","text":"As a source for CANopen timer management, we need some kind of interrupt which is related to real-time. We distinguish between two different modes for generating the needed time intervals out of the real-time related interrupt: the Cyclic Mode and the Delta Mode .","title":"Timer Modes"},{"location":"hardware/timer/#cyclic-mode","text":"In this mode, a periodic interrupt source is (re-)used. The period time of the interrupts represents the granularity for the generation of needed time intervals. no dedicated hardware timer required small and easy timer implementation","title":"Cyclic Mode"},{"location":"hardware/timer/#delta-mode","text":"In this mode, a hardware timer is used as a source for the interrupts. The input clock frequency of the timer represents the granularity for the generation of needed time intervals. interrupt occurs only when needed higher accuracy of time intervals possible","title":"Delta Mode"},{"location":"hardware/timer/#timer-driver-functions","text":"The timer driver contains a set of functions, which are called at specific locations within the CANopen stack. driver function calling location Init() during initialization of CANopen node Reload() when running time interval is elapsed Delay() when the needed time interval is created Stop() when last running time interval is deleted Start() when the first time interval is created Update() when timer interrupt occurs","title":"Timer Driver Functions"},{"location":"hardware/timer/#timer-init","text":"This driver function is called during the initialization phase of the CANopen stack. The function is intended to prepare the real-time related interrupt. void DrvTimerInit ( uint32_t freq ); The required implementation depends on time generation mode: Cyclic Mode - the function initializes the internal driver variables for counting the periodic interrupts (and ignores the given frequency freq ). Delta Mode - the function initializes a hardware timer with the given frequency freq as timer counting frequency.","title":"Timer Init"},{"location":"hardware/timer/#timer-reload","text":"This driver function is called when a running time interval is elapsed. The function is intended to prepare the next needed time interval. void DrvTimerReload ( uint32_t reload ); The required implementation depends on time generation mode: Cyclic Mode - the function sets the internal driver interrupt counting variable to the given number of interrupts: reload . Delta Mode - the function uses the value reload to setup the hardware timer for the next needed interrupt.","title":"Timer Reload"},{"location":"hardware/timer/#timer-delay","text":"This driver function is called during creating a needed time interval. This function is intended to return the number of ticks before the current running time is elapsed. uint32_t DrvTimerDelay ( void ); The required implementation is independent of the time generation mode.","title":"Timer Delay"},{"location":"hardware/timer/#timer-stop","text":"This driver function is called after deleting or elapsing of the last needed time interval. This function is intended to stop further interrupts. void DrvTimerStop ( void ); The required implementation depends on time generation mode: Cyclic Mode - the function may optionally reset the internal driver interrupt counting variable. The interrupt are still generated (by the (re)used source), but have no impact on the timer management. Delta Mode - the function stops the hardware timer to avoid unnecessary interrupts.","title":"Timer Stop"},{"location":"hardware/timer/#timer-start","text":"This function is called after creating the first needed time interval. This function is intended to enable the interrupts. void DrvTimerStart ( void ); The required implementation depends on time generation mode: Cyclic Mode - the function is most likely empty because the interrupts are (re)used from an independent source. Delta Mode - the function starts the hardware timer to get the already programmed timer interrupts.","title":"Timer Start"},{"location":"hardware/timer/#timer-update","text":"This function is called when a real-time related interrupt occurs. This function is intended to update the timer driver state. uint8_t DrvTimerUpdate ( void ); The required implementation depends on time generation mode: Cyclic Mode - the function counts the amount of cyclic interrupts and indicates an elapsed time interval by returning (uint8_t)1u . Delta Mode - this function returns always an elapsed time interval (uint8_t)1u because each interrupt represents a needed time interval.","title":"Timer Update"},{"location":"hardware/timer/#timer-driver-integration","text":"During the design of the driver interface for usage with the CANopen stack, we want to decouple the CANopen library from the driver implementation. At the same time, we want to keep the overall usage as easy as possible. The solution for this requirement is the implementation of the timer driver function as static functions within a single file and an allocated interface structure of type CO_IF_TIMER_DRV : #include \"co_if.h\" : static void DrvTimerInit ( uint32_t freq ); static void DrvTimerReload ( uint32_t reload ); static uint32_t DrvTimerDelay ( void ); static void DrvTimerStop ( void ); static void DrvTimerStart ( void ); static uint8_t DrvTimerUpdate ( void ); : const CO_IF_TIMER_DRV < MyDeviceDriverName > TimerDriver = { DrvTimerInit , DrvTimerReload , DrvTimerDelay , DrvTimerStop , DrvTimerStart , DrvTimerUpdate }; With this kind of implementation, the usage is simply the import of the interface structure as an external symbol, and we are ready to go: : extern const CO_IF_TIMER_DRV < MyDeviceDriverName > TimerDriver ; : To keep the drivers organized, we put the implementation in a file which follows the naming convention: co_timer_<my-device-driver-name>.c , and the declaration of the external symbol in the corresponding header file co_timer_<my-device-driver-name>.h .","title":"Timer Driver Integration"},{"location":"hardware/timer/#timer-driver-template","text":"The files /driver/source/co_timer_dummy.c and /driver/include/co_timer_dummy.h are templates for timer drivers.","title":"Timer Driver Template"},{"location":"start/installation/","text":"Installation # With version 4.4 the CANopen Stack project introduces an ecosystem, which supports you in project management. This is realized by using multiple repositories with independent version management for important aspects of an embedded software project setup: cmake-scripts - this repository is responsible for the embedded toolchains and the component package management. canopen-stack - this repository represents the platform independent CANopen stack component. canopen-stm32f7xx - this repository contains a complete Quickstart example setup for the device STM32F769. The adaption to other devices out of the STM32F7 series are small. STM32CubeF7 - this fork of the ST Microelectronics HAL package is integrated into the CMake build system and packaged with minimal required source files to get the ST HAL/LL drivers working (No middleware and documentation). Add Component in CMake (recommended) # The build system is realized with CMake and the CPM.cmake package management. See cmake-scripts for details. Including the CANopen Stack into the project is done during the configuration phase of the build environment. During this phase, the CANopen Stack is fetched in the defined version and is available for usage. set ( CO_TARGET \"canopen-stack\" ) set ( CO_PROJECT \"embedded-office/canopen-stack\" ) set ( CO_VERSION \"4.4.0\" ) CPMAddPackage ( NAME ${ CO_TARGET } URL https://github.com/ ${ CO_PROJECT } /releases/download/v ${ CO_VERSION } / ${ CO_TARGET } -src.zip VERSION ${ CO_VERSION } ) Getting the Source # When you just want to use the source code of the platform independent CANopen Stack, all you need to do is getting the repository canopen-stack and use the files in your prefered build system. There are multiple ways in getting the source code: Clone Repository # Clone the canopen-stack repository from github. This is good if you want to review and merge future updates into your project: git clone https://github.com/embedded-office/canopen-stack.git Download ZIP File # Download and unzip the file from the canopen-stack repository. This is good if you want to work on hosts without internet access. Click on Releases Download the package canopen-stack-src.zip Unzip the archive to your local drive Note This is exactly what the CMake command CPMAddPackage() does during project configuration. Fork Repository # Fork the github repository canopen-stack into your GitHub account. This is good if you want to collaborate enhancements or bugfixes to the project. Any improvement of the project is highly welcome. Cross-compile for Target # Add the source files and include paths to a library project (see Repository Structure ). Create a library with your cross-compiler and share this library together with the include files with your embedded software project. Note This is exactly what the CMake command CPMAddPackage() prepares during project configuration.","title":"Install Environment"},{"location":"start/installation/#installation","text":"With version 4.4 the CANopen Stack project introduces an ecosystem, which supports you in project management. This is realized by using multiple repositories with independent version management for important aspects of an embedded software project setup: cmake-scripts - this repository is responsible for the embedded toolchains and the component package management. canopen-stack - this repository represents the platform independent CANopen stack component. canopen-stm32f7xx - this repository contains a complete Quickstart example setup for the device STM32F769. The adaption to other devices out of the STM32F7 series are small. STM32CubeF7 - this fork of the ST Microelectronics HAL package is integrated into the CMake build system and packaged with minimal required source files to get the ST HAL/LL drivers working (No middleware and documentation).","title":"Installation"},{"location":"start/installation/#add-component-in-cmake-recommended","text":"The build system is realized with CMake and the CPM.cmake package management. See cmake-scripts for details. Including the CANopen Stack into the project is done during the configuration phase of the build environment. During this phase, the CANopen Stack is fetched in the defined version and is available for usage. set ( CO_TARGET \"canopen-stack\" ) set ( CO_PROJECT \"embedded-office/canopen-stack\" ) set ( CO_VERSION \"4.4.0\" ) CPMAddPackage ( NAME ${ CO_TARGET } URL https://github.com/ ${ CO_PROJECT } /releases/download/v ${ CO_VERSION } / ${ CO_TARGET } -src.zip VERSION ${ CO_VERSION } )","title":"Add Component in CMake (recommended)"},{"location":"start/installation/#getting-the-source","text":"When you just want to use the source code of the platform independent CANopen Stack, all you need to do is getting the repository canopen-stack and use the files in your prefered build system. There are multiple ways in getting the source code:","title":"Getting the Source"},{"location":"start/installation/#clone-repository","text":"Clone the canopen-stack repository from github. This is good if you want to review and merge future updates into your project: git clone https://github.com/embedded-office/canopen-stack.git","title":"Clone Repository"},{"location":"start/installation/#download-zip-file","text":"Download and unzip the file from the canopen-stack repository. This is good if you want to work on hosts without internet access. Click on Releases Download the package canopen-stack-src.zip Unzip the archive to your local drive Note This is exactly what the CMake command CPMAddPackage() does during project configuration.","title":"Download ZIP File"},{"location":"start/installation/#fork-repository","text":"Fork the github repository canopen-stack into your GitHub account. This is good if you want to collaborate enhancements or bugfixes to the project. Any improvement of the project is highly welcome.","title":"Fork Repository"},{"location":"start/installation/#cross-compile-for-target","text":"Add the source files and include paths to a library project (see Repository Structure ). Create a library with your cross-compiler and share this library together with the include files with your embedded software project. Note This is exactly what the CMake command CPMAddPackage() prepares during project configuration.","title":"Cross-compile for Target"},{"location":"start/quickstart/","text":"Quickstart # The quickstart example describes in detail the steps to build a CANopen node. The source files are included in the example repository canopen-stm32f7xx . To get most out of this artice, you should clone this repository and follow in the real files during reading this article. For setting up the hardware and software environment, please follow the README.md in the root of the example repository canopen-stm32f7xx . Functional Specification # In this quickstart example, we will create a CANopen Clock . This clock is not a serious application, the example just illustrates the key principles of creating a device using the CANopen Stack. The CANopen clock shall measure the time while the device is switched to OPERATIONAL mode. In OPERATIONAL mode, the node will transmit a PDO every second. The SDO server allows access to the device information at any time. Architectural Overview # The following figure shows the layered architecture of the CANopen Clock device and the related directories. The following descriptions explains in detail the important parts of the directory src/app/... . All other directories and files are described within the source files. The directory src/app/... contains three modules: clock_spec.c/h - this module configures the CANopen Stack layer clock_hw.c/h - this module connects the CANopen Stack layer to the hardware clock_app.c/h - this module includes the CANopen application Clock Spec # The main settings of the node are configured inside the CO_NODE_SPEC struct. This struct is not used or modified after initialization is finished. This allows you to declared this structure as a constant. Due to the fact, that the central element of a CANopen node is the object dictionary, we start with the description of the specification of our object dictionary. You find the specification in the file src/app/clock_spec.c . Object Dictionary # Description To keep the software as simple as possible, we will use a static object dictionary. In this case, the object dictionary is an array of object entries, declared as a constant array of object entries of type CO_OBJ . Implementation : #define APP_OBJ_N 128u /* Object dictionary max size */ : /* define the static object dictionary */ const CO_OBJ ClockOD [ APP_OBJ_N ] = { : /* here is your array of object entries */ : CO_OBJ_DICT_ENDMARK /* mark end of used objects */ }; : Mandatory Object Entries # Description When we want to achieve compliance with the CiA301 specification, the object dictionary must hold some mandatory object entries: Index:sub Type Access Value Description 1000h:00 UNSIGNED32 Const 0 Device Type 1001h:00 UNSIGNED8 Read-only 0 Error Register 1014h:00 UNSIGNED32 Const 80h + node ID COB-ID EMCY 1017h:00 UNSIGNED16 Read-Write 0 Heartbeat Producer 1018h:00 UNSIGNED8 Const 4 Identity Object 1018h:01 UNSIGNED32 Const 0 - Vendor ID 1018h:02 UNSIGNED32 Const 0 - Product code 1018h:03 UNSIGNED32 Const 0 - Revision number 1018h:04 UNSIGNED32 Const 0 - Serial number Implementation The configuration of each object entry is a single configuration line within the object dictionary CO_OBJ array. The following figure shows how a single line is constructed: The CO_KEY macro creates out of \" index, subindex \" and the \" property flags \" the unique object entry key, which is used for addressing an object entry. The property flags are a collection of type settings (more details, see in Configuration / Property Flags ). A letter indicates ON , while an underscore ( _ ) at the same place indicates OFF : RW - The access mode flags (read, write by network) NAP - The object type flags (node-id considered, asynchronous trigger, PDO mappable) D - The direct storage flag (used to store the value directly in the object data field) The object type references the object type functions for this object entry. The object data is a pointer to the object entry data (or in some cases a object data structure). What kind of data the object type requires, is listed in Configuration / Object Type Interface . With this knowledge, the mandatory entries are added with the following lines of code: : { CO_KEY ( 0x1000 , 0 , CO_OBJ_____R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1000_00_20 )}, { CO_KEY ( 0x1001 , 0 , CO_OBJ_____R_ ), CO_TUNSIGNED8 , ( CO_DATA )( & Obj1001_00_08 )}, { CO_KEY ( 0x1014 , 0 , CO_OBJ__N__R_ ), CO_TEMCY_ID , ( CO_DATA )( & Obj1014_00_20 )}, { CO_KEY ( 0x1017 , 0 , CO_OBJ_____RW ), CO_THB_PROD , ( CO_DATA )( & Obj1017_00_10 )}, { CO_KEY ( 0x1018 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 4 ) }, { CO_KEY ( 0x1018 , 1 , CO_OBJ_____R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1018_01_20 )}, { CO_KEY ( 0x1018 , 2 , CO_OBJ_____R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1018_02_20 )}, { CO_KEY ( 0x1018 , 3 , CO_OBJ_____R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1018_03_20 )}, { CO_KEY ( 0x1018 , 4 , CO_OBJ_____R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1018_04_20 )}, : Important The CANopen Stack relies on a binary search algorithm to ensure that object dictionary entries are found quickly. Because of this, you must keep the index / subindex of all entries in the object dictionary sorted in ascending order. Most of these entries are constant. We can place their values in read-only FLASH memory. This is not the case for the error register object 1001h and the heartbeat producer 1017h . These entries may change during runtime. Therefore, we need to declare global variables in RAM memory to hold the runtime value of these entries: /* allocate variables for dynamic runtime value in RAM */ uint8_t Obj1001_00_08 = 0 ; uint16_t Obj1017_00_08 = 0 ; /* allocate variables for constant values in FLASH */ const uint32_t Obj1000_00_20 = 0x00000000L ; const uint32_t Obj1014_00_20 = 0x00000080L ; const uint32_t Obj1018_01_20 = 0x00000000L ; const uint32_t Obj1018_02_20 = 0x00000000L ; const uint32_t Obj1018_03_20 = 0x00000000L ; const uint32_t Obj1018_04_20 = 0x00000000L ; A pointer to the variables and constants are stored in the corresponding object dictionary entry. The subindex 0 of the object record 1018h holds a single byte which is constant. We can store the value directly in the object data field (so we need no constant variable) and set the D flag in the properties (compare: CO_OBJ_D___R_ vs. CO_OBJ_____R_ - and be careful when specify your object entries). Important When using architectures with pointer types lower than 32bit (e.g. 16bit microcontrollers), you can store only values up to the pointer width directly in the object dictionary. For larger values declare a constant variable and place a pointer to this constant into the object dictionary! ``` SDO Server # Description The settings for the SDO server are defined in CiA301 and must contain the following object dictionary entries: Index:sub Type Access Value Description 1200h:00 UNSIGNED8 Const 2 Communication Object SDO Server 1200h:01 UNSIGNED32 Const 600h + node ID - SDO Server Request COBID 1200h:02 UNSIGNED32 Const 580h + node ID - SDO Server Response COBID Implementation The following lines add the SDO server entries to the object dictionary: /* allocate variables for constant values in FLASH */ const uint32_t Obj1200_01_20 = CO_COBID_SDO_REQUEST (); const uint32_t Obj1200_02_20 = CO_COBID_SDO_RESPONSE (); : /* within object dictionary */ { CO_KEY ( 0x1200 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 2 )}, { CO_KEY ( 0x1200 , 1 , CO_OBJ__N__R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1200_01_20 )}, { CO_KEY ( 0x1200 , 2 , CO_OBJ__N__R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1200_02_20 )}, : The predefined COBIDs are dependent on the actual node ID. For this reason, the CANopen stack allows you to specify entries whose value depends on the current node ID at runtime. This behavior is specified using the N flag in the CO_OBJ__N__R_ properties. Application Object Entries # Description We need to add some manufacturer specific object entries to support the clock of the example application: Index:sub Type Access Value Description 2100h:00 UNSIGNED8 Const 3 Clock Object 2100h:01 UNSIGNED32 Read Only 0 - Hour 2100h:02 UNSIGNED8 Read Only 0 - Minute 2100h:03 UNSIGNED8 Read Only 0 - Second Info These entries are placed within the manufacturer-specific area (from 2000h up to 5FFFh ) and can be chosen freely (see CiA301). Entries outside of this range cannot be chosen freely, and should conform to the various CiA standards and profiles (e.g. CiA301 for communication profile area, CiA401 for generic IO modules, etc). Implementation These entries are created using the following lines of code: /* allocate variables for dynamic runtime value in RAM */ uint32_t Obj2100_01_20 = 0 ; uint8_t Obj2100_02_08 = 0 ; uint8_t Obj2100_03_08 = 0 ; : /* within object dictionary */ { CO_KEY ( 0x2100 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 3 )}, { CO_KEY ( 0x2100 , 1 , CO_OBJ____PR_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj2100_01_20 )}, { CO_KEY ( 0x2100 , 2 , CO_OBJ____PR_ ), CO_TUNSIGNED8 , ( CO_DATA )( & Obj2100_02_08 )}, { CO_KEY ( 0x2100 , 3 , CO_OBJ___APR_ ), CO_TUNSIGNED8 , ( CO_DATA )( & Obj2100_03_08 )}, : The flag CO_OBJ___A___ for the object entry 2100h:03 enables the \" asynchronous transmission trigger \" for PDOs. This means: when changing the value of this object entry, all PDOs with an active mapping to this object are triggered for transmission. We use this mechanism to achieve the PDO transmission on each write access to the second. Important The asynchronous transmission trigger is provided for the basic type functions: CO_TUNSIGNED8 , CO_TSIGNED8 , CO_TUNSIGNED16 , CO_TSIGNED16 , CO_TUNSIGNED32 and CO_TSIGNED32 . TPDO Communication # Description The communication settings for the TPDO must contain the following object entries: Index:sub Type Access Value Description 1800h:00 UNSIGNED8 Const 2 Communication Object TPDO #0 1800h:01 UNSIGNED32 Const 40000180h + node ID - PDO transmission COBID (no RTR) 1800h:02 UNSIGNED8 Const 254 - PDO transmission type Implementation See the following lines in the object dictionary: /* allocate variables for constant values in FLASH */ const uint32_t Obj1800_01_20 = CO_COBID_TPDO_DEFAULT ( 0 ); : /* within object dictionary */ { CO_KEY ( 0x1800 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 2 ) }, { CO_KEY ( 0x1800 , 1 , CO_OBJ__N__R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1800_01_20 )}, { CO_KEY ( 0x1800 , 2 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 254 ) }, : The CANopen stack does not support remote CAN frames as they are no longer recommended for new devices. The use of RTR frames in CANopen devices has been deprecated for many years now. Bit 30 in 1800h:01 indicates that a remote transfer request (RTR) is not allowed for this PDO. The CAN identifier 180h + node-ID is the recommended value from the pre-defined connection set. TPDO Data Mapping # Description The mapping settings for the TPDO must contain the following object entries: Index:sub Type Access Value Description 1A00h:00 UNSIGNED8 Const 3 Mapping Object TPDO #0 1A00h:01 UNSIGNED32 Const 21000120h - map: 32-bit clock hour 1A00h:02 UNSIGNED32 Const 21000208h - map: 8-bit clock minute 1A00h:03 UNSIGNED32 Const 21000308h - map: 8-bit clock second How we get these values is explained in section configuration of PDO mapping . Implementation This way of defining the payload for PDOs is part of the CiA301 standard and leads us to the following lines in the object dictionary: /* allocate variables for constant values in FLASH */ const uint32_t Obj1A00_01_20 = CO_LINK ( 0x2100 , 0x01 , 32 ); const uint32_t Obj1A00_02_20 = CO_LINK ( 0x2100 , 0x02 , 8 ); const uint32_t Obj1A00_03_20 = CO_LINK ( 0x2100 , 0x03 , 8 ); : /* within object dictionary */ { CO_KEY ( 0x1A00 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 3 ) }, { CO_KEY ( 0x1A00 , 1 , CO_OBJ_____R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1A00_01_20 )}, { CO_KEY ( 0x1A00 , 2 , CO_OBJ_____R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1A00_02_20 )}, { CO_KEY ( 0x1A00 , 3 , CO_OBJ_____R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1A00_03_20 )}, : EMCY Error Specification # Description We want to send a EMCY message, when we detect a hardware error (e.g. an unplugged EEPROM). The EMCY error code and error register flag is defined in the following table: EMCY ID Error Register ( 1001h ) EMCY Code APP_ERR_ID_EEPROM Bit 0 ( CO_EMCY_REG_GENERAL ) 0x5000 ( CO_EMCY_CODE_HW_ERR ) Implementation We define all possible identifiers as a handy enumeration. enum { APP_ERR_ID_EEPROM = 0 , APP_ERR_ID_NUM /* number of EMCYs in application */ }; The CANopen stack behavior for each of these EMCY identifier is defined in an EMCY table. Here we define the related error register bit and the EMCY code. The defines CO_EMCY_REG_... for the error register bits and CO_EMCY_CODE_... for the EMCY code base values are specified values out of the CANopen specification. static CO_EMCY_TBL AppEmcyTbl [ APP_ERR_ID_NUM ] = { { CO_EMCY_REG_GENERAL , CO_EMCY_CODE_HW_ERR } /* APP_ERR_ID_EEPROM */ }; Possible extension With these enumerations in place, we can call the EMCY service functions in our application. For example we can add the following line at the end of the clock application to store the operational time in hh:mm : : /* store operational time (hour and minute) in NVM */ if ( second == 0 ) { uint32_t num ; num = COIfNvmWrite ( & Clk . If , 0 , & hour , 4 ); num += COIfNvmWrite ( & Clk . If , 0 , & minute , 1 ); if ( num != 5 ) { COEmcySet ( & Clk . Emcy , APP_ERR_ID_EEPROM , 0 ); /*no user data*/ } else { COEmcyClr ( & Clk . Emcy , APP_ERR_ID_EEPROM ); } } Reading the stored value during startup, or data protection with 2 toggling storage locations is left as training for you. CANopen Timers # Description The CANopen stack provides flexible timers for protocol and application usage. Implementation Each software timer needs some memory for managing the lists and states of the timed action events: : #define APP_TMR_N 16u /* Number of software timers */ : CO_TMR_MEM TmrMem [ APP_TMR_N ]; /* Allocate timer memory */ : SDO Server Buffers # Description The CANopen node requires for each SDO server a certain amount of transmission buffers, in case the client is using segmented or block transfers to access large objects. Implementation Each SDO server needs memory for the segmented or block transfer requests. uint8_t SdoSrvMem [ CO_SSDO_N * CO_SDO_BUF_BYTE ]; Fill the Specification Structure # Description We want to act the CANopen node with a NodeId of 1 , and a CAN network baudrate of 250kBaud For our timer driver accuracy we want timer granularity: 1\u00b5s Implementation The required CANopen definitions are simple defines, provided for use in the specification structure below. We need to implement the timer driver granularity in the driver. The following define is used to fill the specification structure in a readable form with all the collected node specification settings: : #define APP_NODE_ID 1u /* CANopen node ID */ #define APP_BAUDRATE 250000u /* CAN baudrate */ #define APP_TICKS_PER_SEC 1000000u /* Timer frequency in Hz */ : CO_NODE_SPEC AppSpec = { APP_NODE_ID , /* default Node-Id */ APP_BAUDRATE , /* default Baudrate */ ( CO_OBJ * ) & ClockOD [ 0 ], /* pointer to object dictionary */ APP_OBJ_N , /* object dictionary max length */ & AppEmcyTbl [ 0 ], /* EMCY code & register bit table */ & TmrMem [ 0 ], /* pointer to timer memory blocks */ APP_TMR_N , /* number of timer memory blocks */ APP_TICKS_PER_SEC , /* timer clock frequency in Hz */ ( CO_IF_DRV * ) & AppDriver , /* select drivers for application */ & SdoSrvMem [ 0 ] /* SDO Transfer Buffer Memory */ }; Clock HW # Description For connecting the CANopen stack to your microcontroller hardware, you need drivers for CAN controller, a hardware timer and a non-volatile memory. You find the connection setup in the file src/app/clock_hw.c . Implementation You can use a chip-vendor provided HAL for the implementation of the drivers, or use direct register access to perform the required actions - whatever you like. This example project provides drivers, using the ST Microelectronics HAL layer. First we select and connect a set of drivers to the CANopen stack: : /* select application drivers */ #include \"drv_can1_stm32f7xx.h\" /* CAN driver (CAN1) */ #include \"drv_timer2_stm32f7xx.h\" /* Timer driver (TIM2) */ #include \"drv_nvm_i2c1_at24c256.h\" /* NVM driver (AT24C256 via I2C1) */ : struct CO_IF_DRV_T AppDriver = { & STM32F7xxCan1Driver , & STM32F7xxTimer2Driver , & I2C1_AT24C256NvmDriver }; : When you write your device driver, you will need to set up a hardware timer interrupt within your low-level layer and configure a periodic interrupt source with a frequency of APP_TICKS_PER_SEC . The timer interrupt service handler should look something like this: /* ST HAL TIM2 overflow interrupt callback */ void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htmr ) { /* collect elapsed timed actions */ COTmrService ( & Clk . Tmr ); } Furthermore, the CAN bus message reception should work with receive interrupts to avoid loosing messages. The CAN receive interrupt handler should look similar to: /* ST HAL CAN receive interrupt callback */ void HAL_CAN_RxFifo0MsgPendingCallback ( CAN_HandleTypeDef * hcan ) { /* process CAN frame with CANopen protocol */ CONodeProcess ( & Clk ); } Clock App # The CANopen application is realized in functions, reflecting two phases of the application: Application Startup - where initialization of hardware and CANopen layer takes place. The function holds the background loop for processing timer events. Application Callback - the cyclic started function holding the running application. The application for this tiny example is implemented in a single file: src/app/clock_app.c . Application Start # Description This function is responsible for the CANopen Stack startup. The startup needs to connect the CANopen Stack layer with the filled specification structure: CONodeInit ( & Clk , ( CO_NODE_SPEC * ) & AppSpec ); if ( CONodeGetErr ( & Clk ) != CO_ERR_NONE ) { while ( 1 ); } We use CANopen software timer to create a cyclic function call to the callback function AppClock() with a period of 1s (equal: 1000ms): ticks = COTmrGetTicks ( & Clk . Tmr , 1000 , CO_TMR_UNIT_1MS ); COTmrCreate ( & Clk . Tmr , 0 , ticks , AppClock , & Clk ); Finally, we start the CANopen node and set it automatically to NMT mode: 'OPERATIONAL': CONodeStart ( & Clk ); CONmtSetMode ( & Clk . Nmt , CO_OPERATIONAL ); Application Callback # The timer callback function AppClock() includes the main functionality of the clock node: /* timer callback function, called every 1000ms */ static void AppClock ( void * p_arg ) { CO_NODE * node ; CO_OBJ * od_sec ; CO_OBJ * od_min ; CO_OBJ * od_hr ; uint8_t second ; uint8_t minute ; uint32_t hour ; /* For flexible usage (not needed, but nice to show), we use the argument * as reference to the CANopen node object. If no node is given, we ignore * the function call by returning immediatelly. */ node = ( CO_NODE * ) p_arg ; if ( node == 0 ) { return ; } /* Main functionality: when we are in operational mode, we get the current * clock values out of the object dictionary, increment the seconds and * update all clock values in the object dictionary. */ if ( CONmtGetMode ( & node -> Nmt ) == CO_OPERATIONAL ) { od_sec = CODictFind ( & node -> Dict , CO_DEV ( 0x2100 , 3 )); od_min = CODictFind ( & node -> Dict , CO_DEV ( 0x2100 , 2 )); od_hr = CODictFind ( & node -> Dict , CO_DEV ( 0x2100 , 1 )); COObjRdValue ( od_sec , node , ( void * ) & second , sizeof ( second )); COObjRdValue ( od_min , node , ( void * ) & minute , sizeof ( minute )); COObjRdValue ( od_hr , node , ( void * ) & hour , sizeof ( hour )); second ++ ; if ( second >= 60 ) { second = 0 ; minute ++ ; } if ( minute >= 60 ) { minute = 0 ; hour ++ ; } COObjWrValue ( od_hr , node , ( void * ) & hour , sizeof ( hour )); COObjWrValue ( od_min , node , ( void * ) & minute , sizeof ( minute )); COObjWrValue ( od_sec , node , ( void * ) & second , sizeof ( second )); } } Info The last write access with COObjWrValue() triggers the asynchronous transmission of the PDO, because the corresponding object entry is defined with the object property flag A .","title":"Quickstart Example"},{"location":"start/quickstart/#quickstart","text":"The quickstart example describes in detail the steps to build a CANopen node. The source files are included in the example repository canopen-stm32f7xx . To get most out of this artice, you should clone this repository and follow in the real files during reading this article. For setting up the hardware and software environment, please follow the README.md in the root of the example repository canopen-stm32f7xx .","title":"Quickstart"},{"location":"start/quickstart/#functional-specification","text":"In this quickstart example, we will create a CANopen Clock . This clock is not a serious application, the example just illustrates the key principles of creating a device using the CANopen Stack. The CANopen clock shall measure the time while the device is switched to OPERATIONAL mode. In OPERATIONAL mode, the node will transmit a PDO every second. The SDO server allows access to the device information at any time.","title":"Functional Specification"},{"location":"start/quickstart/#architectural-overview","text":"The following figure shows the layered architecture of the CANopen Clock device and the related directories. The following descriptions explains in detail the important parts of the directory src/app/... . All other directories and files are described within the source files. The directory src/app/... contains three modules: clock_spec.c/h - this module configures the CANopen Stack layer clock_hw.c/h - this module connects the CANopen Stack layer to the hardware clock_app.c/h - this module includes the CANopen application","title":"Architectural Overview"},{"location":"start/quickstart/#clock-spec","text":"The main settings of the node are configured inside the CO_NODE_SPEC struct. This struct is not used or modified after initialization is finished. This allows you to declared this structure as a constant. Due to the fact, that the central element of a CANopen node is the object dictionary, we start with the description of the specification of our object dictionary. You find the specification in the file src/app/clock_spec.c .","title":"Clock Spec"},{"location":"start/quickstart/#object-dictionary","text":"Description To keep the software as simple as possible, we will use a static object dictionary. In this case, the object dictionary is an array of object entries, declared as a constant array of object entries of type CO_OBJ . Implementation : #define APP_OBJ_N 128u /* Object dictionary max size */ : /* define the static object dictionary */ const CO_OBJ ClockOD [ APP_OBJ_N ] = { : /* here is your array of object entries */ : CO_OBJ_DICT_ENDMARK /* mark end of used objects */ }; :","title":"Object Dictionary"},{"location":"start/quickstart/#mandatory-object-entries","text":"Description When we want to achieve compliance with the CiA301 specification, the object dictionary must hold some mandatory object entries: Index:sub Type Access Value Description 1000h:00 UNSIGNED32 Const 0 Device Type 1001h:00 UNSIGNED8 Read-only 0 Error Register 1014h:00 UNSIGNED32 Const 80h + node ID COB-ID EMCY 1017h:00 UNSIGNED16 Read-Write 0 Heartbeat Producer 1018h:00 UNSIGNED8 Const 4 Identity Object 1018h:01 UNSIGNED32 Const 0 - Vendor ID 1018h:02 UNSIGNED32 Const 0 - Product code 1018h:03 UNSIGNED32 Const 0 - Revision number 1018h:04 UNSIGNED32 Const 0 - Serial number Implementation The configuration of each object entry is a single configuration line within the object dictionary CO_OBJ array. The following figure shows how a single line is constructed: The CO_KEY macro creates out of \" index, subindex \" and the \" property flags \" the unique object entry key, which is used for addressing an object entry. The property flags are a collection of type settings (more details, see in Configuration / Property Flags ). A letter indicates ON , while an underscore ( _ ) at the same place indicates OFF : RW - The access mode flags (read, write by network) NAP - The object type flags (node-id considered, asynchronous trigger, PDO mappable) D - The direct storage flag (used to store the value directly in the object data field) The object type references the object type functions for this object entry. The object data is a pointer to the object entry data (or in some cases a object data structure). What kind of data the object type requires, is listed in Configuration / Object Type Interface . With this knowledge, the mandatory entries are added with the following lines of code: : { CO_KEY ( 0x1000 , 0 , CO_OBJ_____R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1000_00_20 )}, { CO_KEY ( 0x1001 , 0 , CO_OBJ_____R_ ), CO_TUNSIGNED8 , ( CO_DATA )( & Obj1001_00_08 )}, { CO_KEY ( 0x1014 , 0 , CO_OBJ__N__R_ ), CO_TEMCY_ID , ( CO_DATA )( & Obj1014_00_20 )}, { CO_KEY ( 0x1017 , 0 , CO_OBJ_____RW ), CO_THB_PROD , ( CO_DATA )( & Obj1017_00_10 )}, { CO_KEY ( 0x1018 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 4 ) }, { CO_KEY ( 0x1018 , 1 , CO_OBJ_____R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1018_01_20 )}, { CO_KEY ( 0x1018 , 2 , CO_OBJ_____R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1018_02_20 )}, { CO_KEY ( 0x1018 , 3 , CO_OBJ_____R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1018_03_20 )}, { CO_KEY ( 0x1018 , 4 , CO_OBJ_____R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1018_04_20 )}, : Important The CANopen Stack relies on a binary search algorithm to ensure that object dictionary entries are found quickly. Because of this, you must keep the index / subindex of all entries in the object dictionary sorted in ascending order. Most of these entries are constant. We can place their values in read-only FLASH memory. This is not the case for the error register object 1001h and the heartbeat producer 1017h . These entries may change during runtime. Therefore, we need to declare global variables in RAM memory to hold the runtime value of these entries: /* allocate variables for dynamic runtime value in RAM */ uint8_t Obj1001_00_08 = 0 ; uint16_t Obj1017_00_08 = 0 ; /* allocate variables for constant values in FLASH */ const uint32_t Obj1000_00_20 = 0x00000000L ; const uint32_t Obj1014_00_20 = 0x00000080L ; const uint32_t Obj1018_01_20 = 0x00000000L ; const uint32_t Obj1018_02_20 = 0x00000000L ; const uint32_t Obj1018_03_20 = 0x00000000L ; const uint32_t Obj1018_04_20 = 0x00000000L ; A pointer to the variables and constants are stored in the corresponding object dictionary entry. The subindex 0 of the object record 1018h holds a single byte which is constant. We can store the value directly in the object data field (so we need no constant variable) and set the D flag in the properties (compare: CO_OBJ_D___R_ vs. CO_OBJ_____R_ - and be careful when specify your object entries). Important When using architectures with pointer types lower than 32bit (e.g. 16bit microcontrollers), you can store only values up to the pointer width directly in the object dictionary. For larger values declare a constant variable and place a pointer to this constant into the object dictionary! ```","title":"Mandatory Object Entries"},{"location":"start/quickstart/#sdo-server","text":"Description The settings for the SDO server are defined in CiA301 and must contain the following object dictionary entries: Index:sub Type Access Value Description 1200h:00 UNSIGNED8 Const 2 Communication Object SDO Server 1200h:01 UNSIGNED32 Const 600h + node ID - SDO Server Request COBID 1200h:02 UNSIGNED32 Const 580h + node ID - SDO Server Response COBID Implementation The following lines add the SDO server entries to the object dictionary: /* allocate variables for constant values in FLASH */ const uint32_t Obj1200_01_20 = CO_COBID_SDO_REQUEST (); const uint32_t Obj1200_02_20 = CO_COBID_SDO_RESPONSE (); : /* within object dictionary */ { CO_KEY ( 0x1200 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 2 )}, { CO_KEY ( 0x1200 , 1 , CO_OBJ__N__R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1200_01_20 )}, { CO_KEY ( 0x1200 , 2 , CO_OBJ__N__R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1200_02_20 )}, : The predefined COBIDs are dependent on the actual node ID. For this reason, the CANopen stack allows you to specify entries whose value depends on the current node ID at runtime. This behavior is specified using the N flag in the CO_OBJ__N__R_ properties.","title":"SDO Server"},{"location":"start/quickstart/#application-object-entries","text":"Description We need to add some manufacturer specific object entries to support the clock of the example application: Index:sub Type Access Value Description 2100h:00 UNSIGNED8 Const 3 Clock Object 2100h:01 UNSIGNED32 Read Only 0 - Hour 2100h:02 UNSIGNED8 Read Only 0 - Minute 2100h:03 UNSIGNED8 Read Only 0 - Second Info These entries are placed within the manufacturer-specific area (from 2000h up to 5FFFh ) and can be chosen freely (see CiA301). Entries outside of this range cannot be chosen freely, and should conform to the various CiA standards and profiles (e.g. CiA301 for communication profile area, CiA401 for generic IO modules, etc). Implementation These entries are created using the following lines of code: /* allocate variables for dynamic runtime value in RAM */ uint32_t Obj2100_01_20 = 0 ; uint8_t Obj2100_02_08 = 0 ; uint8_t Obj2100_03_08 = 0 ; : /* within object dictionary */ { CO_KEY ( 0x2100 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 3 )}, { CO_KEY ( 0x2100 , 1 , CO_OBJ____PR_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj2100_01_20 )}, { CO_KEY ( 0x2100 , 2 , CO_OBJ____PR_ ), CO_TUNSIGNED8 , ( CO_DATA )( & Obj2100_02_08 )}, { CO_KEY ( 0x2100 , 3 , CO_OBJ___APR_ ), CO_TUNSIGNED8 , ( CO_DATA )( & Obj2100_03_08 )}, : The flag CO_OBJ___A___ for the object entry 2100h:03 enables the \" asynchronous transmission trigger \" for PDOs. This means: when changing the value of this object entry, all PDOs with an active mapping to this object are triggered for transmission. We use this mechanism to achieve the PDO transmission on each write access to the second. Important The asynchronous transmission trigger is provided for the basic type functions: CO_TUNSIGNED8 , CO_TSIGNED8 , CO_TUNSIGNED16 , CO_TSIGNED16 , CO_TUNSIGNED32 and CO_TSIGNED32 .","title":"Application Object Entries"},{"location":"start/quickstart/#tpdo-communication","text":"Description The communication settings for the TPDO must contain the following object entries: Index:sub Type Access Value Description 1800h:00 UNSIGNED8 Const 2 Communication Object TPDO #0 1800h:01 UNSIGNED32 Const 40000180h + node ID - PDO transmission COBID (no RTR) 1800h:02 UNSIGNED8 Const 254 - PDO transmission type Implementation See the following lines in the object dictionary: /* allocate variables for constant values in FLASH */ const uint32_t Obj1800_01_20 = CO_COBID_TPDO_DEFAULT ( 0 ); : /* within object dictionary */ { CO_KEY ( 0x1800 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 2 ) }, { CO_KEY ( 0x1800 , 1 , CO_OBJ__N__R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1800_01_20 )}, { CO_KEY ( 0x1800 , 2 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 254 ) }, : The CANopen stack does not support remote CAN frames as they are no longer recommended for new devices. The use of RTR frames in CANopen devices has been deprecated for many years now. Bit 30 in 1800h:01 indicates that a remote transfer request (RTR) is not allowed for this PDO. The CAN identifier 180h + node-ID is the recommended value from the pre-defined connection set.","title":"TPDO Communication"},{"location":"start/quickstart/#tpdo-data-mapping","text":"Description The mapping settings for the TPDO must contain the following object entries: Index:sub Type Access Value Description 1A00h:00 UNSIGNED8 Const 3 Mapping Object TPDO #0 1A00h:01 UNSIGNED32 Const 21000120h - map: 32-bit clock hour 1A00h:02 UNSIGNED32 Const 21000208h - map: 8-bit clock minute 1A00h:03 UNSIGNED32 Const 21000308h - map: 8-bit clock second How we get these values is explained in section configuration of PDO mapping . Implementation This way of defining the payload for PDOs is part of the CiA301 standard and leads us to the following lines in the object dictionary: /* allocate variables for constant values in FLASH */ const uint32_t Obj1A00_01_20 = CO_LINK ( 0x2100 , 0x01 , 32 ); const uint32_t Obj1A00_02_20 = CO_LINK ( 0x2100 , 0x02 , 8 ); const uint32_t Obj1A00_03_20 = CO_LINK ( 0x2100 , 0x03 , 8 ); : /* within object dictionary */ { CO_KEY ( 0x1A00 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 3 ) }, { CO_KEY ( 0x1A00 , 1 , CO_OBJ_____R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1A00_01_20 )}, { CO_KEY ( 0x1A00 , 2 , CO_OBJ_____R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1A00_02_20 )}, { CO_KEY ( 0x1A00 , 3 , CO_OBJ_____R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & Obj1A00_03_20 )}, :","title":"TPDO Data Mapping"},{"location":"start/quickstart/#emcy-error-specification","text":"Description We want to send a EMCY message, when we detect a hardware error (e.g. an unplugged EEPROM). The EMCY error code and error register flag is defined in the following table: EMCY ID Error Register ( 1001h ) EMCY Code APP_ERR_ID_EEPROM Bit 0 ( CO_EMCY_REG_GENERAL ) 0x5000 ( CO_EMCY_CODE_HW_ERR ) Implementation We define all possible identifiers as a handy enumeration. enum { APP_ERR_ID_EEPROM = 0 , APP_ERR_ID_NUM /* number of EMCYs in application */ }; The CANopen stack behavior for each of these EMCY identifier is defined in an EMCY table. Here we define the related error register bit and the EMCY code. The defines CO_EMCY_REG_... for the error register bits and CO_EMCY_CODE_... for the EMCY code base values are specified values out of the CANopen specification. static CO_EMCY_TBL AppEmcyTbl [ APP_ERR_ID_NUM ] = { { CO_EMCY_REG_GENERAL , CO_EMCY_CODE_HW_ERR } /* APP_ERR_ID_EEPROM */ }; Possible extension With these enumerations in place, we can call the EMCY service functions in our application. For example we can add the following line at the end of the clock application to store the operational time in hh:mm : : /* store operational time (hour and minute) in NVM */ if ( second == 0 ) { uint32_t num ; num = COIfNvmWrite ( & Clk . If , 0 , & hour , 4 ); num += COIfNvmWrite ( & Clk . If , 0 , & minute , 1 ); if ( num != 5 ) { COEmcySet ( & Clk . Emcy , APP_ERR_ID_EEPROM , 0 ); /*no user data*/ } else { COEmcyClr ( & Clk . Emcy , APP_ERR_ID_EEPROM ); } } Reading the stored value during startup, or data protection with 2 toggling storage locations is left as training for you.","title":"EMCY Error Specification"},{"location":"start/quickstart/#canopen-timers","text":"Description The CANopen stack provides flexible timers for protocol and application usage. Implementation Each software timer needs some memory for managing the lists and states of the timed action events: : #define APP_TMR_N 16u /* Number of software timers */ : CO_TMR_MEM TmrMem [ APP_TMR_N ]; /* Allocate timer memory */ :","title":"CANopen Timers"},{"location":"start/quickstart/#sdo-server-buffers","text":"Description The CANopen node requires for each SDO server a certain amount of transmission buffers, in case the client is using segmented or block transfers to access large objects. Implementation Each SDO server needs memory for the segmented or block transfer requests. uint8_t SdoSrvMem [ CO_SSDO_N * CO_SDO_BUF_BYTE ];","title":"SDO Server Buffers"},{"location":"start/quickstart/#fill-the-specification-structure","text":"Description We want to act the CANopen node with a NodeId of 1 , and a CAN network baudrate of 250kBaud For our timer driver accuracy we want timer granularity: 1\u00b5s Implementation The required CANopen definitions are simple defines, provided for use in the specification structure below. We need to implement the timer driver granularity in the driver. The following define is used to fill the specification structure in a readable form with all the collected node specification settings: : #define APP_NODE_ID 1u /* CANopen node ID */ #define APP_BAUDRATE 250000u /* CAN baudrate */ #define APP_TICKS_PER_SEC 1000000u /* Timer frequency in Hz */ : CO_NODE_SPEC AppSpec = { APP_NODE_ID , /* default Node-Id */ APP_BAUDRATE , /* default Baudrate */ ( CO_OBJ * ) & ClockOD [ 0 ], /* pointer to object dictionary */ APP_OBJ_N , /* object dictionary max length */ & AppEmcyTbl [ 0 ], /* EMCY code & register bit table */ & TmrMem [ 0 ], /* pointer to timer memory blocks */ APP_TMR_N , /* number of timer memory blocks */ APP_TICKS_PER_SEC , /* timer clock frequency in Hz */ ( CO_IF_DRV * ) & AppDriver , /* select drivers for application */ & SdoSrvMem [ 0 ] /* SDO Transfer Buffer Memory */ };","title":"Fill the Specification Structure"},{"location":"start/quickstart/#clock-hw","text":"Description For connecting the CANopen stack to your microcontroller hardware, you need drivers for CAN controller, a hardware timer and a non-volatile memory. You find the connection setup in the file src/app/clock_hw.c . Implementation You can use a chip-vendor provided HAL for the implementation of the drivers, or use direct register access to perform the required actions - whatever you like. This example project provides drivers, using the ST Microelectronics HAL layer. First we select and connect a set of drivers to the CANopen stack: : /* select application drivers */ #include \"drv_can1_stm32f7xx.h\" /* CAN driver (CAN1) */ #include \"drv_timer2_stm32f7xx.h\" /* Timer driver (TIM2) */ #include \"drv_nvm_i2c1_at24c256.h\" /* NVM driver (AT24C256 via I2C1) */ : struct CO_IF_DRV_T AppDriver = { & STM32F7xxCan1Driver , & STM32F7xxTimer2Driver , & I2C1_AT24C256NvmDriver }; : When you write your device driver, you will need to set up a hardware timer interrupt within your low-level layer and configure a periodic interrupt source with a frequency of APP_TICKS_PER_SEC . The timer interrupt service handler should look something like this: /* ST HAL TIM2 overflow interrupt callback */ void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htmr ) { /* collect elapsed timed actions */ COTmrService ( & Clk . Tmr ); } Furthermore, the CAN bus message reception should work with receive interrupts to avoid loosing messages. The CAN receive interrupt handler should look similar to: /* ST HAL CAN receive interrupt callback */ void HAL_CAN_RxFifo0MsgPendingCallback ( CAN_HandleTypeDef * hcan ) { /* process CAN frame with CANopen protocol */ CONodeProcess ( & Clk ); }","title":"Clock HW"},{"location":"start/quickstart/#clock-app","text":"The CANopen application is realized in functions, reflecting two phases of the application: Application Startup - where initialization of hardware and CANopen layer takes place. The function holds the background loop for processing timer events. Application Callback - the cyclic started function holding the running application. The application for this tiny example is implemented in a single file: src/app/clock_app.c .","title":"Clock App"},{"location":"start/quickstart/#application-start","text":"Description This function is responsible for the CANopen Stack startup. The startup needs to connect the CANopen Stack layer with the filled specification structure: CONodeInit ( & Clk , ( CO_NODE_SPEC * ) & AppSpec ); if ( CONodeGetErr ( & Clk ) != CO_ERR_NONE ) { while ( 1 ); } We use CANopen software timer to create a cyclic function call to the callback function AppClock() with a period of 1s (equal: 1000ms): ticks = COTmrGetTicks ( & Clk . Tmr , 1000 , CO_TMR_UNIT_1MS ); COTmrCreate ( & Clk . Tmr , 0 , ticks , AppClock , & Clk ); Finally, we start the CANopen node and set it automatically to NMT mode: 'OPERATIONAL': CONodeStart ( & Clk ); CONmtSetMode ( & Clk . Nmt , CO_OPERATIONAL );","title":"Application Start"},{"location":"start/quickstart/#application-callback","text":"The timer callback function AppClock() includes the main functionality of the clock node: /* timer callback function, called every 1000ms */ static void AppClock ( void * p_arg ) { CO_NODE * node ; CO_OBJ * od_sec ; CO_OBJ * od_min ; CO_OBJ * od_hr ; uint8_t second ; uint8_t minute ; uint32_t hour ; /* For flexible usage (not needed, but nice to show), we use the argument * as reference to the CANopen node object. If no node is given, we ignore * the function call by returning immediatelly. */ node = ( CO_NODE * ) p_arg ; if ( node == 0 ) { return ; } /* Main functionality: when we are in operational mode, we get the current * clock values out of the object dictionary, increment the seconds and * update all clock values in the object dictionary. */ if ( CONmtGetMode ( & node -> Nmt ) == CO_OPERATIONAL ) { od_sec = CODictFind ( & node -> Dict , CO_DEV ( 0x2100 , 3 )); od_min = CODictFind ( & node -> Dict , CO_DEV ( 0x2100 , 2 )); od_hr = CODictFind ( & node -> Dict , CO_DEV ( 0x2100 , 1 )); COObjRdValue ( od_sec , node , ( void * ) & second , sizeof ( second )); COObjRdValue ( od_min , node , ( void * ) & minute , sizeof ( minute )); COObjRdValue ( od_hr , node , ( void * ) & hour , sizeof ( hour )); second ++ ; if ( second >= 60 ) { second = 0 ; minute ++ ; } if ( minute >= 60 ) { minute = 0 ; hour ++ ; } COObjWrValue ( od_hr , node , ( void * ) & hour , sizeof ( hour )); COObjWrValue ( od_min , node , ( void * ) & minute , sizeof ( minute )); COObjWrValue ( od_sec , node , ( void * ) & second , sizeof ( second )); } } Info The last write access with COObjWrValue() triggers the asynchronous transmission of the PDO, because the corresponding object entry is defined with the object property flag A .","title":"Application Callback"},{"location":"start/structure/","text":"Structure # Layout of Repository # The following description explains the included directories of the repository canopen-stack in the released package. root +- src : --- CANopen Stack source code --- | +- config : configuration files | +- core : core services | +- hal : hardware abstraction interface | +- object : object type functions | | +- basic : basic types | | +- cia301 : CiA301 types | +- service : protocol service files | | +- cia301 : standard protocols | | +- cia305 : layer setting service Info When cloning the CANopen Stack repository, you need the src directory tree only. The repository contains in addition a test directory with a collection of unit- and integration-tests running on the host. Directory: config # This directory contains the configuration of the CANopen Stack. The intended purpose is to create a library with your cross-compiler with all source files in the directory src and a specific configuration, defined in the file co_cfg.h : mandatory settings - CO_SSDO_N : maximum number of possible SDO servers (default: 1) - CO_CSDO_N : maximum number of possible SDO clients (default: 1) - CO_TPDO_N : maximum number of possible TPDOs (default: 4) - CO_RPDO_N : maximum number of possible RPDOs (default: 4) - CO_EMCY_N : maximum number of possible emergency codes (default: 32) settings for optimizing resource usage - USE_LSS : enable/disable support for LSS functionality (default: 1) - USE_CSDO : enable/disable support for SDO clients (default: 1) Directory: core # This directory holds the general CANopen functions, which are implemented according the specification Cia301. Directory: hal # This directory holds a common interface definition used within the CANopen stack to access different chip vendor hardware abstraction layers via drivers . The drivers are not included in this directory, they are part of the target specific project. (see an example in canopen-stm32f7xx ). Directory: object # This directory includes the implementation of object type functions. The subdirectory basic includes the basic data types, which handles values in object dictionary entries. Other subdirectories (e.g. cia301 ) includes object types, which performs some kind of functionality during reading or writing from/to the object entry. The name of the subdirectory describes the source of specification for this object type. Directory: service # This directory holds the implementation of CAN protocols. The subdirectory cia301 and cia305 describes the source of specification for the included protocols.","title":"Repository Structure"},{"location":"start/structure/#structure","text":"","title":"Structure"},{"location":"start/structure/#layout-of-repository","text":"The following description explains the included directories of the repository canopen-stack in the released package. root +- src : --- CANopen Stack source code --- | +- config : configuration files | +- core : core services | +- hal : hardware abstraction interface | +- object : object type functions | | +- basic : basic types | | +- cia301 : CiA301 types | +- service : protocol service files | | +- cia301 : standard protocols | | +- cia305 : layer setting service Info When cloning the CANopen Stack repository, you need the src directory tree only. The repository contains in addition a test directory with a collection of unit- and integration-tests running on the host.","title":"Layout of Repository"},{"location":"start/structure/#directory-config","text":"This directory contains the configuration of the CANopen Stack. The intended purpose is to create a library with your cross-compiler with all source files in the directory src and a specific configuration, defined in the file co_cfg.h : mandatory settings - CO_SSDO_N : maximum number of possible SDO servers (default: 1) - CO_CSDO_N : maximum number of possible SDO clients (default: 1) - CO_TPDO_N : maximum number of possible TPDOs (default: 4) - CO_RPDO_N : maximum number of possible RPDOs (default: 4) - CO_EMCY_N : maximum number of possible emergency codes (default: 32) settings for optimizing resource usage - USE_LSS : enable/disable support for LSS functionality (default: 1) - USE_CSDO : enable/disable support for SDO clients (default: 1)","title":"Directory: config"},{"location":"start/structure/#directory-core","text":"This directory holds the general CANopen functions, which are implemented according the specification Cia301.","title":"Directory: core"},{"location":"start/structure/#directory-hal","text":"This directory holds a common interface definition used within the CANopen stack to access different chip vendor hardware abstraction layers via drivers . The drivers are not included in this directory, they are part of the target specific project. (see an example in canopen-stm32f7xx ).","title":"Directory: hal"},{"location":"start/structure/#directory-object","text":"This directory includes the implementation of object type functions. The subdirectory basic includes the basic data types, which handles values in object dictionary entries. Other subdirectories (e.g. cia301 ) includes object types, which performs some kind of functionality during reading or writing from/to the object entry. The name of the subdirectory describes the source of specification for this object type.","title":"Directory: object"},{"location":"start/structure/#directory-service","text":"This directory holds the implementation of CAN protocols. The subdirectory cia301 and cia305 describes the source of specification for the included protocols.","title":"Directory: service"},{"location":"usage/actions/","text":"Timed Actions # CANopen Timer # The CANopen stack provides service functions for performing timed actions on the application or the profile-specific events. For timed actions the service function group COTmr\u2026() is provided. Event Time Base # To establishing a constant time base, the CANopen stack provides a service function. For generating a time base, the following line should be placed in a hardware timer interrupt service function, which is called periodically: COTmrService ( & demo ); /* trigger time event */ The following diagram shows the internal behavior of this service: sequenceDiagram participant H as Hardware Timer participant T as demo.Tmr H->>+T: COTmrService() alt elapsed timer note over T: store elapsed timer end T-->>-H: ok Action Processing # The CANopen stack handles the storage and order of timed actions internally. For the execution of the timed functions a service function is provided. For processing the elapsed timer actions, the following line should be placed in a loop within the background function: COTmrProcess ( & demo ); /* process timed action(s) */ The following diagram shows the internal behavior of this service: sequenceDiagram participant A as Application participant T as demo.Tmr A->>+T: COTmrProcess() loop all elapsed timer T->>+A: call action callback A-->>-T: ok end T-->>-A: ok Note: The CANopen stack uses the timed actions for standardized timed actions. In this case the shown ActionCallback function is an internal CANopen stack function.","title":"Timed Actions"},{"location":"usage/actions/#timed-actions","text":"","title":"Timed Actions"},{"location":"usage/actions/#canopen-timer","text":"The CANopen stack provides service functions for performing timed actions on the application or the profile-specific events. For timed actions the service function group COTmr\u2026() is provided.","title":"CANopen Timer"},{"location":"usage/actions/#event-time-base","text":"To establishing a constant time base, the CANopen stack provides a service function. For generating a time base, the following line should be placed in a hardware timer interrupt service function, which is called periodically: COTmrService ( & demo ); /* trigger time event */ The following diagram shows the internal behavior of this service: sequenceDiagram participant H as Hardware Timer participant T as demo.Tmr H->>+T: COTmrService() alt elapsed timer note over T: store elapsed timer end T-->>-H: ok","title":"Event Time Base"},{"location":"usage/actions/#action-processing","text":"The CANopen stack handles the storage and order of timed actions internally. For the execution of the timed functions a service function is provided. For processing the elapsed timer actions, the following line should be placed in a loop within the background function: COTmrProcess ( & demo ); /* process timed action(s) */ The following diagram shows the internal behavior of this service: sequenceDiagram participant A as Application participant T as demo.Tmr A->>+T: COTmrProcess() loop all elapsed timer T->>+A: call action callback A-->>-T: ok end T-->>-A: ok Note: The CANopen stack uses the timed actions for standardized timed actions. In this case the shown ActionCallback function is an internal CANopen stack function.","title":"Action Processing"},{"location":"usage/architecture/","text":"Device Architecture # Standard Architecture # The architecture of a CANopen device is standardized and shown in the following figure: Object Dictionary # The central component in a CANopen device is the Object Directory (OD) . The OD is organized as a table with object entries. Each Entry is addressed with a unique combination of Index and SubIdx . The index is a 16 bit value (from 0...0xFFFF), and the sub-index is a 8 bit value (from 0...0xFF). Within the CANopen standard, the layout and usage of many object entries is specified and marked as mandatory , optional or manufacturer-specific . The following table shows an overview of the OD areas: Index Content 0x0000 Reserved 0x0001 \u2013 0x025F Data types 0x0260 \u2013 0x0FFF Reserved 0x1000 \u2013 0x1FFF Communication profile area 0x2000 \u2013 0x5FFF Manufacturer specific profile area 0x6000 \u2013 0x9FFF Standardized device profile area 0xA000 \u2013 0xBFFF Standardized interface profile area 0xC000 \u2013 0xFFFF Reserved Communication Unit # The Communication Unit (CU) uses the OD to set and get configuration settings, inform the device application about new received process data and transmit the device process data to the CAN network. For the different requirements of these activities, different CANopen protocol elements are specified. The CU takes care of all necessary operations to be compliant with the CANopen standard. The following table shows an overview of the CU modules and their responsibility: CU Module Responsibility NMT Network Management SDO Service Data Object Transfer PDO Process Data Object Transfer SYNC Synchronization Module EMCY Emergency Transfer TIME Time Management Network Management # The Network Management State Machine (NMT) of all CANopen devices within a CANopen network is controlled by the CANopen network master. The following state machine is specified: Within this state machine, the state transitions with a number (e.g. [129]) will be activated with a network management command equal to this number. If no transition criteria is stated, the transition will be activated after finished state operations automatically. The following table summarizes the network management commands: NMT Command Description 1 Start remote node 2 Stop remote node 128 Enter \"Pre-Operational\" state 129 Reset node 130 Reset communication These NMT commands used by the CANopen network boot-up master to control the network. During the different states, the listed communication services are allowed: Init Pre-Op. Operational Stop Boot-Up Object X NMT Object X X X SDO Transfer X X SYNC Object X X Time Stamp Object X X Emergency Object X X PDO Transfer X Note: The Boot-Up message is sent only once during the transition from Initialization to Pre-Operational .","title":"Device Architecture"},{"location":"usage/architecture/#device-architecture","text":"","title":"Device Architecture"},{"location":"usage/architecture/#standard-architecture","text":"The architecture of a CANopen device is standardized and shown in the following figure:","title":"Standard Architecture"},{"location":"usage/architecture/#object-dictionary","text":"The central component in a CANopen device is the Object Directory (OD) . The OD is organized as a table with object entries. Each Entry is addressed with a unique combination of Index and SubIdx . The index is a 16 bit value (from 0...0xFFFF), and the sub-index is a 8 bit value (from 0...0xFF). Within the CANopen standard, the layout and usage of many object entries is specified and marked as mandatory , optional or manufacturer-specific . The following table shows an overview of the OD areas: Index Content 0x0000 Reserved 0x0001 \u2013 0x025F Data types 0x0260 \u2013 0x0FFF Reserved 0x1000 \u2013 0x1FFF Communication profile area 0x2000 \u2013 0x5FFF Manufacturer specific profile area 0x6000 \u2013 0x9FFF Standardized device profile area 0xA000 \u2013 0xBFFF Standardized interface profile area 0xC000 \u2013 0xFFFF Reserved","title":"Object Dictionary"},{"location":"usage/architecture/#communication-unit","text":"The Communication Unit (CU) uses the OD to set and get configuration settings, inform the device application about new received process data and transmit the device process data to the CAN network. For the different requirements of these activities, different CANopen protocol elements are specified. The CU takes care of all necessary operations to be compliant with the CANopen standard. The following table shows an overview of the CU modules and their responsibility: CU Module Responsibility NMT Network Management SDO Service Data Object Transfer PDO Process Data Object Transfer SYNC Synchronization Module EMCY Emergency Transfer TIME Time Management","title":"Communication Unit"},{"location":"usage/architecture/#network-management","text":"The Network Management State Machine (NMT) of all CANopen devices within a CANopen network is controlled by the CANopen network master. The following state machine is specified: Within this state machine, the state transitions with a number (e.g. [129]) will be activated with a network management command equal to this number. If no transition criteria is stated, the transition will be activated after finished state operations automatically. The following table summarizes the network management commands: NMT Command Description 1 Start remote node 2 Stop remote node 128 Enter \"Pre-Operational\" state 129 Reset node 130 Reset communication These NMT commands used by the CANopen network boot-up master to control the network. During the different states, the listed communication services are allowed: Init Pre-Op. Operational Stop Boot-Up Object X NMT Object X X X SDO Transfer X X SYNC Object X X Time Stamp Object X X Emergency Object X X PDO Transfer X Note: The Boot-Up message is sent only once during the transition from Initialization to Pre-Operational .","title":"Network Management"},{"location":"usage/callbacks/","text":"Callback Interface # Application Callback Functions # This chapter gives an overview of the component Callback Interface. The listed functions are available for programming the application-specific reactions on several events of the CANopen device. CONodeFatalError() # This mandatory function is called, after detecting a fatal error within the stack, and no way out of the situation ( panic ). The function is intended to allow the implementation of a pre-defined shutdown sequence and setting the device in a safe state. void CONodeFatalError ( void ) { /* Place here your fatal error handling. * There is most likely a programming error. * !! Please don't ignore this errors. !! */ for (;;); } COTmrLock() # These mandatory function pair is called during timer management and is the right place to add a locking mechanism for the timer management structure. The simplest implementation is disabling and re-enabling the timer hardware interrupt. In more advanced scenarios there could be a timer mutex or spin-lock, depending on the RTOS and number of active cores. void COTmrLock ( void ) { /* This function helps to guarantee the consistancy * of the internal timer management while interrupted * by the used timer interrupt. Most likely you need * at this point on of the following mechanisms: * - disable the used hardware timer interrupt * - get a 'timer-mutex' from your RTOS (ensure to * call COTmrService() in a timer triggered task) */ } void COTmrUnlock ( void ) { /* This function helps to guarantee the consistancy * of the internal timer management while interrupted * by the used timer interrupt. Most likely you need * at this point on of the following mechanisms: * - (re)enable the used hardware timer interrupt * - release the 'timer-mutex' from your RTOS (ensure * to call COTmrService() in a timer triggered task) */ } COIfCanReceive() # This optional function is called for each CAN frame, which is not consumed (processed) by the CANopen stack. The CAN frame pointer is checked to be valid before the CANopen stack calls this function. void COIfCanReceive ( CO_IF_FRM * frm ) { /* Optional: place here some code, which is called * when you need to handle CAN messages, which are * not part of the CANopen protocol. */ } Arguments Parameter Description frm The received CAN frame COLssStore() # This optional function is called with new configuration data, which is set by the LSS service. If the configuration data should stay unchanged, the argument is 0. The CAN frame pointer is checked to be valid before the CANopen stack calls this function. CO_ERR COLssStore ( uint32_t baudrate , uint8_t nodeId ) { /* Optional: place here some code, which is called * when LSS client is in use and the CANopen node * needs to store updated values. */ return ( CO_ERR_NONE ); } Arguments Parameter Description baudrate The configured baudrate for storage nodeId The configured node id for storage Returned Value ==CO_ERR_NONE : configuration stored !=CO_ERR_NONE : error is detected COLssLoad() # This optional function is called during reset communication to load the stored LSS configuration. If no storage for the configuration data is found, the referenced argument should stay unchanged. The CAN frame pointer is checked to be valid before the CANopen stack calls this function. CO_ERR COLssLoad ( uint32_t * baudrate , uint8_t * nodeId ) { /* Optional: place here some code, which is called * when LSS client is in use and the CANopen node * is initialized. */ return ( CO_ERR_NONE ); } Arguments Parameter Description baudrate Reference to the baudrate, which should be set to storage value nodeId Reference to the node-id, which should be set to storage value Returned Value ==CO_ERR_NONE : configuration loaded !=CO_ERR_NONE : error is detected CONmtModeChange() # This optional function is called when the NMT mode is changed. The nmt object pointer is checked to be valid before the CANopen stack calls this function. void CONmtModeChange ( CO_NMT * nmt , CO_MODE mode ) { /* Optional: place here some code, which is called * when a NMT mode change is initiated. */ } Arguments Parameter Description nmt reference to NMT structure mode the new mode CONmtResetRequest() # This optional function is called when the NMT reset is requested via CAN network. The nmt object pointer is checked to be valid before the CANopen stack calls this function. void CONmtResetRequest ( CO_NMT * nmt , CO_NMT_RESET reset ) { /* Optional: place here some code, which is called * when a NMT reset is requested by the network. */ } Arguments Parameter Description nmt reference to NMT structure reset the requested reset type CONmtHbConsEvent() # This optional function is called when a heartbeat consumer monitor timer elapses, before receiving the corresponding heartbeat message. The node pointer is checked to be valid before the CANopen stack calls this function. void CONmtHbConsEvent ( CO_NMT * nmt , uint8_t nodeId ) { /* Optional: place here some code, which is called * called when heartbeat consumer is in use and * detects an error on monitored node(s). */ } Arguments Parameter Description nmt reference to NMT structure nodeId The nodeId of the missed heartbeat message CONmtHbConsChange() # This optional function is called when a heartbeat consumer monitor detects a state change, of a monitored node. The node pointer is checked to be valid before the CANopen stack calls this function. void CONmtHbConsChange ( CO_NMT * nmt , uint8_t nodeId , CO_MODE mode ) { /* Optional: place here some code, which is called * when heartbeat consumer is in use and detects a * NMT state change on monitored node(s). */ } Arguments Parameter Description nmt reference to NMT structure nodeId The nodeId of the monitored node mode The new received node state of the monitored node COPdoTransmit() # This optional function is called just before the PDO transmission will send the PDO message frame to the CANopen network. void COPdoTransmit ( CO_IF_FRM * frm ) { /* Optional: place here some code, which is called * just before a PDO is transmitted. You may adjust * the given CAN frame which is send afterwards. */ } Arguments Parameter Description frm Pointer to PDO message frame COPdoReceive() # This optional function is called just before the PDO reception will distribute the PDO message frame into the object dictionary. This callback function is able to consume the PDO message frame, e.g. the distribution into the object dictionary will be skipped. Furthermore without consuming the PDO message frame, this function could modify the received data before distribution takes place. int16_t COPdoReceive ( CO_IF_FRM * frm ) { /* Optional: place here some code, which is called * right after receiving a PDO. You may adjust * the given CAN frame which is written into the * object dictionary afterwards or suppress the * write operation. */ return ( 0u ); } Arguments Parameter Description frm Pointer to received PDO message frame Returned Value =0 : CAN message frame is not consumed >0 : CAN message frame is consumed COPdoSyncUpdate() # This optional function is called after a synchronized PDO is received and the data is distributed into the object dictionary. void COPdoSyncUpdate ( CO_RPDO * pdo ) { /* Optional: place here some code, which is called * right after the object dictionary update due to * a synchronized PDO. */ } Arguments Parameter Description pdo Pointer to received and synchronous processed RPDO COParaDefault() # This optional function will be called during restoring the default values of a parameter group. The function is responsible for setting the factory defaults in the current parameter group memory. The parameter group info pointer is checked to be valid before the CANopen stack calls this function. int16_t COParaDefault ( CO_PARA * pg ) { /* Optional: place here some code, which is called * when a parameter group is restored to factory * settings. */ } Arguments Parameter Description pg Ptr to parameter group info Returned Value =0 : parameter default values successful set <0 : error is detected and function aborted CORpdoWriteData() # This optional function is called during PDO distribution of the PDO message frame into the object dictionary when mapped data value consumes more than 4 bytes. void CORpdoWriteData ( CO_IF_FRM * frm , uint8_t pos , uint8_t size , CO_OBJ * obj ) { /* Optional: place here some code, which is called * when a PDO is received with mapped values with * a size larger than 4 byte. */ } Arguments Parameter Description frm Ptr to PDO message frame pos The start index in the CAN message frame payload size The mapped value size in bytes obj Ptr to the target object entry COTpdoReadData() # This optional function is called during PDO transmission when a mapped data value consumes more than 4 bytes. void COTpdoReadData ( CO_IF_FRM * frm , uint8_t pos , uint8_t size , CO_OBJ * obj ) { /* Optional: place here some code, which is called * when a PDO is constructed for transmission which * needs a mapped values with a size larger than 4 byte. */ } Arguments Parameter Description frm Ptr to PDO message frame pos The start index in the CAN message frame payload size The mapped value size in bytes obj Ptr to the source object entry","title":"Callback Interface"},{"location":"usage/callbacks/#callback-interface","text":"","title":"Callback Interface"},{"location":"usage/callbacks/#application-callback-functions","text":"This chapter gives an overview of the component Callback Interface. The listed functions are available for programming the application-specific reactions on several events of the CANopen device.","title":"Application Callback Functions"},{"location":"usage/callbacks/#conodefatalerror","text":"This mandatory function is called, after detecting a fatal error within the stack, and no way out of the situation ( panic ). The function is intended to allow the implementation of a pre-defined shutdown sequence and setting the device in a safe state. void CONodeFatalError ( void ) { /* Place here your fatal error handling. * There is most likely a programming error. * !! Please don't ignore this errors. !! */ for (;;); }","title":"CONodeFatalError()"},{"location":"usage/callbacks/#cotmrlock","text":"These mandatory function pair is called during timer management and is the right place to add a locking mechanism for the timer management structure. The simplest implementation is disabling and re-enabling the timer hardware interrupt. In more advanced scenarios there could be a timer mutex or spin-lock, depending on the RTOS and number of active cores. void COTmrLock ( void ) { /* This function helps to guarantee the consistancy * of the internal timer management while interrupted * by the used timer interrupt. Most likely you need * at this point on of the following mechanisms: * - disable the used hardware timer interrupt * - get a 'timer-mutex' from your RTOS (ensure to * call COTmrService() in a timer triggered task) */ } void COTmrUnlock ( void ) { /* This function helps to guarantee the consistancy * of the internal timer management while interrupted * by the used timer interrupt. Most likely you need * at this point on of the following mechanisms: * - (re)enable the used hardware timer interrupt * - release the 'timer-mutex' from your RTOS (ensure * to call COTmrService() in a timer triggered task) */ }","title":"COTmrLock()"},{"location":"usage/callbacks/#coifcanreceive","text":"This optional function is called for each CAN frame, which is not consumed (processed) by the CANopen stack. The CAN frame pointer is checked to be valid before the CANopen stack calls this function. void COIfCanReceive ( CO_IF_FRM * frm ) { /* Optional: place here some code, which is called * when you need to handle CAN messages, which are * not part of the CANopen protocol. */ } Arguments Parameter Description frm The received CAN frame","title":"COIfCanReceive()"},{"location":"usage/callbacks/#colssstore","text":"This optional function is called with new configuration data, which is set by the LSS service. If the configuration data should stay unchanged, the argument is 0. The CAN frame pointer is checked to be valid before the CANopen stack calls this function. CO_ERR COLssStore ( uint32_t baudrate , uint8_t nodeId ) { /* Optional: place here some code, which is called * when LSS client is in use and the CANopen node * needs to store updated values. */ return ( CO_ERR_NONE ); } Arguments Parameter Description baudrate The configured baudrate for storage nodeId The configured node id for storage Returned Value ==CO_ERR_NONE : configuration stored !=CO_ERR_NONE : error is detected","title":"COLssStore()"},{"location":"usage/callbacks/#colssload","text":"This optional function is called during reset communication to load the stored LSS configuration. If no storage for the configuration data is found, the referenced argument should stay unchanged. The CAN frame pointer is checked to be valid before the CANopen stack calls this function. CO_ERR COLssLoad ( uint32_t * baudrate , uint8_t * nodeId ) { /* Optional: place here some code, which is called * when LSS client is in use and the CANopen node * is initialized. */ return ( CO_ERR_NONE ); } Arguments Parameter Description baudrate Reference to the baudrate, which should be set to storage value nodeId Reference to the node-id, which should be set to storage value Returned Value ==CO_ERR_NONE : configuration loaded !=CO_ERR_NONE : error is detected","title":"COLssLoad()"},{"location":"usage/callbacks/#conmtmodechange","text":"This optional function is called when the NMT mode is changed. The nmt object pointer is checked to be valid before the CANopen stack calls this function. void CONmtModeChange ( CO_NMT * nmt , CO_MODE mode ) { /* Optional: place here some code, which is called * when a NMT mode change is initiated. */ } Arguments Parameter Description nmt reference to NMT structure mode the new mode","title":"CONmtModeChange()"},{"location":"usage/callbacks/#conmtresetrequest","text":"This optional function is called when the NMT reset is requested via CAN network. The nmt object pointer is checked to be valid before the CANopen stack calls this function. void CONmtResetRequest ( CO_NMT * nmt , CO_NMT_RESET reset ) { /* Optional: place here some code, which is called * when a NMT reset is requested by the network. */ } Arguments Parameter Description nmt reference to NMT structure reset the requested reset type","title":"CONmtResetRequest()"},{"location":"usage/callbacks/#conmthbconsevent","text":"This optional function is called when a heartbeat consumer monitor timer elapses, before receiving the corresponding heartbeat message. The node pointer is checked to be valid before the CANopen stack calls this function. void CONmtHbConsEvent ( CO_NMT * nmt , uint8_t nodeId ) { /* Optional: place here some code, which is called * called when heartbeat consumer is in use and * detects an error on monitored node(s). */ } Arguments Parameter Description nmt reference to NMT structure nodeId The nodeId of the missed heartbeat message","title":"CONmtHbConsEvent()"},{"location":"usage/callbacks/#conmthbconschange","text":"This optional function is called when a heartbeat consumer monitor detects a state change, of a monitored node. The node pointer is checked to be valid before the CANopen stack calls this function. void CONmtHbConsChange ( CO_NMT * nmt , uint8_t nodeId , CO_MODE mode ) { /* Optional: place here some code, which is called * when heartbeat consumer is in use and detects a * NMT state change on monitored node(s). */ } Arguments Parameter Description nmt reference to NMT structure nodeId The nodeId of the monitored node mode The new received node state of the monitored node","title":"CONmtHbConsChange()"},{"location":"usage/callbacks/#copdotransmit","text":"This optional function is called just before the PDO transmission will send the PDO message frame to the CANopen network. void COPdoTransmit ( CO_IF_FRM * frm ) { /* Optional: place here some code, which is called * just before a PDO is transmitted. You may adjust * the given CAN frame which is send afterwards. */ } Arguments Parameter Description frm Pointer to PDO message frame","title":"COPdoTransmit()"},{"location":"usage/callbacks/#copdoreceive","text":"This optional function is called just before the PDO reception will distribute the PDO message frame into the object dictionary. This callback function is able to consume the PDO message frame, e.g. the distribution into the object dictionary will be skipped. Furthermore without consuming the PDO message frame, this function could modify the received data before distribution takes place. int16_t COPdoReceive ( CO_IF_FRM * frm ) { /* Optional: place here some code, which is called * right after receiving a PDO. You may adjust * the given CAN frame which is written into the * object dictionary afterwards or suppress the * write operation. */ return ( 0u ); } Arguments Parameter Description frm Pointer to received PDO message frame Returned Value =0 : CAN message frame is not consumed >0 : CAN message frame is consumed","title":"COPdoReceive()"},{"location":"usage/callbacks/#copdosyncupdate","text":"This optional function is called after a synchronized PDO is received and the data is distributed into the object dictionary. void COPdoSyncUpdate ( CO_RPDO * pdo ) { /* Optional: place here some code, which is called * right after the object dictionary update due to * a synchronized PDO. */ } Arguments Parameter Description pdo Pointer to received and synchronous processed RPDO","title":"COPdoSyncUpdate()"},{"location":"usage/callbacks/#coparadefault","text":"This optional function will be called during restoring the default values of a parameter group. The function is responsible for setting the factory defaults in the current parameter group memory. The parameter group info pointer is checked to be valid before the CANopen stack calls this function. int16_t COParaDefault ( CO_PARA * pg ) { /* Optional: place here some code, which is called * when a parameter group is restored to factory * settings. */ } Arguments Parameter Description pg Ptr to parameter group info Returned Value =0 : parameter default values successful set <0 : error is detected and function aborted","title":"COParaDefault()"},{"location":"usage/callbacks/#corpdowritedata","text":"This optional function is called during PDO distribution of the PDO message frame into the object dictionary when mapped data value consumes more than 4 bytes. void CORpdoWriteData ( CO_IF_FRM * frm , uint8_t pos , uint8_t size , CO_OBJ * obj ) { /* Optional: place here some code, which is called * when a PDO is received with mapped values with * a size larger than 4 byte. */ } Arguments Parameter Description frm Ptr to PDO message frame pos The start index in the CAN message frame payload size The mapped value size in bytes obj Ptr to the target object entry","title":"CORpdoWriteData()"},{"location":"usage/callbacks/#cotpdoreaddata","text":"This optional function is called during PDO transmission when a mapped data value consumes more than 4 bytes. void COTpdoReadData ( CO_IF_FRM * frm , uint8_t pos , uint8_t size , CO_OBJ * obj ) { /* Optional: place here some code, which is called * when a PDO is constructed for transmission which * needs a mapped values with a size larger than 4 byte. */ } Arguments Parameter Description frm Ptr to PDO message frame pos The start index in the CAN message frame payload size The mapped value size in bytes obj Ptr to the source object entry","title":"COTpdoReadData()"},{"location":"usage/configuration/","text":"Configuration # Configuration Options # Application Parameter # This chapter describes the specification of the parameter groups. The parameter structures are highly application-specific and shall be defined within the application header files. Example: typedef struct COM_PARA_MEM_T { uint16_t Heartbeat_1017_0 ; } COM_PARA_MEM ; typedef struct APP_PARA_MEM_T { uint32_t DemoLong ; uint16_t DemoWord ; uint8_t DemoByte ; } APP_PARA_MEM ; typedef struct ALL_PARA_MEM_T { COM_PARA_MEM Com ; APP_PARA_MEM App ; } ALL_PARA_MEM ; This example defines multiple parameter groups: a parameter group containing the communication profile parameter ( COM_PARA_MEM ) a parameter group containing the application-specific parameter ( APP_PARA_MEM ) The third definition collects the previously defined parameter groups to a single parameter group to allow loading and storage of both parameter groups with single access ( ALL_PARA_MEM ) These structure type definitions are recommended to force the linker to place the corresponding parameter variables in a consecutive memory block. Any other technique to get this result is reasonable, too. Within the object directory configuration, the parameter group information structures shall be allocated and filled with the corresponding parameter group information settings. Example: static const CO_PARA AllParaObj = { 0L , /* placement in non-volatile memory */ sizeof ( ALL_PARA_MEM ), ( uint8_t * ) & Para , ( uint8_t * ) & ParaDef , CO_RESET_NODE , ( void * ) \"all.txt\" , CO_PARA___E }; static const CO_PARA ComParaObj = { 0L , /* placement in non-volatile memory */ sizeof ( COM_PARA_MEM ), ( uint8_t * ) & Para . Com , ( uint8_t * ) & ParaDef . Com , CO_RESET_COM , ( void * ) \"com.txt\" , CO_PARA___E }; static const CO_PARA AppParaObj = { sizeof ( COM_PARA_MEM ), /* placement in non-volatile memory */ sizeof ( APP_PARA_MEM ), ( uint8_t * ) & Para . App , ( uint8_t * ) & ParaDef . App , CO_RESET_NODE , ( void * ) \"app.txt\" , CO_PARA___E }; The following descriptions explains the details of the table members: The parameter group size [ uint32_t ] shall be set to the number of bytes within the parameter group memory area The start address of the parameter group memory area [ uint8_t * ] shall be set to the first address of the parameter group memory The reset type [ CO_NMT_RESET ] shall be set to one of the following values: Reset Type Description CO_RESET_COM parameter group shall be set to the stored values on communication reset CO_RESET_NODE parameter group shall be set to the stored values on node reset The pointer to the identification [ void * ] of this parameter group is not used by the CANopen stack. This member is intended to identify the different parameter groups within the application callback functions, related to the parameter handling. Any type of identification may be used for this purpose. In the shown example, an identification string is used. The parameter group feature indication [ uint32_t ], which is returned on a simple object entry read access, shall be set to one of the following values: Parameter Feature Description CO_PARA____ parameter group is disabled CO_PARA___E parameter group is enabled and will be stored on command CO_PARA__A_ parameter group is enabled and will be stored autonomously CO_PARA__AE parameter group is enabled and will be stored on command and autonomously Note: \"autonomously\" means without CANopen network interaction; e.g. the application is responsible for the storage of these parameter groups. The object entries, handling the saving and restoring of parameters, shall be set for the example to the following values: { CO_KEY ( 0x1010 , 0 , CO_OBJ_D___R_ ), CO_TPARA_STORE , ( CO_DATA )( 0x03 ) }, { CO_KEY ( 0x1010 , 1 , CO_OBJ_____RW ), CO_TPARA_STORE , ( CO_DATA )( & AllParaObj ) }, { CO_KEY ( 0x1010 , 2 , CO_OBJ_____RW ), CO_TPARA_STORE , ( CO_DATA )( & ComParaObj ) }, { CO_KEY ( 0x1010 , 3 , CO_OBJ_____RW ), CO_TPARA_STORE , ( CO_DATA )( & AppParaObj ) }, { CO_KEY ( 0x1011 , 0 , CO_OBJ_D___R_ ), CO_TPARA_RESTORE , ( CO_DATA )( 0x03 ) }, { CO_KEY ( 0x1011 , 1 , CO_OBJ_____RW ), CO_TPARA_RESTORE , ( CO_DATA )( & AllParaObj ) }, { CO_KEY ( 0x1011 , 2 , CO_OBJ_____RW ), CO_TPARA_RESTORE , ( CO_DATA )( & ComParaObj ) }, { CO_KEY ( 0x1011 , 3 , CO_OBJ_____RW ), CO_TPARA_RESTORE , ( CO_DATA )( & AppParaObj ) }, The single parameters are most likely used within the object directory. The example definition of an object entry is shown for one parameter: { CO_KEY ( 0x1017 , 0 , CO_OBJ_____RW ), CO_TUNSIGNED16 , ( CO_DATA )( & Para . App . DemoWord ) }, Domain Definition # This chapter describes the specification of an object with the type domain . The domains are highly application-specific and are usable in a wide range. Example: CO_OBJ_DOM AppDomain = { 0 , sizeof ( APP_PARA_MEM ), & AppParaObj }; This example defines a domain information object for the already allocated memory space of the variable AppParaObj (a variable within the application parameter example). This allows access to the complete application parameter set with SDO segmented or block transfers from within the CANopen network. The following descriptions explains the details of the structure members: The domain offset [ uint32_t ] shall be set to 0 to access the first byte of the domain The domain size [ uint32_t ] in bytes shall be set to the number of bytes within the domain memory area The start address of the domain memory area [ uint8_t * ] shall be set to the first address of the domain The object entry, presenting the example domain above to the CANopen network, should be defined within the manufacturer-specific area (e.g. index 0x2500, subindex 0x00) with the following object directory entry definition line: { CO_KEY ( 0x2500 , 0 , CO_OBJ_____RW ), CO_TDOMAIN , ( CO_DATA )( & AppDomain ) }, Note: The standard type implementation CO_TDOMAIN assumes, that the domain memory is located in RAM and is direct accessible. For other types of domain, a project-specific domain type shall be implemented. Heartbeat Consumer Definition # This chapter describes the specification of a heartbeat consumer object. Example: CO_HBCONS AppHbConsumer_1 = { 0 }; /* optional somewhere during startup: */ AppHbConsumer_1 . Time = 100 ; /* heartbeat consumer time of 100ms */ AppHbConsumer_1 . NodeId = 42 ; /* heartbeat consumer for node 42 */ This example defines a heartbeat consumer object. The initialization of all members with 0 is good practice, but not mandatory. The heartbeat consumer object allows the configuration of a heartbeat consumer with SDO transfers from within the CANopen network or during configuration time. The following descriptions explains the details of the structure members, which should be initialized (via application - or via an SDO write access): The Time [ uint16_t ] shall be set to the heartbeat consumer time in ms. The monitoring of the addressed heartbeat starts after the first reception of the addressed heartbeat. The NodeId [ uint8_t ] shall be set to the CANopen Node-ID of the heartbeat producer, which shall be consumed. The object entry, presenting the example domain above to the CANopen network, should be defined within the heartbeat consumer area (index 0x1016, subindex 0 to 254) with the following object directory entry definition line: { CO_KEY ( 0x1016 , 0 , CO_OBJ_D___R_ ), CO_THB_CONS , ( CO_DATA )( 1 ) }, { CO_KEY ( 0x1016 , 1 , CO_OBJ_____RW ), CO_THB_CONS , ( CO_DATA )( & AppHbConsumer_1 ) }, Note: Even, if the members \"Time\" and \"NodeId\" are static, the heartbeat consumer must be placed in RAM. There are multiple internal members for managing the heartbeat consumer included as well. Emergency Code Definition # This chapter describes the definition of the Emergency error code table. This table must be in line with the Emergency identifier enumeration. Example: const CO_EMCY_TBL AppEmcyCode [ CO_EMCY_N ] = { { CO_EMCY_REG_GENERAL , CO_EMCY_CODE_GEN_ERR + 0x01 }, /* APP_EMCY_1 */ { CO_EMCY_REG_CURRENT , CO_EMCY_CODE_CUR_ERR + 0x01 }, /* APP_EMCY_2 */ { CO_EMCY_REG_VOLTAGE , CO_EMCY_CODE_VOL_ERR + 0x01 }, /* APP_EMCY_3 */ { CO_EMCY_REG_TEMP , CO_EMCY_CODE_TEMP_ERR + 0x01 } /* APP_EMCY_4 */ }; This example defines 4 emergency codes within different error register classes (first entry of each line). The emergency codes itself are based on the standard emergency codes (second entry of each line). The following descriptions explains the details of the table members: The error register bit definition [ uint8_t ] shall be set to one of the following values: Error Register Bit Description CO_EMCY_REG_GENERAL general error (includes all other classes) CO_EMCY_REG_CURRENT error class: current CO_EMCY_REG_VOLTAGE error class: voltage CO_EMCY_REG_TEMP error class: temperature CO_EMCY_REG_COM error class: communication CO_EMCY_REG_PROFILE error class: profile specific error CO_EMCY_REG_MANUFACTURER error class: manufacturer specific The emergency error code [ uint16_t ] shall be set to the application-specific error code. This error code should be defined acc. the CANopen specification. The EMCY handling and object directory manipulations with these definitions is performed by the CANopen stack without further definitions. The application is able to register, clear, reset, check and count emergency errors with the provided function API. For details on this API, see Reference Manual [2]. Example: status = COEmcyGet ( & Node . Emcy , APP_EMCY_1 ); This example gets the current status of the Emergency error with the given emergency identifier APP_EMCY_1 . Object Dictionary # This chapter describes the configuration table representing the CANopen object dictionary. This is the central element of the CANopen node. This table can be placed in RAM or in ROM. The placement decides, which access type is possible with direct entries. Most likely this table is placed in ROM because RAM is in most cases the limited resource. const CO_OBJ AppObjDir [] = { { < ObjEntryKey_0 > , < ObjTypeRef_0 > , < ObjData_0 > }, /* first object entry */ : { < ObjEntryKey_N > , < ObjTypeRef_N > , < ObjData_N > }, /* last object entry */ CO_OBJ_DICT_ENDMARK }; Each line represents a single object entry definition. The collection of object entries shall be sorted in ascending order in index and subindex. The following chapters describes the details of the table members. Object Entry Key # The object entry key [ uint32_t ] shall be constructed with the following macro: CO_KEY ( < index > , < subindex > , < property flags > ) The index is a 16bit value with possible range from 0x0000 to 0xFFFF The subindex is an 8bit value with the possible range from 0x00 to 0xFF The property flags shall be set to a bitwise disjunction of the listed values Property Flags # The following table shows the possible property flags. The bitwise disjunction is possible with setting multiple letters in a prepared define (e.g. CO_OBJ__N_PRW ), or using them separately. Access Mode Flags Description CO_OBJ______W Write only CO_OBJ_____R_ Read only Note The access types specifies the possible access types from the CANopen network to that object entry. The application is always able to read and write the object entry. Type Flags Description CO_OBJ____P__ PDO mappable object CO_OBJ___A___ Use asynchronous PDO trigger on change CO_OBJ__N____ Add Node-ID to object value Note The type flags are used in the communication modules for the basic object types CO_TUNSIGNED8 , CO_TUNSIGNED16 , and CO_TUNSIGNED32 only. Storage Flags Description CO_OBJ_D_____ Store the value in data pointer memory Important When using architectures with pointer types lower than 32bit (e.g. 16bit microcontrollers), you can store only values up to the pointer width directly in the object dictionary. For larger values declare a constant variable and place a pointer to this constant into the object dictionary. Object Type Interface # The object entry type function interface [ CO_OBJ_TYPE * ] shall be set to one of the following values: Basic types # Object Type Description Data Variable CO_TUNSIGNED8 Basic 8bit type uint8_t CO_TUNSIGNED16 Basic 16bit type uint16_t CO_TUNSIGNED32 Basic 32bit type uint32_t CO_TDOMAIN Domain entry CO_OBJ_DOM CO_TSTRING Unlimited read-only string CO_OBJ_STR CiA301 Specific Types # Object Type Description Data Variable CO_TEMCY_HIST EMCY history entry (subindex 0) uint8_t CO_TEMCY_HIST EMCY history entry (subindex 1..254) uint32_t CO_TEMCY_ID Dynamic EMCY COB-ID uint32_t CO_TEVENT PDO event timer entry uint16_t CO_THB_CONS Heartbeat consumer entry CO_HBCONS CO_THB_PROD Heartbeat producer entry uint16_t CO_TPARA_STORE Parameter group store (subindex 0) uint8_t CO_TPARA_STORE Parameter group store (subindex 1..254) CO_PARA CO_TPARA_RESTORE Parameter group restore (subindex 0) uint8_t CO_TPARA_RESTORE Parameter group restore (subindex 1..254) CO_PARA CO_TPDO_ID Dynamic PDO COB-ID entry uint32_t CO_TPDO_MAP Dynamic PDO mapping entry uint32_t CO_TPDO_NUM Dynamic PDO number of mapping entries uint8_t CO_TPDO_TYPE Dynamic PDO transmission type entry uint8_t CO_TSDO_ID Dynamic SDO COB-ID entry uint32_t CO_TSYNC_CYCLE SYNC producer cycle time uint32_t CO_TSYNC_ID Dynamic SYNC COB-ID uint32_t Object Data Reference # The object data reference [ CO_DATA ] shall be set in dependence to the object type to a variable pointer of a specific type. See above for the type specific data variable types. PDO Mapping Value # For the PDO mapping object entries, we must encode the object data value in the following way: You can use the macro CO_LINK to get the value in a readable way: CO_LINK ( < destination - index > , < destination - subindex > , < mapping - bits > ) For example, when you want to map an object entry with a size of 8 bits from index 0x2100, subindex 0x02 to your PDO, the mapping entry in the object dictionary is: /* variable for object entry data */ uint8_t MyData = 0u ; /* object dictionary */ const CO_OBJ AppObjDir [] = { : /* PDO mapping entry */ { CO_KEY ( 0x1A00 , 1 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( CO_LINK ( 0x2100 , 0x02 , 8 ))}, : /* mapped object entry */ { CO_KEY ( 0x2100 , 2 , CO_OBJ____PR_ ), CO_TUNSIGNED8 , ( CO_DATA )( & MyData )}, : CO_OBJ_DICT_ENDMARK }; Note: this CANopen stack supports the mapping of 8, 16, 24 or 32bits. Transmit PDO Communication # This chapter describes the PDO communication record for a transmit PDO. The object record contains the following object entries: Index:sub Static Type Dynamic Type Description 1800h:00 CO_TUNSIGNED8 CO_TUNSIGNED8 Communication Object TPDO #0 1800h:01 CO_TUNSIGNED32 CO_TPDO_ID COB-ID used by TPDO 1800h:02 CO_TUNSIGNED8 CO_TPDO_TYPE Transmission type 1800h:03 CO_TUNSIGNED16 CO_TUNSIGNED16 Inhibit time with LSB 100us (0=disable) 1800h:04 n/a n/a reserved, shall not be implemented 1800h:05 CO_TUNSIGNED16 CO_TPDO_EVENT Event timer LSB 1ms (0=disable) The index identifies which PDO is configured (1800h: TPDO #0, 1801h: TPDO #1, ..., 19ffh: TPDO #511). The object entries are setup with basic types in case of static communication settings. When the communication settings are parameters or dynamic variables, the listed dynamic object types ensures the correct change behavior for these records. The encoding for the transmission type (subindex 2) is standardized: Value Description 00h acyclic 01h..F0h cyclic every n-th SYNC (1..240) F1h..FDh reserved FEh event-driven (manufacturer specific) FFh event-driven (device profile specific) Timer Memory Block # This chapter describes the allocation of the data memory, required by the CANopen timer module. The presented source code lines represent the default and must not be changed. The typical need on changing this memory allocation is to place this memory to a specific place in internal or external RAM. CO_TMR_MEM AppTmrMem [ CO_TMR_N ]; SDO Transfer Memory # This chapter describes the allocation of the data memory, required by the CANopen SDO server module. The presented source code lines represent the default and must not be changed. The typical need on changing this memory allocation is to place this memory to a specific place in internal or external RAM. uint8_t AppSdoBuf [ CO_SSDO_N ][ CO_SDO_BUF_BYTE ]; Note: This memory is used only when support for SDO segmented or block transfers are performed. Node Specification # This chapter describes the basic node specification. This table must be existent for each CANopen node, which shall be active within the CANopen device. Example: const CO_NODE_SPEC AppSpec = { ( uint8_t ) 0x01 , /* pre-defined Node-ID */ ( uint32_t ) Baudrate , /* default baudrate */ ( CO_OBJ * ) & AppObjDir , /* start of object directory */ ( uint16_t ) APP_OBJ_N , /* number of objects in directory */ ( CO_EMCY_TBL * ) & AppEmcyCode , /* start of emergency code table */ ( CO_TMR_MEM * ) & AppTmrMem , /* start of timer manager memory */ ( uint16_t ) APP_TMR_N , /* max. number of timers/actions */ ( uint32_t ) APP_TICKS_PER_SEC , /* timer clock frequency in Hz */ ( CO_IF_DRV ) & AppDrv , /* hardware interface drivers */ ( uint8_t * ) & AppSdoBuf /* start of SDO transfer buffer */ }; This example specifies the basic node information for the example node. Each entry is a part of the configuration. This structure is only required during the startup of the CANopen stack. If SDO block and segmented transfer is disabled, e.g. the SDO transfer buffer is not used, the last entry in the node specification can be set to NULL . The following example creates a single CANopen node: extern const CO_NODE_SPEC AppSpec ; CO_NODE AppNode ; void StartNode ( void ) { CONodeInit ( & AppNode , ( CO_NODE_SPEC * ) & AppSpec ); if ( CONodeGetErr ( & AppNode ) != CO_ERR_NONE ) { /* error handling */ } };","title":"Configuration"},{"location":"usage/configuration/#configuration","text":"","title":"Configuration"},{"location":"usage/configuration/#configuration-options","text":"","title":"Configuration Options"},{"location":"usage/configuration/#application-parameter","text":"This chapter describes the specification of the parameter groups. The parameter structures are highly application-specific and shall be defined within the application header files. Example: typedef struct COM_PARA_MEM_T { uint16_t Heartbeat_1017_0 ; } COM_PARA_MEM ; typedef struct APP_PARA_MEM_T { uint32_t DemoLong ; uint16_t DemoWord ; uint8_t DemoByte ; } APP_PARA_MEM ; typedef struct ALL_PARA_MEM_T { COM_PARA_MEM Com ; APP_PARA_MEM App ; } ALL_PARA_MEM ; This example defines multiple parameter groups: a parameter group containing the communication profile parameter ( COM_PARA_MEM ) a parameter group containing the application-specific parameter ( APP_PARA_MEM ) The third definition collects the previously defined parameter groups to a single parameter group to allow loading and storage of both parameter groups with single access ( ALL_PARA_MEM ) These structure type definitions are recommended to force the linker to place the corresponding parameter variables in a consecutive memory block. Any other technique to get this result is reasonable, too. Within the object directory configuration, the parameter group information structures shall be allocated and filled with the corresponding parameter group information settings. Example: static const CO_PARA AllParaObj = { 0L , /* placement in non-volatile memory */ sizeof ( ALL_PARA_MEM ), ( uint8_t * ) & Para , ( uint8_t * ) & ParaDef , CO_RESET_NODE , ( void * ) \"all.txt\" , CO_PARA___E }; static const CO_PARA ComParaObj = { 0L , /* placement in non-volatile memory */ sizeof ( COM_PARA_MEM ), ( uint8_t * ) & Para . Com , ( uint8_t * ) & ParaDef . Com , CO_RESET_COM , ( void * ) \"com.txt\" , CO_PARA___E }; static const CO_PARA AppParaObj = { sizeof ( COM_PARA_MEM ), /* placement in non-volatile memory */ sizeof ( APP_PARA_MEM ), ( uint8_t * ) & Para . App , ( uint8_t * ) & ParaDef . App , CO_RESET_NODE , ( void * ) \"app.txt\" , CO_PARA___E }; The following descriptions explains the details of the table members: The parameter group size [ uint32_t ] shall be set to the number of bytes within the parameter group memory area The start address of the parameter group memory area [ uint8_t * ] shall be set to the first address of the parameter group memory The reset type [ CO_NMT_RESET ] shall be set to one of the following values: Reset Type Description CO_RESET_COM parameter group shall be set to the stored values on communication reset CO_RESET_NODE parameter group shall be set to the stored values on node reset The pointer to the identification [ void * ] of this parameter group is not used by the CANopen stack. This member is intended to identify the different parameter groups within the application callback functions, related to the parameter handling. Any type of identification may be used for this purpose. In the shown example, an identification string is used. The parameter group feature indication [ uint32_t ], which is returned on a simple object entry read access, shall be set to one of the following values: Parameter Feature Description CO_PARA____ parameter group is disabled CO_PARA___E parameter group is enabled and will be stored on command CO_PARA__A_ parameter group is enabled and will be stored autonomously CO_PARA__AE parameter group is enabled and will be stored on command and autonomously Note: \"autonomously\" means without CANopen network interaction; e.g. the application is responsible for the storage of these parameter groups. The object entries, handling the saving and restoring of parameters, shall be set for the example to the following values: { CO_KEY ( 0x1010 , 0 , CO_OBJ_D___R_ ), CO_TPARA_STORE , ( CO_DATA )( 0x03 ) }, { CO_KEY ( 0x1010 , 1 , CO_OBJ_____RW ), CO_TPARA_STORE , ( CO_DATA )( & AllParaObj ) }, { CO_KEY ( 0x1010 , 2 , CO_OBJ_____RW ), CO_TPARA_STORE , ( CO_DATA )( & ComParaObj ) }, { CO_KEY ( 0x1010 , 3 , CO_OBJ_____RW ), CO_TPARA_STORE , ( CO_DATA )( & AppParaObj ) }, { CO_KEY ( 0x1011 , 0 , CO_OBJ_D___R_ ), CO_TPARA_RESTORE , ( CO_DATA )( 0x03 ) }, { CO_KEY ( 0x1011 , 1 , CO_OBJ_____RW ), CO_TPARA_RESTORE , ( CO_DATA )( & AllParaObj ) }, { CO_KEY ( 0x1011 , 2 , CO_OBJ_____RW ), CO_TPARA_RESTORE , ( CO_DATA )( & ComParaObj ) }, { CO_KEY ( 0x1011 , 3 , CO_OBJ_____RW ), CO_TPARA_RESTORE , ( CO_DATA )( & AppParaObj ) }, The single parameters are most likely used within the object directory. The example definition of an object entry is shown for one parameter: { CO_KEY ( 0x1017 , 0 , CO_OBJ_____RW ), CO_TUNSIGNED16 , ( CO_DATA )( & Para . App . DemoWord ) },","title":"Application Parameter"},{"location":"usage/configuration/#domain-definition","text":"This chapter describes the specification of an object with the type domain . The domains are highly application-specific and are usable in a wide range. Example: CO_OBJ_DOM AppDomain = { 0 , sizeof ( APP_PARA_MEM ), & AppParaObj }; This example defines a domain information object for the already allocated memory space of the variable AppParaObj (a variable within the application parameter example). This allows access to the complete application parameter set with SDO segmented or block transfers from within the CANopen network. The following descriptions explains the details of the structure members: The domain offset [ uint32_t ] shall be set to 0 to access the first byte of the domain The domain size [ uint32_t ] in bytes shall be set to the number of bytes within the domain memory area The start address of the domain memory area [ uint8_t * ] shall be set to the first address of the domain The object entry, presenting the example domain above to the CANopen network, should be defined within the manufacturer-specific area (e.g. index 0x2500, subindex 0x00) with the following object directory entry definition line: { CO_KEY ( 0x2500 , 0 , CO_OBJ_____RW ), CO_TDOMAIN , ( CO_DATA )( & AppDomain ) }, Note: The standard type implementation CO_TDOMAIN assumes, that the domain memory is located in RAM and is direct accessible. For other types of domain, a project-specific domain type shall be implemented.","title":"Domain Definition"},{"location":"usage/configuration/#heartbeat-consumer-definition","text":"This chapter describes the specification of a heartbeat consumer object. Example: CO_HBCONS AppHbConsumer_1 = { 0 }; /* optional somewhere during startup: */ AppHbConsumer_1 . Time = 100 ; /* heartbeat consumer time of 100ms */ AppHbConsumer_1 . NodeId = 42 ; /* heartbeat consumer for node 42 */ This example defines a heartbeat consumer object. The initialization of all members with 0 is good practice, but not mandatory. The heartbeat consumer object allows the configuration of a heartbeat consumer with SDO transfers from within the CANopen network or during configuration time. The following descriptions explains the details of the structure members, which should be initialized (via application - or via an SDO write access): The Time [ uint16_t ] shall be set to the heartbeat consumer time in ms. The monitoring of the addressed heartbeat starts after the first reception of the addressed heartbeat. The NodeId [ uint8_t ] shall be set to the CANopen Node-ID of the heartbeat producer, which shall be consumed. The object entry, presenting the example domain above to the CANopen network, should be defined within the heartbeat consumer area (index 0x1016, subindex 0 to 254) with the following object directory entry definition line: { CO_KEY ( 0x1016 , 0 , CO_OBJ_D___R_ ), CO_THB_CONS , ( CO_DATA )( 1 ) }, { CO_KEY ( 0x1016 , 1 , CO_OBJ_____RW ), CO_THB_CONS , ( CO_DATA )( & AppHbConsumer_1 ) }, Note: Even, if the members \"Time\" and \"NodeId\" are static, the heartbeat consumer must be placed in RAM. There are multiple internal members for managing the heartbeat consumer included as well.","title":"Heartbeat Consumer Definition"},{"location":"usage/configuration/#emergency-code-definition","text":"This chapter describes the definition of the Emergency error code table. This table must be in line with the Emergency identifier enumeration. Example: const CO_EMCY_TBL AppEmcyCode [ CO_EMCY_N ] = { { CO_EMCY_REG_GENERAL , CO_EMCY_CODE_GEN_ERR + 0x01 }, /* APP_EMCY_1 */ { CO_EMCY_REG_CURRENT , CO_EMCY_CODE_CUR_ERR + 0x01 }, /* APP_EMCY_2 */ { CO_EMCY_REG_VOLTAGE , CO_EMCY_CODE_VOL_ERR + 0x01 }, /* APP_EMCY_3 */ { CO_EMCY_REG_TEMP , CO_EMCY_CODE_TEMP_ERR + 0x01 } /* APP_EMCY_4 */ }; This example defines 4 emergency codes within different error register classes (first entry of each line). The emergency codes itself are based on the standard emergency codes (second entry of each line). The following descriptions explains the details of the table members: The error register bit definition [ uint8_t ] shall be set to one of the following values: Error Register Bit Description CO_EMCY_REG_GENERAL general error (includes all other classes) CO_EMCY_REG_CURRENT error class: current CO_EMCY_REG_VOLTAGE error class: voltage CO_EMCY_REG_TEMP error class: temperature CO_EMCY_REG_COM error class: communication CO_EMCY_REG_PROFILE error class: profile specific error CO_EMCY_REG_MANUFACTURER error class: manufacturer specific The emergency error code [ uint16_t ] shall be set to the application-specific error code. This error code should be defined acc. the CANopen specification. The EMCY handling and object directory manipulations with these definitions is performed by the CANopen stack without further definitions. The application is able to register, clear, reset, check and count emergency errors with the provided function API. For details on this API, see Reference Manual [2]. Example: status = COEmcyGet ( & Node . Emcy , APP_EMCY_1 ); This example gets the current status of the Emergency error with the given emergency identifier APP_EMCY_1 .","title":"Emergency Code Definition"},{"location":"usage/configuration/#object-dictionary","text":"This chapter describes the configuration table representing the CANopen object dictionary. This is the central element of the CANopen node. This table can be placed in RAM or in ROM. The placement decides, which access type is possible with direct entries. Most likely this table is placed in ROM because RAM is in most cases the limited resource. const CO_OBJ AppObjDir [] = { { < ObjEntryKey_0 > , < ObjTypeRef_0 > , < ObjData_0 > }, /* first object entry */ : { < ObjEntryKey_N > , < ObjTypeRef_N > , < ObjData_N > }, /* last object entry */ CO_OBJ_DICT_ENDMARK }; Each line represents a single object entry definition. The collection of object entries shall be sorted in ascending order in index and subindex. The following chapters describes the details of the table members.","title":"Object Dictionary"},{"location":"usage/configuration/#object-entry-key","text":"The object entry key [ uint32_t ] shall be constructed with the following macro: CO_KEY ( < index > , < subindex > , < property flags > ) The index is a 16bit value with possible range from 0x0000 to 0xFFFF The subindex is an 8bit value with the possible range from 0x00 to 0xFF The property flags shall be set to a bitwise disjunction of the listed values","title":"Object Entry Key"},{"location":"usage/configuration/#property-flags","text":"The following table shows the possible property flags. The bitwise disjunction is possible with setting multiple letters in a prepared define (e.g. CO_OBJ__N_PRW ), or using them separately. Access Mode Flags Description CO_OBJ______W Write only CO_OBJ_____R_ Read only Note The access types specifies the possible access types from the CANopen network to that object entry. The application is always able to read and write the object entry. Type Flags Description CO_OBJ____P__ PDO mappable object CO_OBJ___A___ Use asynchronous PDO trigger on change CO_OBJ__N____ Add Node-ID to object value Note The type flags are used in the communication modules for the basic object types CO_TUNSIGNED8 , CO_TUNSIGNED16 , and CO_TUNSIGNED32 only. Storage Flags Description CO_OBJ_D_____ Store the value in data pointer memory Important When using architectures with pointer types lower than 32bit (e.g. 16bit microcontrollers), you can store only values up to the pointer width directly in the object dictionary. For larger values declare a constant variable and place a pointer to this constant into the object dictionary.","title":"Property Flags"},{"location":"usage/configuration/#object-type-interface","text":"The object entry type function interface [ CO_OBJ_TYPE * ] shall be set to one of the following values:","title":"Object Type Interface"},{"location":"usage/configuration/#basic-types","text":"Object Type Description Data Variable CO_TUNSIGNED8 Basic 8bit type uint8_t CO_TUNSIGNED16 Basic 16bit type uint16_t CO_TUNSIGNED32 Basic 32bit type uint32_t CO_TDOMAIN Domain entry CO_OBJ_DOM CO_TSTRING Unlimited read-only string CO_OBJ_STR","title":"Basic types"},{"location":"usage/configuration/#cia301-specific-types","text":"Object Type Description Data Variable CO_TEMCY_HIST EMCY history entry (subindex 0) uint8_t CO_TEMCY_HIST EMCY history entry (subindex 1..254) uint32_t CO_TEMCY_ID Dynamic EMCY COB-ID uint32_t CO_TEVENT PDO event timer entry uint16_t CO_THB_CONS Heartbeat consumer entry CO_HBCONS CO_THB_PROD Heartbeat producer entry uint16_t CO_TPARA_STORE Parameter group store (subindex 0) uint8_t CO_TPARA_STORE Parameter group store (subindex 1..254) CO_PARA CO_TPARA_RESTORE Parameter group restore (subindex 0) uint8_t CO_TPARA_RESTORE Parameter group restore (subindex 1..254) CO_PARA CO_TPDO_ID Dynamic PDO COB-ID entry uint32_t CO_TPDO_MAP Dynamic PDO mapping entry uint32_t CO_TPDO_NUM Dynamic PDO number of mapping entries uint8_t CO_TPDO_TYPE Dynamic PDO transmission type entry uint8_t CO_TSDO_ID Dynamic SDO COB-ID entry uint32_t CO_TSYNC_CYCLE SYNC producer cycle time uint32_t CO_TSYNC_ID Dynamic SYNC COB-ID uint32_t","title":"CiA301 Specific Types"},{"location":"usage/configuration/#object-data-reference","text":"The object data reference [ CO_DATA ] shall be set in dependence to the object type to a variable pointer of a specific type. See above for the type specific data variable types.","title":"Object Data Reference"},{"location":"usage/configuration/#pdo-mapping-value","text":"For the PDO mapping object entries, we must encode the object data value in the following way: You can use the macro CO_LINK to get the value in a readable way: CO_LINK ( < destination - index > , < destination - subindex > , < mapping - bits > ) For example, when you want to map an object entry with a size of 8 bits from index 0x2100, subindex 0x02 to your PDO, the mapping entry in the object dictionary is: /* variable for object entry data */ uint8_t MyData = 0u ; /* object dictionary */ const CO_OBJ AppObjDir [] = { : /* PDO mapping entry */ { CO_KEY ( 0x1A00 , 1 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( CO_LINK ( 0x2100 , 0x02 , 8 ))}, : /* mapped object entry */ { CO_KEY ( 0x2100 , 2 , CO_OBJ____PR_ ), CO_TUNSIGNED8 , ( CO_DATA )( & MyData )}, : CO_OBJ_DICT_ENDMARK }; Note: this CANopen stack supports the mapping of 8, 16, 24 or 32bits.","title":"PDO Mapping Value"},{"location":"usage/configuration/#transmit-pdo-communication","text":"This chapter describes the PDO communication record for a transmit PDO. The object record contains the following object entries: Index:sub Static Type Dynamic Type Description 1800h:00 CO_TUNSIGNED8 CO_TUNSIGNED8 Communication Object TPDO #0 1800h:01 CO_TUNSIGNED32 CO_TPDO_ID COB-ID used by TPDO 1800h:02 CO_TUNSIGNED8 CO_TPDO_TYPE Transmission type 1800h:03 CO_TUNSIGNED16 CO_TUNSIGNED16 Inhibit time with LSB 100us (0=disable) 1800h:04 n/a n/a reserved, shall not be implemented 1800h:05 CO_TUNSIGNED16 CO_TPDO_EVENT Event timer LSB 1ms (0=disable) The index identifies which PDO is configured (1800h: TPDO #0, 1801h: TPDO #1, ..., 19ffh: TPDO #511). The object entries are setup with basic types in case of static communication settings. When the communication settings are parameters or dynamic variables, the listed dynamic object types ensures the correct change behavior for these records. The encoding for the transmission type (subindex 2) is standardized: Value Description 00h acyclic 01h..F0h cyclic every n-th SYNC (1..240) F1h..FDh reserved FEh event-driven (manufacturer specific) FFh event-driven (device profile specific)","title":"Transmit PDO Communication"},{"location":"usage/configuration/#timer-memory-block","text":"This chapter describes the allocation of the data memory, required by the CANopen timer module. The presented source code lines represent the default and must not be changed. The typical need on changing this memory allocation is to place this memory to a specific place in internal or external RAM. CO_TMR_MEM AppTmrMem [ CO_TMR_N ];","title":"Timer Memory Block"},{"location":"usage/configuration/#sdo-transfer-memory","text":"This chapter describes the allocation of the data memory, required by the CANopen SDO server module. The presented source code lines represent the default and must not be changed. The typical need on changing this memory allocation is to place this memory to a specific place in internal or external RAM. uint8_t AppSdoBuf [ CO_SSDO_N ][ CO_SDO_BUF_BYTE ]; Note: This memory is used only when support for SDO segmented or block transfers are performed.","title":"SDO Transfer Memory"},{"location":"usage/configuration/#node-specification","text":"This chapter describes the basic node specification. This table must be existent for each CANopen node, which shall be active within the CANopen device. Example: const CO_NODE_SPEC AppSpec = { ( uint8_t ) 0x01 , /* pre-defined Node-ID */ ( uint32_t ) Baudrate , /* default baudrate */ ( CO_OBJ * ) & AppObjDir , /* start of object directory */ ( uint16_t ) APP_OBJ_N , /* number of objects in directory */ ( CO_EMCY_TBL * ) & AppEmcyCode , /* start of emergency code table */ ( CO_TMR_MEM * ) & AppTmrMem , /* start of timer manager memory */ ( uint16_t ) APP_TMR_N , /* max. number of timers/actions */ ( uint32_t ) APP_TICKS_PER_SEC , /* timer clock frequency in Hz */ ( CO_IF_DRV ) & AppDrv , /* hardware interface drivers */ ( uint8_t * ) & AppSdoBuf /* start of SDO transfer buffer */ }; This example specifies the basic node information for the example node. Each entry is a part of the configuration. This structure is only required during the startup of the CANopen stack. If SDO block and segmented transfer is disabled, e.g. the SDO transfer buffer is not used, the last entry in the node specification can be set to NULL . The following example creates a single CANopen node: extern const CO_NODE_SPEC AppSpec ; CO_NODE AppNode ; void StartNode ( void ) { CONodeInit ( & AppNode , ( CO_NODE_SPEC * ) & AppSpec ); if ( CONodeGetErr ( & AppNode ) != CO_ERR_NONE ) { /* error handling */ } };","title":"Node Specification"},{"location":"usage/control/","text":"Controlling the Node # CANopen Node # The CANopen network is organized in a mix of master/slave and producer/consumer communication architecture. One single CANopen device (a master or a slave) is represented within the software with a data structure, called node . This structure is the central entry point of the application into the specific CANopen node. The following source line is essential to create a new instance of the node: CO_NODE demo ; /* create the node instance 'demo' */ The service functions starting with CONode\u2026() are provided for initializing and controlling the node-specific aspects. These service functions are requesting the corresponding node pointer as the first argument. For example reading the internal error state of the CANopen Node: err = CONodeGetErr ( & demo ); /* get error state of node 'demo' */ The same naming convention is realized with several modules. The following table shows the names of the provided modules and their corresponding arguments: Service Group Argument Example CODir\u2026() &demo.Dir CODirFind(&demo.Dir, CO_DEV(0x1234,0x56)); COEmcy\u2026() &demo.Emcy COEmcyCnt(&demo.Emcy); COIf\u2026() &demo.If COIfCanSend(&demo.If, &frm); CONmt\u2026() &demo.Nmt CONmtGetMode(&demo.Nmt); CONode\u2026() &demo CONodeGetErr(&demo); COTmr\u2026() &demo.Tmr COTmrCreate(&demo.Tmr, 0, 10, MyFunc, 0); COTPdo\u2026() &demo.TPdo COTPdoTrigPdo(&demo.TPdo, 1); Node Start # The start of a node needs to have some additional information about memory allocation, the object directory, and more. This information is collected to a single structure, called node specification . The following source lines show a typical node specification: const CO_NODE_SPEC DemoSpec = { ( uint8_t ) 0x01 , /* pre-defined Node-ID */ ( uint32_t ) Baudrate , /* default baudrate */ ( CO_OBJ * ) & AppObjDir , /* start of object directory */ ( uint16_t ) APP_OBJ_N , /* number of objects in directory */ ( CO_EMCY_TBL * ) & AppEmcyCode , /* start of emergency code table */ ( CO_TMR_MEM * ) & AppTmrMem , /* start of timer manager memory */ ( uint16_t ) APP_TMR_N , /* max. number of timers/actions */ ( uint32_t ) APP_TICKS_PER_SEC , /* timer clock frequency in Hz */ ( CO_IF_DRV ) & AppDrv , /* hardware interface drivers */ ( uint8_t * ) & AppSdoBuf /* start of SDO transfer buffer */ }; The service function CONodeInit() initializes the given node with the data and memory of the given node specification: CONodeInit ( & demo , ( CO_NODE_SPEC * ) & DemoSpec ); The internal behavior of the CANopen stack is shown in the following diagram: sequenceDiagram participant A as Application participant S as demo participant N as demo.Nmt Note over S,N: NMT State = CO_INVALID A->>+S: CONodeInit() S->>+N: initialize NMT N-->>-S: ok S-->>-A: ok Note over S,N: NMT State = CO_INIT A->>+S: CONodeStart() S->>+N: NMT bootup N-->>-S: ok S-->>-A: ok Note over S,N: NMT State = CO_PREOP The CANopen network state machine state is still in CO_INIT after the node initialization, because there may be several additional actions necessary before setting the node in the pre-operational state. With the second function call CONodeStart() the bootup message is sent and the node is in pre-operational mode. The node is now able to perform network communications. Node Processing # For processing a single CANopen network message, the CANopen stack provides a service function. The following line processes the latest received CAN message: CONodeProcess ( & demo ); The internal behavior of the CANopen stack is shown in the following diagram: sequenceDiagram participant A as Application participant S as demo participant I as demo.If A->>+S: CONodeProcess() S->>+I: get received CAN frame I-->>-S: CAN frame S-->>-A: ok Node Stop # Stopping a node is typically performed by the CAN network with autonomous requests . Nevertheless, the CANopen stack provides a service function to switch the NMT modes by the application. The following line switches the node into the NMT mode CO_STOP . CONmtSetMode ( & demo . Nmt , CO_STOP ); The internal behavior of the CANopen stack is shown in the following diagram: sequenceDiagram participant A as Application participant S as demo participant N as demo.Nmt Note over S,N: NMT State = <any> A->>+N: CONmtSetMode() N-->>-A: ok Note over S,N: NMT State = CO_STOP Note: After this activity, the interface and all resources are still locked and must not be used by other components. Node Reset # Resetting a node is typically performed by the CANopen master via NMT protocol messages. This is done by the CANopen stack without any necessary actions by the application. The CANopen stack provides a service function to reset the node by the application. The following line initiates the reset of the node. CONmtReset ( & demo . Nmt , CO_RESET_NODE ); There are two different kinds of resets possible: - Reset Communication and Application (this is called \"Reset Node\") - Reset Communication The internal behavior of the CANopen stack is shown in the following diagram: sequenceDiagram participant A as Application participant N as demo.Nmt participant S as demo participant I as demo.If Note over N: NMT State = <any> A->>+N: CONmtReset() Note over N: NMT State = CO_INIT opt application reset N->>+S: load parameters in [2000h to 9FFFh] S-->>-N: ok end N->>+S: load parameters in [1000h to 1FFFh] S-->>-N: ok N->>+I: COIfCanReset() I-->>-N: ok N-->>-A: ok Node Shutdown # Shutting down a node is typically not used by real embedded CANopen applications. This function is provided to delete all dynamically created objects and free the used memory areas. CONodeStop ( & demo ); The internal behavior of the CANopen stack is shown in the following diagram: sequenceDiagram participant A as Application participant S as demo participant N as demo.Nmt Note over S,N: NMT State = <any> A->>+S: CONodeStop() S->>+N: CONmtSetMode() N-->>-S: ok S-->>-A: ok Note over S,N: NMT State = CO_STOP Note: After this activity, the interface and all resources are free to use by other components.","title":"Controlling the Node"},{"location":"usage/control/#controlling-the-node","text":"","title":"Controlling the Node"},{"location":"usage/control/#canopen-node","text":"The CANopen network is organized in a mix of master/slave and producer/consumer communication architecture. One single CANopen device (a master or a slave) is represented within the software with a data structure, called node . This structure is the central entry point of the application into the specific CANopen node. The following source line is essential to create a new instance of the node: CO_NODE demo ; /* create the node instance 'demo' */ The service functions starting with CONode\u2026() are provided for initializing and controlling the node-specific aspects. These service functions are requesting the corresponding node pointer as the first argument. For example reading the internal error state of the CANopen Node: err = CONodeGetErr ( & demo ); /* get error state of node 'demo' */ The same naming convention is realized with several modules. The following table shows the names of the provided modules and their corresponding arguments: Service Group Argument Example CODir\u2026() &demo.Dir CODirFind(&demo.Dir, CO_DEV(0x1234,0x56)); COEmcy\u2026() &demo.Emcy COEmcyCnt(&demo.Emcy); COIf\u2026() &demo.If COIfCanSend(&demo.If, &frm); CONmt\u2026() &demo.Nmt CONmtGetMode(&demo.Nmt); CONode\u2026() &demo CONodeGetErr(&demo); COTmr\u2026() &demo.Tmr COTmrCreate(&demo.Tmr, 0, 10, MyFunc, 0); COTPdo\u2026() &demo.TPdo COTPdoTrigPdo(&demo.TPdo, 1);","title":"CANopen Node"},{"location":"usage/control/#node-start","text":"The start of a node needs to have some additional information about memory allocation, the object directory, and more. This information is collected to a single structure, called node specification . The following source lines show a typical node specification: const CO_NODE_SPEC DemoSpec = { ( uint8_t ) 0x01 , /* pre-defined Node-ID */ ( uint32_t ) Baudrate , /* default baudrate */ ( CO_OBJ * ) & AppObjDir , /* start of object directory */ ( uint16_t ) APP_OBJ_N , /* number of objects in directory */ ( CO_EMCY_TBL * ) & AppEmcyCode , /* start of emergency code table */ ( CO_TMR_MEM * ) & AppTmrMem , /* start of timer manager memory */ ( uint16_t ) APP_TMR_N , /* max. number of timers/actions */ ( uint32_t ) APP_TICKS_PER_SEC , /* timer clock frequency in Hz */ ( CO_IF_DRV ) & AppDrv , /* hardware interface drivers */ ( uint8_t * ) & AppSdoBuf /* start of SDO transfer buffer */ }; The service function CONodeInit() initializes the given node with the data and memory of the given node specification: CONodeInit ( & demo , ( CO_NODE_SPEC * ) & DemoSpec ); The internal behavior of the CANopen stack is shown in the following diagram: sequenceDiagram participant A as Application participant S as demo participant N as demo.Nmt Note over S,N: NMT State = CO_INVALID A->>+S: CONodeInit() S->>+N: initialize NMT N-->>-S: ok S-->>-A: ok Note over S,N: NMT State = CO_INIT A->>+S: CONodeStart() S->>+N: NMT bootup N-->>-S: ok S-->>-A: ok Note over S,N: NMT State = CO_PREOP The CANopen network state machine state is still in CO_INIT after the node initialization, because there may be several additional actions necessary before setting the node in the pre-operational state. With the second function call CONodeStart() the bootup message is sent and the node is in pre-operational mode. The node is now able to perform network communications.","title":"Node Start"},{"location":"usage/control/#node-processing","text":"For processing a single CANopen network message, the CANopen stack provides a service function. The following line processes the latest received CAN message: CONodeProcess ( & demo ); The internal behavior of the CANopen stack is shown in the following diagram: sequenceDiagram participant A as Application participant S as demo participant I as demo.If A->>+S: CONodeProcess() S->>+I: get received CAN frame I-->>-S: CAN frame S-->>-A: ok","title":"Node Processing"},{"location":"usage/control/#node-stop","text":"Stopping a node is typically performed by the CAN network with autonomous requests . Nevertheless, the CANopen stack provides a service function to switch the NMT modes by the application. The following line switches the node into the NMT mode CO_STOP . CONmtSetMode ( & demo . Nmt , CO_STOP ); The internal behavior of the CANopen stack is shown in the following diagram: sequenceDiagram participant A as Application participant S as demo participant N as demo.Nmt Note over S,N: NMT State = <any> A->>+N: CONmtSetMode() N-->>-A: ok Note over S,N: NMT State = CO_STOP Note: After this activity, the interface and all resources are still locked and must not be used by other components.","title":"Node Stop"},{"location":"usage/control/#node-reset","text":"Resetting a node is typically performed by the CANopen master via NMT protocol messages. This is done by the CANopen stack without any necessary actions by the application. The CANopen stack provides a service function to reset the node by the application. The following line initiates the reset of the node. CONmtReset ( & demo . Nmt , CO_RESET_NODE ); There are two different kinds of resets possible: - Reset Communication and Application (this is called \"Reset Node\") - Reset Communication The internal behavior of the CANopen stack is shown in the following diagram: sequenceDiagram participant A as Application participant N as demo.Nmt participant S as demo participant I as demo.If Note over N: NMT State = <any> A->>+N: CONmtReset() Note over N: NMT State = CO_INIT opt application reset N->>+S: load parameters in [2000h to 9FFFh] S-->>-N: ok end N->>+S: load parameters in [1000h to 1FFFh] S-->>-N: ok N->>+I: COIfCanReset() I-->>-N: ok N-->>-A: ok","title":"Node Reset"},{"location":"usage/control/#node-shutdown","text":"Shutting down a node is typically not used by real embedded CANopen applications. This function is provided to delete all dynamically created objects and free the used memory areas. CONodeStop ( & demo ); The internal behavior of the CANopen stack is shown in the following diagram: sequenceDiagram participant A as Application participant S as demo participant N as demo.Nmt Note over S,N: NMT State = <any> A->>+S: CONodeStop() S->>+N: CONmtSetMode() N-->>-S: ok S-->>-A: ok Note over S,N: NMT State = CO_STOP Note: After this activity, the interface and all resources are free to use by other components.","title":"Node Shutdown"},{"location":"usage/dictionary/","text":"Using Object Dictionary # Object Dictionary # The main interface within the CANopen network is the object dictionary of the CANopen nodes. The object dictionary of a node is accessible from the network as well as from the node application. The definition of the object dictionary table is done with an array of object entries of the type CO_OBJ . A small example is shown below: const CO_OBJ DemoOD [] = { : /* PDO mappable read-only value: */ { CO_KEY ( 0x1001 , 0 , CO_OBJ____PR_ ), CO_TUNSIGNED8 , ( CO_DATA )( & DemoErrReg ) }, /* Read-only value, which depends on Node-ID: */ { CO_KEY ( 0x1014 , 0 , CO_OBJ__N__R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & DemoEmcyId ) }, /* In CO_DATA pointer memory stored constant value: */ { CO_KEY ( 0x2400 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 1 ) }, /* A normal 32bit process data entry: */ { CO_KEY ( 0x2400 , 1 , CO_OBJ_____RW ), CO_TUNSIGNED32 , ( CO_DATA )( & DemoVarLong )}, : /* mark the end of object dictionary: */ CO_OBJ_DICT_ENDMARK }; Important The CANopen Stack relies on a binary search algorithm to ensure that object dictionary entries are found quickly. Because of this, you must keep the index / subindex of all entries in the object dictionary sorted in ascending order. Note The object dictionary can manage different object entry types with different properties. This information is encoded within the object property flags and the object type functions and is described in detail in the configuration section. The update of the provided basic and system object types within the object dictionary is managed by the CANopen stack. The application may read or write these objects at any time. Use the service function groups CODict\u2026() and COObj\u2026() for accessing the object dictionary. Basic Objects # The read and write access of basic object entries is symmetrical. Therefore the description is reduced to read access. The data width of basic objects is 8bit (byte), 16bit (word) or 32bit (long). All widths are handled in the same way, therefore the description is reduced to 32bit (long) object entries. For simple read access of a (hypothetical) 32bit object entry with an index=0x2345 and subindex=0x56, the service call is: CODictRdLong ( & demo . Dict , CO_DEV ( 0x2345 , 0x56 ), & value ); The following diagram shows the internal behavior of this service. sequenceDiagram participant A as Application participant D as demo.Dict participant O as demo.Obj A->>+D: CODictRdLong() D->>D: CODictFind() D->>+O: get size O-->>-D: size D->>+O: read object O-->>-D: value D-->>-A: value For multiple accesses to the same object entry, the following sequence reduces the performance overhead, which is based on searching within the object dictionary. The object read and write functions can take a previously searched object entry as the first argument: CO_OBJ * obj = CODictFind ( & demo . Dict , CO_DEV ( 0x1234 , 0x56 )); do { COObjRdValue ( obj , & demo , & value , sizeof ( value )); } while ( value == 0 ); Parameter Objects # The CANopen stack provides service functions, a callback interface and a system object type for managing parameters. The parameters are handled in parameter groups. The parameter group memory must be a consecutive memory area. The recommended way to allocate this memory area is shown in the following example: struct DEMO_PARA_T { uint32_t ParaLong ; /* storable 32bit parameter value */ uint16_t ParaWord ; /* storable 16bit parameter value */ uint8_t ParaByte ; /* storable 8bit parameter value */ } DemoParaMem ; The parameter group object holds all necessary information, which are needed for the parameter handling. This structure may be placed into ROM because it holds only constant values. const CO_PARA { 0L , /* start address in non-volatile memory */ sizeof ( struct DEMO_PARA_T ), /* size of parameter memory */ & DemoParaMem , /* start address of parameter memory */ & DemoParaDef , /* start address of default parameters */ CO_RESET_NODE , /* reset type for reload parameter */ ( void * ) \"DemoParaId\" , /* user parameter identification */ CO_PARA___E /* enable parameter storage on cmd */ } DemoParaObj ; If this parameter group is controllable from the CAN network side, the standard parameter save object (and optionally the parameter load object) is placed into the standard defined location of the object dictionary. The following example shows the object entry for save all parameters : const CO_OBJ DemoOD [] = { : { CO_KEY ( 0x1010 , 1 , CO_OBJ_____RW ), CO_TPARA_STORE , ( CO_DATA )( & DemoParaObj ) }, : }; The parameter values itself can be used within any object directory entry. The following example shows the usage of the demo parameter of the parameter group DemoParaMem within a hypothetical object entry with index 0x2345 and subindex 0x56: const CO_OBJ DemoOD [] = { : { CO_KEY ( 0x2345 , 0x56 , CO_OBJ_____RW ), CO_TUNSIGNED32 , ( CO_DATA )( & ( DemoParaMem . ParaLong )) }, { CO_KEY ( 0x2345 , 0x57 , CO_OBJ_____RW ), CO_TUNSIGNED16 , ( CO_DATA )( & ( DemoParaMem . ParaWord )) }, { CO_KEY ( 0x2345 , 0x58 , CO_OBJ_____RW ), CO_TUNSIGNED8 , ( CO_DATA )( & ( DemoParaMem . ParaByte )) }, : }; If a parameter group must be controllable from the node application side, the API function group COPara\u2026() is provided. The following line stores the given parameter group in NVM. COParaStore ( & DemoParaObj , & demo ); /* store parameter group */ The following diagram shows the internal behavior of storing a parameter object: sequenceDiagram participant A as Application participant P as demo.Para A->>+P: COParaStore() P->>+A: callback CP_SavePara() A-->>-P: ok P-->>-A: ok Domain Objects # The CANopen stack provides a system object type for managing domains. The domain memory must be a consecutive memory area. The recommended way to allocate this memory area is shown in the following example: uint8_t DemoDomainMem [ DEMO_DOMAIN_SIZE ]; /* domain memory area */ The domain object holds all necessary information, which is needed for domain handling. CO_OBJ_DOM DemoDomainObj = { 0 , /* variable for read position */ DEMO_DOMAIN_SIZE , /* size of domain memory */ & DemoDomainMem [ 0 ] /* start address of domain memory */ }; To enable the usage of this domain to the CAN network side, the domain object must be added to the object directory. See the following object entry with index=0x2345 and subindex=0 as an example: const CO_OBJ DemoOD [] = { : { CO_KEY ( 0x2345 , 0 , CO_OBJ_____RW ), CO_TDOMAIN , ( CO_DATA )( & DemoDomainObj ) }, : }; String Objects # The CANopen stack provides a system object type for managing strings. The strings are assumed to be read-only data. The recommended way to allocate this string memory is shown in the following example: const uint8_t DemoString [] = \"Hello World!\" ; /* string memory */ The string object holds all necessary information, which are needed for the string handling. CO_OBJ_STR DemoStringObj = { 0 , /* variable for read position */ & DemoString [ 0 ] /* start address of string memory */ }; To enable the usage of this string to the CAN network side, the string must be added to the object directory. See the following object entry with index=0x3456 and subindex=0 as an example: const CO_OBJ DemoOD [] = { : { CO_KEY ( 0x3456 , 0 , CO_OBJ_____R_ ), CO_TSTRING , ( CO_DATA )( & DemoStringObj ) }, : }; User Objects # User type objects are provided to implement special behavior of read and/or write access to an object entry. The complex system types are using this mechanism to provide the specified behavior of several pre-defined CANopen object entries. The implemented access functions (called \"type functions\") are used for any access to the object entry, regardless of the accessing component (CAN network via CAN messages or the application via the API functions). An example user type (called \"DemoType\") is declared with the following structure. CO_OBJ_TYPE DemoType = { DemoSize , /* type function to get object size */ DemoInit , /* type function to initialize type object */ DemoRead , /* type function to read object content */ DemoWrite , /* type function to write object content */ DemoReset /* type function to reset the object */ }; If a new user type didn't need to have special behavior on initialization or reset events, the corresponding type function can be set to 0 to ignore potential calls and just return no error. The following list shows the type function prototypes. The return value of the size type function (e.g. DemoSize() ) shall return the size of the user type in bytes. The other type functions shall return CO_ERR_NONE after the successful operation. If an error is detected the corresponding error codes must be returned: CO_ERR_TYPE_RD , CO_ERR_TYPE_WR , CO_ERR_TYPE_INIT , or CO_ERR_TYPE_RESET . uint32_t DemoSize ( CO_OBJ * obj , CO_NODE * node , uint32_t width ); CO_ERR DemoInit ( CO_OBJ * obj , CO_NODE * node ); CO_ERR DemoRead ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ); CO_ERR DemoWrite ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ); CO_ERR DemoReset ( CO_OBJ * obj , CO_NODE * node , uint32_t para ); To enable the usage of this demo type to the CAN network side, the demo object must be added to the object directory. See the following object entry with index=0x6789 and subindex=0 as an example: #define CO_TDEMO ((CO_OBJ_TYPE*)&DemoType) const CO_OBJ DemoOD [] = { : { CO_KEY ( 0x6789 , 0 , CO_OBJ_____RW ), CO_TDEMO , ( CO_DATA )( & DemoValue ) }, : }; The following diagram shows the internal behavior of read access to the user type object: sequenceDiagram participant A as Application participant D as demo.Dir participant O as demo.Obj participant T as DemoType A->>+D: CODirRdLong() D->>+O: COObjRdValue() O->>+T: DemoSize() T-->>-O: size O->>+T: DemoRead() T-->>-O: value O-->>-D: value D-->>-A: value FAQ # How can I access the object size when implementing a type function? The parameter size in the functions DemoRead() and DemoWrite() is the size of the data, given via the pointer buffer . If you want to use the width of the object entry, you can use the following snippet: CO_ERR DemoRead ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ) { uint32_t width = COObjGetSize ( obj , node , 0 ); /* now you can handle your data with: * - size (number of bytes in buffer) * - width (number of bytes in object entry) * Note: you can trust, that the indicated SDO transfer size (if given) * is equal to the width (checked by the SDO server) */ } How can I set a non-standard ABORT codes when implementing a type function? When you need to control the ABORT codes of SDO expedited transfers, you can use the function COObjTypeUserSDOAbort() to set a user defined SDO abort code within your type functions: CO_ERR DemoWrite ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ) { : if ( /* your error condition */ ) { /* the given abort code is considered in SDO transfers only! */ COObjTypeUserSDOAbort ( obj , node , 0x12345678 ); return CO_ERR_TYPE_WR ; } : } How can I use the basic type functions when implemeting a type function? When you want to change the behavior of writing to a basic object entry but keep reading this entry unchanged, you need to implement a type function set with Size , Read , and Write . The Size and Read type functions can be reused from the standard implementation. In the following example we reuse the CO_TUNSIGNED32 implementation: /* define your new type interface */ const CO_OBJ_TYPE MyType = { MyTypeSize , 0 , MyTypeRead , MyTypeWrite }; uint32_t MyTypeSize ( CO_OBJ * obj , CO_NODE * node , uint32_t width ) { /* get base type and re-use it for the size function */ const CO_OBJ_TYPE * uint32 = CO_TUNSIGNED32 ; return uint32 -> Size ( obj , node , width ); } CO_ERR MyTypeRead ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ) { /* get base type and re-use it for the read function */ const CO_OBJ_TYPE * uint32 = CO_TUNSIGNED32 ; return uint32 -> Read ( obj , node , buffer , size ); } CO_ERR MyTypeWrite ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ) { /* place here your implementation for the write function */ }","title":"Using Object Dictionary"},{"location":"usage/dictionary/#using-object-dictionary","text":"","title":"Using Object Dictionary"},{"location":"usage/dictionary/#object-dictionary","text":"The main interface within the CANopen network is the object dictionary of the CANopen nodes. The object dictionary of a node is accessible from the network as well as from the node application. The definition of the object dictionary table is done with an array of object entries of the type CO_OBJ . A small example is shown below: const CO_OBJ DemoOD [] = { : /* PDO mappable read-only value: */ { CO_KEY ( 0x1001 , 0 , CO_OBJ____PR_ ), CO_TUNSIGNED8 , ( CO_DATA )( & DemoErrReg ) }, /* Read-only value, which depends on Node-ID: */ { CO_KEY ( 0x1014 , 0 , CO_OBJ__N__R_ ), CO_TUNSIGNED32 , ( CO_DATA )( & DemoEmcyId ) }, /* In CO_DATA pointer memory stored constant value: */ { CO_KEY ( 0x2400 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 1 ) }, /* A normal 32bit process data entry: */ { CO_KEY ( 0x2400 , 1 , CO_OBJ_____RW ), CO_TUNSIGNED32 , ( CO_DATA )( & DemoVarLong )}, : /* mark the end of object dictionary: */ CO_OBJ_DICT_ENDMARK }; Important The CANopen Stack relies on a binary search algorithm to ensure that object dictionary entries are found quickly. Because of this, you must keep the index / subindex of all entries in the object dictionary sorted in ascending order. Note The object dictionary can manage different object entry types with different properties. This information is encoded within the object property flags and the object type functions and is described in detail in the configuration section. The update of the provided basic and system object types within the object dictionary is managed by the CANopen stack. The application may read or write these objects at any time. Use the service function groups CODict\u2026() and COObj\u2026() for accessing the object dictionary.","title":"Object Dictionary"},{"location":"usage/dictionary/#basic-objects","text":"The read and write access of basic object entries is symmetrical. Therefore the description is reduced to read access. The data width of basic objects is 8bit (byte), 16bit (word) or 32bit (long). All widths are handled in the same way, therefore the description is reduced to 32bit (long) object entries. For simple read access of a (hypothetical) 32bit object entry with an index=0x2345 and subindex=0x56, the service call is: CODictRdLong ( & demo . Dict , CO_DEV ( 0x2345 , 0x56 ), & value ); The following diagram shows the internal behavior of this service. sequenceDiagram participant A as Application participant D as demo.Dict participant O as demo.Obj A->>+D: CODictRdLong() D->>D: CODictFind() D->>+O: get size O-->>-D: size D->>+O: read object O-->>-D: value D-->>-A: value For multiple accesses to the same object entry, the following sequence reduces the performance overhead, which is based on searching within the object dictionary. The object read and write functions can take a previously searched object entry as the first argument: CO_OBJ * obj = CODictFind ( & demo . Dict , CO_DEV ( 0x1234 , 0x56 )); do { COObjRdValue ( obj , & demo , & value , sizeof ( value )); } while ( value == 0 );","title":"Basic Objects"},{"location":"usage/dictionary/#parameter-objects","text":"The CANopen stack provides service functions, a callback interface and a system object type for managing parameters. The parameters are handled in parameter groups. The parameter group memory must be a consecutive memory area. The recommended way to allocate this memory area is shown in the following example: struct DEMO_PARA_T { uint32_t ParaLong ; /* storable 32bit parameter value */ uint16_t ParaWord ; /* storable 16bit parameter value */ uint8_t ParaByte ; /* storable 8bit parameter value */ } DemoParaMem ; The parameter group object holds all necessary information, which are needed for the parameter handling. This structure may be placed into ROM because it holds only constant values. const CO_PARA { 0L , /* start address in non-volatile memory */ sizeof ( struct DEMO_PARA_T ), /* size of parameter memory */ & DemoParaMem , /* start address of parameter memory */ & DemoParaDef , /* start address of default parameters */ CO_RESET_NODE , /* reset type for reload parameter */ ( void * ) \"DemoParaId\" , /* user parameter identification */ CO_PARA___E /* enable parameter storage on cmd */ } DemoParaObj ; If this parameter group is controllable from the CAN network side, the standard parameter save object (and optionally the parameter load object) is placed into the standard defined location of the object dictionary. The following example shows the object entry for save all parameters : const CO_OBJ DemoOD [] = { : { CO_KEY ( 0x1010 , 1 , CO_OBJ_____RW ), CO_TPARA_STORE , ( CO_DATA )( & DemoParaObj ) }, : }; The parameter values itself can be used within any object directory entry. The following example shows the usage of the demo parameter of the parameter group DemoParaMem within a hypothetical object entry with index 0x2345 and subindex 0x56: const CO_OBJ DemoOD [] = { : { CO_KEY ( 0x2345 , 0x56 , CO_OBJ_____RW ), CO_TUNSIGNED32 , ( CO_DATA )( & ( DemoParaMem . ParaLong )) }, { CO_KEY ( 0x2345 , 0x57 , CO_OBJ_____RW ), CO_TUNSIGNED16 , ( CO_DATA )( & ( DemoParaMem . ParaWord )) }, { CO_KEY ( 0x2345 , 0x58 , CO_OBJ_____RW ), CO_TUNSIGNED8 , ( CO_DATA )( & ( DemoParaMem . ParaByte )) }, : }; If a parameter group must be controllable from the node application side, the API function group COPara\u2026() is provided. The following line stores the given parameter group in NVM. COParaStore ( & DemoParaObj , & demo ); /* store parameter group */ The following diagram shows the internal behavior of storing a parameter object: sequenceDiagram participant A as Application participant P as demo.Para A->>+P: COParaStore() P->>+A: callback CP_SavePara() A-->>-P: ok P-->>-A: ok","title":"Parameter Objects"},{"location":"usage/dictionary/#domain-objects","text":"The CANopen stack provides a system object type for managing domains. The domain memory must be a consecutive memory area. The recommended way to allocate this memory area is shown in the following example: uint8_t DemoDomainMem [ DEMO_DOMAIN_SIZE ]; /* domain memory area */ The domain object holds all necessary information, which is needed for domain handling. CO_OBJ_DOM DemoDomainObj = { 0 , /* variable for read position */ DEMO_DOMAIN_SIZE , /* size of domain memory */ & DemoDomainMem [ 0 ] /* start address of domain memory */ }; To enable the usage of this domain to the CAN network side, the domain object must be added to the object directory. See the following object entry with index=0x2345 and subindex=0 as an example: const CO_OBJ DemoOD [] = { : { CO_KEY ( 0x2345 , 0 , CO_OBJ_____RW ), CO_TDOMAIN , ( CO_DATA )( & DemoDomainObj ) }, : };","title":"Domain Objects"},{"location":"usage/dictionary/#string-objects","text":"The CANopen stack provides a system object type for managing strings. The strings are assumed to be read-only data. The recommended way to allocate this string memory is shown in the following example: const uint8_t DemoString [] = \"Hello World!\" ; /* string memory */ The string object holds all necessary information, which are needed for the string handling. CO_OBJ_STR DemoStringObj = { 0 , /* variable for read position */ & DemoString [ 0 ] /* start address of string memory */ }; To enable the usage of this string to the CAN network side, the string must be added to the object directory. See the following object entry with index=0x3456 and subindex=0 as an example: const CO_OBJ DemoOD [] = { : { CO_KEY ( 0x3456 , 0 , CO_OBJ_____R_ ), CO_TSTRING , ( CO_DATA )( & DemoStringObj ) }, : };","title":"String Objects"},{"location":"usage/dictionary/#user-objects","text":"User type objects are provided to implement special behavior of read and/or write access to an object entry. The complex system types are using this mechanism to provide the specified behavior of several pre-defined CANopen object entries. The implemented access functions (called \"type functions\") are used for any access to the object entry, regardless of the accessing component (CAN network via CAN messages or the application via the API functions). An example user type (called \"DemoType\") is declared with the following structure. CO_OBJ_TYPE DemoType = { DemoSize , /* type function to get object size */ DemoInit , /* type function to initialize type object */ DemoRead , /* type function to read object content */ DemoWrite , /* type function to write object content */ DemoReset /* type function to reset the object */ }; If a new user type didn't need to have special behavior on initialization or reset events, the corresponding type function can be set to 0 to ignore potential calls and just return no error. The following list shows the type function prototypes. The return value of the size type function (e.g. DemoSize() ) shall return the size of the user type in bytes. The other type functions shall return CO_ERR_NONE after the successful operation. If an error is detected the corresponding error codes must be returned: CO_ERR_TYPE_RD , CO_ERR_TYPE_WR , CO_ERR_TYPE_INIT , or CO_ERR_TYPE_RESET . uint32_t DemoSize ( CO_OBJ * obj , CO_NODE * node , uint32_t width ); CO_ERR DemoInit ( CO_OBJ * obj , CO_NODE * node ); CO_ERR DemoRead ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ); CO_ERR DemoWrite ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ); CO_ERR DemoReset ( CO_OBJ * obj , CO_NODE * node , uint32_t para ); To enable the usage of this demo type to the CAN network side, the demo object must be added to the object directory. See the following object entry with index=0x6789 and subindex=0 as an example: #define CO_TDEMO ((CO_OBJ_TYPE*)&DemoType) const CO_OBJ DemoOD [] = { : { CO_KEY ( 0x6789 , 0 , CO_OBJ_____RW ), CO_TDEMO , ( CO_DATA )( & DemoValue ) }, : }; The following diagram shows the internal behavior of read access to the user type object: sequenceDiagram participant A as Application participant D as demo.Dir participant O as demo.Obj participant T as DemoType A->>+D: CODirRdLong() D->>+O: COObjRdValue() O->>+T: DemoSize() T-->>-O: size O->>+T: DemoRead() T-->>-O: value O-->>-D: value D-->>-A: value","title":"User Objects"},{"location":"usage/dictionary/#faq","text":"How can I access the object size when implementing a type function? The parameter size in the functions DemoRead() and DemoWrite() is the size of the data, given via the pointer buffer . If you want to use the width of the object entry, you can use the following snippet: CO_ERR DemoRead ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ) { uint32_t width = COObjGetSize ( obj , node , 0 ); /* now you can handle your data with: * - size (number of bytes in buffer) * - width (number of bytes in object entry) * Note: you can trust, that the indicated SDO transfer size (if given) * is equal to the width (checked by the SDO server) */ } How can I set a non-standard ABORT codes when implementing a type function? When you need to control the ABORT codes of SDO expedited transfers, you can use the function COObjTypeUserSDOAbort() to set a user defined SDO abort code within your type functions: CO_ERR DemoWrite ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ) { : if ( /* your error condition */ ) { /* the given abort code is considered in SDO transfers only! */ COObjTypeUserSDOAbort ( obj , node , 0x12345678 ); return CO_ERR_TYPE_WR ; } : } How can I use the basic type functions when implemeting a type function? When you want to change the behavior of writing to a basic object entry but keep reading this entry unchanged, you need to implement a type function set with Size , Read , and Write . The Size and Read type functions can be reused from the standard implementation. In the following example we reuse the CO_TUNSIGNED32 implementation: /* define your new type interface */ const CO_OBJ_TYPE MyType = { MyTypeSize , 0 , MyTypeRead , MyTypeWrite }; uint32_t MyTypeSize ( CO_OBJ * obj , CO_NODE * node , uint32_t width ) { /* get base type and re-use it for the size function */ const CO_OBJ_TYPE * uint32 = CO_TUNSIGNED32 ; return uint32 -> Size ( obj , node , width ); } CO_ERR MyTypeRead ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ) { /* get base type and re-use it for the read function */ const CO_OBJ_TYPE * uint32 = CO_TUNSIGNED32 ; return uint32 -> Read ( obj , node , buffer , size ); } CO_ERR MyTypeWrite ( CO_OBJ * obj , CO_NODE * node , void * buffer , uint32_t size ) { /* place here your implementation for the write function */ }","title":"FAQ"},{"location":"usage/emergency/","text":"Emergency Errors # Managing Emergency Errors # The CANopen stack provides service API functions for managing the emergency events within the application. The handling of EMCY transmission events, the error register and EMCY history management within the object directory is handled within the CANopen stack. For managing the emergency errors the service function group COEmcy\u2026() is provided. Emergency Codes # The emergency error codes and the properties of the emergency errors are specified within the configuration. The following example shows the emergency error specification table: const CO_EMCY_TBL DemoEmcyCode [ CO_EMCY_N ] = { { /*--- emercency: #0 -----*/ CO_EMCY_REG_GENERAL , /* error register bit */ CO_EMCY_CODE_GEN_ERR + 0x0010 /* emergency error code */ }, { /*--- emercency: #1 -----*/ CO_EMCY_REG_VOLTAGE , /* error register bit */ CO_EMCY_CODE_VOL_ERR + 0x0001 /* emergency error code */ }, : }; When using emergency errors, the emergency code is the key for the service functions. Additional to the specific emergency code, user data may be stored or transmitted with each emergency change event. The user data is allocated as a local structure which will be given as a parameter to the service functions. Due to the fact, that the user data for transmission and internal history has different sizes, the following structure is provided for the user data fields: CO_EMCY_USR DemoEmcyUsr = { 0x1234 , /* 16bit User Data for History */ { 0x11 , 0x22 , 0x33 , 0x44 , 0x55 } /* 5byte User Data for EMCY-Msg */ }; Note: The user data fields for history and/or message can be disabled with two separate configuration settings. Emergency Event # The application can focus on the detection of system situations, which shall rise an emergency event. For setting and clearing an emergency #0 on an application-specific emergency condition, the typical sequence is: if ( DemoEmcyCondition == TRUE ) { COEmcySet ( & demo . Emcy , 0 , & DemoEmcyUsr ); } else { COEmcyClr ( & demo . Emcy , 0 ); } The setting and clearing functions are very similar. Therefore the following diagram shows the internal behavior of the service for setting an emergency error: sequenceDiagram participant A as Application participant E as demo.Emcy participant D as demo.Dir participant I as demo.If A->>+E: COEmcySet() alt new emergency E->>D: add emcy to history E->>D: set error register E->>I: send EMCY message end E-->>-A: ok Emergency State # The CANopen stack provides service functions to get internal information of the emergency error management. This simplifies the realization of central error management within the CANopen device. The following example returns the number of currently active emergency errors: num = COEmcyCnt ( & demo . Emcy );","title":"Emergency Errors"},{"location":"usage/emergency/#emergency-errors","text":"","title":"Emergency Errors"},{"location":"usage/emergency/#managing-emergency-errors","text":"The CANopen stack provides service API functions for managing the emergency events within the application. The handling of EMCY transmission events, the error register and EMCY history management within the object directory is handled within the CANopen stack. For managing the emergency errors the service function group COEmcy\u2026() is provided.","title":"Managing Emergency Errors"},{"location":"usage/emergency/#emergency-codes","text":"The emergency error codes and the properties of the emergency errors are specified within the configuration. The following example shows the emergency error specification table: const CO_EMCY_TBL DemoEmcyCode [ CO_EMCY_N ] = { { /*--- emercency: #0 -----*/ CO_EMCY_REG_GENERAL , /* error register bit */ CO_EMCY_CODE_GEN_ERR + 0x0010 /* emergency error code */ }, { /*--- emercency: #1 -----*/ CO_EMCY_REG_VOLTAGE , /* error register bit */ CO_EMCY_CODE_VOL_ERR + 0x0001 /* emergency error code */ }, : }; When using emergency errors, the emergency code is the key for the service functions. Additional to the specific emergency code, user data may be stored or transmitted with each emergency change event. The user data is allocated as a local structure which will be given as a parameter to the service functions. Due to the fact, that the user data for transmission and internal history has different sizes, the following structure is provided for the user data fields: CO_EMCY_USR DemoEmcyUsr = { 0x1234 , /* 16bit User Data for History */ { 0x11 , 0x22 , 0x33 , 0x44 , 0x55 } /* 5byte User Data for EMCY-Msg */ }; Note: The user data fields for history and/or message can be disabled with two separate configuration settings.","title":"Emergency Codes"},{"location":"usage/emergency/#emergency-event","text":"The application can focus on the detection of system situations, which shall rise an emergency event. For setting and clearing an emergency #0 on an application-specific emergency condition, the typical sequence is: if ( DemoEmcyCondition == TRUE ) { COEmcySet ( & demo . Emcy , 0 , & DemoEmcyUsr ); } else { COEmcyClr ( & demo . Emcy , 0 ); } The setting and clearing functions are very similar. Therefore the following diagram shows the internal behavior of the service for setting an emergency error: sequenceDiagram participant A as Application participant E as demo.Emcy participant D as demo.Dir participant I as demo.If A->>+E: COEmcySet() alt new emergency E->>D: add emcy to history E->>D: set error register E->>I: send EMCY message end E-->>-A: ok","title":"Emergency Event"},{"location":"usage/emergency/#emergency-state","text":"The CANopen stack provides service functions to get internal information of the emergency error management. This simplifies the realization of central error management within the CANopen device. The following example returns the number of currently active emergency errors: num = COEmcyCnt ( & demo . Emcy );","title":"Emergency State"},{"location":"usage/overview/","text":"CANopen Stack Overview # CANopen stack actions # In the architecture we see, that the CANopen stack is the connection between the CAN network and the application. The central information store is the object dictionary which is used to control the behavior of the device, transmit and receive process data or configure runtime parameters. In principle, all of these activities can initiated by external devices in the CAN network, or the internal CANopen application. The following chapters gives an overall of the possible scenarios. Autonomous external request # An autonomous external request is initiated by an external device and is handled by the CANopen stack according to the standard. No interaction with the application is necessary. sequenceDiagram participant C as CAN Network participant N as CANopen Stack participant A as Application C->>+N: external request N-->>-C: response An example for this type of request is the SDO access to an object entry. Therefore, there is nothing to do in the application. It is important to know the CANopen standard CiA-301 to know how to configure the CANopen stack responses within the object dictionary. External request # An external request is similar to the autonomous external request with the difference that the application needs to provide a callback function to realize the application-specific behavior. sequenceDiagram participant C as CAN Network participant N as CANopen Stack participant A as Application C->>+N: external request N->>+A: call callback function A-->>-N: return N-->>-C: response An example for this type of request is the parameter store request which uses the parameter write callback from the application. The Callback functions are documented in the CANopen usage category Callback: Category Content Callback Interface description of all callback functions Internal request # An internal request is an API function call initiated by the application. sequenceDiagram participant C as CAN Network participant N as CANopen Stack participant A as Application A->>+N: API function call N-->>-A: return An example for this type of request is the update of a value in an object entry. The API functions are documented in some categories within the chapter API Functions: Category Content CANopen Node controlling the node (init, start, stop, etc. ) Object Dictionary basic reading and writing in the object dictionary EMCY Handling handle and communicate emergency errors (set, clear, etc.) Network Management local network management (set/get modes, node-ID, etc.) Object Entry read and write object entries of any type and size TPDO Event triggering the transmission of TPDO","title":"CANopen Stack Overview"},{"location":"usage/overview/#canopen-stack-overview","text":"","title":"CANopen Stack Overview"},{"location":"usage/overview/#canopen-stack-actions","text":"In the architecture we see, that the CANopen stack is the connection between the CAN network and the application. The central information store is the object dictionary which is used to control the behavior of the device, transmit and receive process data or configure runtime parameters. In principle, all of these activities can initiated by external devices in the CAN network, or the internal CANopen application. The following chapters gives an overall of the possible scenarios.","title":"CANopen stack actions"},{"location":"usage/overview/#autonomous-external-request","text":"An autonomous external request is initiated by an external device and is handled by the CANopen stack according to the standard. No interaction with the application is necessary. sequenceDiagram participant C as CAN Network participant N as CANopen Stack participant A as Application C->>+N: external request N-->>-C: response An example for this type of request is the SDO access to an object entry. Therefore, there is nothing to do in the application. It is important to know the CANopen standard CiA-301 to know how to configure the CANopen stack responses within the object dictionary.","title":"Autonomous external request"},{"location":"usage/overview/#external-request","text":"An external request is similar to the autonomous external request with the difference that the application needs to provide a callback function to realize the application-specific behavior. sequenceDiagram participant C as CAN Network participant N as CANopen Stack participant A as Application C->>+N: external request N->>+A: call callback function A-->>-N: return N-->>-C: response An example for this type of request is the parameter store request which uses the parameter write callback from the application. The Callback functions are documented in the CANopen usage category Callback: Category Content Callback Interface description of all callback functions","title":"External request"},{"location":"usage/overview/#internal-request","text":"An internal request is an API function call initiated by the application. sequenceDiagram participant C as CAN Network participant N as CANopen Stack participant A as Application A->>+N: API function call N-->>-A: return An example for this type of request is the update of a value in an object entry. The API functions are documented in some categories within the chapter API Functions: Category Content CANopen Node controlling the node (init, start, stop, etc. ) Object Dictionary basic reading and writing in the object dictionary EMCY Handling handle and communicate emergency errors (set, clear, etc.) Network Management local network management (set/get modes, node-ID, etc.) Object Entry read and write object entries of any type and size TPDO Event triggering the transmission of TPDO","title":"Internal request"},{"location":"usage/tpdo/","text":"Transmit PDO # Triggering PDO Transmission # The CANopen stack provides service functions for triggering PDO transmission on application or profile-specific events. In general, we can trigger the transmission of a PDO in the following ways: Time Trigger - transmit the configured PDO in a configured time interval Application Trigger - transmit the given PDO immediatelly Object Trigger - transmit all PDOs with a configured mapping to a given object entry immediatelly Object Change - transmit all PDOs with a configured mapping to an object which is marked as asynchronous on changed values For the detailed object dictionary description for the TPDO communication settings, see Transmit PDO Communication Timer Trigger # For a constant timer based sending as defined in the CiA standards we need to prepare the PDO communication entries accordingly: : { CO_KEY ( 0x1800 , 0 , CO_OBJ_D___R_ ), CO_UNSIGNED8 , ( CO_DATA )( 5 )}, { CO_KEY ( 0x1800 , 1 , CO_OBJ_D___R_ ), CO_UNSIGNED32 , ( CO_DATA )( CO_COBID_TPDO_DEFAULT ( 0 ))}, { CO_KEY ( 0x1800 , 2 , CO_OBJ_D___R_ ), CO_UNSIGNED8 , ( CO_DATA )( 0xfe )}, { CO_KEY ( 0x1800 , 3 , CO_OBJ_D___R_ ), CO_UNSIGNED16 , ( CO_DATA )( 0 )}, { CO_KEY ( 0x1800 , 5 , CO_OBJ_D___R_ ), CO_TPDO_EVENT , ( CO_DATA )( 60 )}, : In this example, the transmission trigger for the TPDO #0 is managed by the stack. The time interval is defined in subindex 5 (in the example 60ms). Application Trigger # Transmit with the application API function call is the foundation for other internal possibilities. You may use this in your application, too. For example you can transmit a PDO when a complex logical expression between multiple objects is valid. COTPdoTrigPdo ( & demo . TPdo , 2 ); /* trigger TPDO #2 */ Object Trigger # For triggering the transmission of all TPDOs, which has an active mapping entry to a given object directory entry, the service call is: COTPdoTrigObj ( & demo . TPdo , obj ); /* trigger TPDOs via object */ The following diagram shows the internal behavior of this service. sequenceDiagram participant A as Application participant P as demo.TPdo A->>+P: COTPdoTrigObj() loop all PDOs with mapped object P->>P: trigger PDO transmission end P-->>-A: ok Object Change # The transmit on change of an object entry is described in the quickstart. This transmission is handled by the stack and is configured in the object dictionary: : { CO_KEY ( 0x1800 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 2 )}, { CO_KEY ( 0x1800 , 1 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( CO_COBID_TPDO_DEFAULT ( 0 ))}, { CO_KEY ( 0x1800 , 2 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 254 )}, { CO_KEY ( 0x1800 , 3 , CO_OBJ_D___R_ ), CO_TUNSIGNED16 , ( CO_DATA )( 100 )}, : { CO_KEY ( 0x1A00 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 1 )}, { CO_KEY ( 0x1A00 , 1 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( CO_LINK ( 0x2100 , 0x01 , 32 ))}, : { CO_KEY ( 0x2100 , 1 , CO_OBJ___APRW ), CO_TUNSIGNED32 , ( CO_DATA )( & MyValue )}, : This example triggers the transmission of TPDO #0 when the value of the mapped object 2100h:01h is changed by the API function COObjWrValue() . : uint32_t value ; CO_OBJ * entry ; : entry = CODictFind ( & ( AppNode . Dict ), CO_DEV ( 0x2100 , 0x01 )); err = COObjRdValue ( entry , & AppNode , & value , sizeof ( value ), 0 ); : value ++ ; /* only a changed value will trigger the PDO transmission! */ : err = COObjWrValue ( entry , & AppNode , & value , sizeof ( value ); 0 ); : Note When using this mode, the setting of the inhibit time is recommended in case the object changes often (e.g. an unfiltered ADC value). This prohibits the CAN bus from overloaded PDO transmissions. In the example we limit the shortest time between two transmissions to 100 * 100us = 10ms. Synchronized communication # Transmit the configured PDO after receiving a configured number of SYNC messages SYNC Producer # For triggering the PDO transmissions on all remote nodes in the network, we need to produce the SYNC messages. This CANopen stack supports the generation of SYNC messages by simply adding the following object entries to your object dictionary: uint32_t obj1005 = CO_SYNC_COBID_ON | 0x80 ; /* enable sync producer */ uint32_t obj1006 = 20 * 1000 ; /* sync cycle-time 20ms in us */ : { CO_KEY ( 0x1005 , 0 , CO_OBJ_____RW ), CO_TSYNC_ID , ( CO_DATA )( & obj1005 )}, { CO_KEY ( 0x1006 , 0 , CO_OBJ_____RW ), CO_TSYNC_CYCLE , ( CO_DATA )( & obj1006 )}, : Note There is only one SYNC producer within the CANopen network allowed. Therefore, you most likely need the dynamic model which allows enabling/disabling of the SYNC producer during the CANopen network configuration process. SYNC Consumer # The CiA standard defines synchronous PDO transfers, too. This allows the transmission trigger for the corresponding PDO is activated after the configured number of SYNC messages: : { CO_KEY ( 0x1807 , 0 , CO_OBJ_D___R_ ), CO_UNSIGNED8 , ( CO_DATA )( 2 )}, { CO_KEY ( 0x1807 , 1 , CO_OBJ_D___R_ ), CO_UNSIGNED32 , ( CO_DATA )( CO_COBID_TPDO_DEFAULT ( 0 ))}, { CO_KEY ( 0x1807 , 2 , CO_OBJ_D___R_ ), CO_UNSIGNED8 , ( CO_DATA )( 0x4 )}, : In this example, the TPDO #7 is triggered after the receiption of every 4-th SYNC message (defined in subindex 2). Note The standard entries for subindex 3 and 5 are not used. Therefore, we adjust the highest subindex in object entry with subindex 00h.","title":"Transmit PDO"},{"location":"usage/tpdo/#transmit-pdo","text":"","title":"Transmit PDO"},{"location":"usage/tpdo/#triggering-pdo-transmission","text":"The CANopen stack provides service functions for triggering PDO transmission on application or profile-specific events. In general, we can trigger the transmission of a PDO in the following ways: Time Trigger - transmit the configured PDO in a configured time interval Application Trigger - transmit the given PDO immediatelly Object Trigger - transmit all PDOs with a configured mapping to a given object entry immediatelly Object Change - transmit all PDOs with a configured mapping to an object which is marked as asynchronous on changed values For the detailed object dictionary description for the TPDO communication settings, see Transmit PDO Communication","title":"Triggering PDO Transmission"},{"location":"usage/tpdo/#timer-trigger","text":"For a constant timer based sending as defined in the CiA standards we need to prepare the PDO communication entries accordingly: : { CO_KEY ( 0x1800 , 0 , CO_OBJ_D___R_ ), CO_UNSIGNED8 , ( CO_DATA )( 5 )}, { CO_KEY ( 0x1800 , 1 , CO_OBJ_D___R_ ), CO_UNSIGNED32 , ( CO_DATA )( CO_COBID_TPDO_DEFAULT ( 0 ))}, { CO_KEY ( 0x1800 , 2 , CO_OBJ_D___R_ ), CO_UNSIGNED8 , ( CO_DATA )( 0xfe )}, { CO_KEY ( 0x1800 , 3 , CO_OBJ_D___R_ ), CO_UNSIGNED16 , ( CO_DATA )( 0 )}, { CO_KEY ( 0x1800 , 5 , CO_OBJ_D___R_ ), CO_TPDO_EVENT , ( CO_DATA )( 60 )}, : In this example, the transmission trigger for the TPDO #0 is managed by the stack. The time interval is defined in subindex 5 (in the example 60ms).","title":"Timer Trigger"},{"location":"usage/tpdo/#application-trigger","text":"Transmit with the application API function call is the foundation for other internal possibilities. You may use this in your application, too. For example you can transmit a PDO when a complex logical expression between multiple objects is valid. COTPdoTrigPdo ( & demo . TPdo , 2 ); /* trigger TPDO #2 */","title":"Application Trigger"},{"location":"usage/tpdo/#object-trigger","text":"For triggering the transmission of all TPDOs, which has an active mapping entry to a given object directory entry, the service call is: COTPdoTrigObj ( & demo . TPdo , obj ); /* trigger TPDOs via object */ The following diagram shows the internal behavior of this service. sequenceDiagram participant A as Application participant P as demo.TPdo A->>+P: COTPdoTrigObj() loop all PDOs with mapped object P->>P: trigger PDO transmission end P-->>-A: ok","title":"Object Trigger"},{"location":"usage/tpdo/#object-change","text":"The transmit on change of an object entry is described in the quickstart. This transmission is handled by the stack and is configured in the object dictionary: : { CO_KEY ( 0x1800 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 2 )}, { CO_KEY ( 0x1800 , 1 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( CO_COBID_TPDO_DEFAULT ( 0 ))}, { CO_KEY ( 0x1800 , 2 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 254 )}, { CO_KEY ( 0x1800 , 3 , CO_OBJ_D___R_ ), CO_TUNSIGNED16 , ( CO_DATA )( 100 )}, : { CO_KEY ( 0x1A00 , 0 , CO_OBJ_D___R_ ), CO_TUNSIGNED8 , ( CO_DATA )( 1 )}, { CO_KEY ( 0x1A00 , 1 , CO_OBJ_D___R_ ), CO_TUNSIGNED32 , ( CO_DATA )( CO_LINK ( 0x2100 , 0x01 , 32 ))}, : { CO_KEY ( 0x2100 , 1 , CO_OBJ___APRW ), CO_TUNSIGNED32 , ( CO_DATA )( & MyValue )}, : This example triggers the transmission of TPDO #0 when the value of the mapped object 2100h:01h is changed by the API function COObjWrValue() . : uint32_t value ; CO_OBJ * entry ; : entry = CODictFind ( & ( AppNode . Dict ), CO_DEV ( 0x2100 , 0x01 )); err = COObjRdValue ( entry , & AppNode , & value , sizeof ( value ), 0 ); : value ++ ; /* only a changed value will trigger the PDO transmission! */ : err = COObjWrValue ( entry , & AppNode , & value , sizeof ( value ); 0 ); : Note When using this mode, the setting of the inhibit time is recommended in case the object changes often (e.g. an unfiltered ADC value). This prohibits the CAN bus from overloaded PDO transmissions. In the example we limit the shortest time between two transmissions to 100 * 100us = 10ms.","title":"Object Change"},{"location":"usage/tpdo/#synchronized-communication","text":"Transmit the configured PDO after receiving a configured number of SYNC messages","title":"Synchronized communication"},{"location":"usage/tpdo/#sync-producer","text":"For triggering the PDO transmissions on all remote nodes in the network, we need to produce the SYNC messages. This CANopen stack supports the generation of SYNC messages by simply adding the following object entries to your object dictionary: uint32_t obj1005 = CO_SYNC_COBID_ON | 0x80 ; /* enable sync producer */ uint32_t obj1006 = 20 * 1000 ; /* sync cycle-time 20ms in us */ : { CO_KEY ( 0x1005 , 0 , CO_OBJ_____RW ), CO_TSYNC_ID , ( CO_DATA )( & obj1005 )}, { CO_KEY ( 0x1006 , 0 , CO_OBJ_____RW ), CO_TSYNC_CYCLE , ( CO_DATA )( & obj1006 )}, : Note There is only one SYNC producer within the CANopen network allowed. Therefore, you most likely need the dynamic model which allows enabling/disabling of the SYNC producer during the CANopen network configuration process.","title":"SYNC Producer"},{"location":"usage/tpdo/#sync-consumer","text":"The CiA standard defines synchronous PDO transfers, too. This allows the transmission trigger for the corresponding PDO is activated after the configured number of SYNC messages: : { CO_KEY ( 0x1807 , 0 , CO_OBJ_D___R_ ), CO_UNSIGNED8 , ( CO_DATA )( 2 )}, { CO_KEY ( 0x1807 , 1 , CO_OBJ_D___R_ ), CO_UNSIGNED32 , ( CO_DATA )( CO_COBID_TPDO_DEFAULT ( 0 ))}, { CO_KEY ( 0x1807 , 2 , CO_OBJ_D___R_ ), CO_UNSIGNED8 , ( CO_DATA )( 0x4 )}, : In this example, the TPDO #7 is triggered after the receiption of every 4-th SYNC message (defined in subindex 2). Note The standard entries for subindex 3 and 5 are not used. Therefore, we adjust the highest subindex in object entry with subindex 00h.","title":"SYNC Consumer"}]}